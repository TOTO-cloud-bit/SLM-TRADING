# Module 1 

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLM TRADE - Bot de Trading Professionnel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0b0d;
            --bg-secondary: #1a1d21;
            --bg-tertiary: #2a2d33;
            --accent-green: #00d4aa;
            --accent-red: #ff6b6b;
            --accent-blue: #4f46e5;
            --accent-gold: #ffd700;
            --text-primary: #ffffff;
            --text-secondary: #a0a3a8;
            --text-muted: #6b7280;
            --border-color: #374151;
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
            --gradient-danger: linear-gradient(135deg, #ff6b6b 0%, #e74c3c 100%);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Animated Background */
        .bg-animated {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 212, 170, 0.3) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 10s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        /* Header */
        header {
            background: rgba(26, 29, 33, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-indicators {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected { background: var(--accent-green); }
        .status-dot.disconnected { background: var(--accent-red); }
        .status-dot.warning { background: var(--accent-gold); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Layout */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 2rem;
            min-height: calc(100vh - 120px);
        }

        /* Cards */
        .card {
            background: rgba(26, 29, 33, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-4px);
            border-color: var(--accent-blue);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Configuration Panel */
        .config-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
            transform: translateY(-1px);
        }

        .form-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }

        .btn-success {
            background: var(--gradient-success);
            color: white;
        }

        .btn-danger {
            background: var(--gradient-danger);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0px);
        }

        /* Trading Panel */
        .trading-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .trading-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .quick-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Chart Container */
        .chart-container {
            height: 400px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            color: var(--text-muted);
            position: relative;
            overflow: hidden;
        }

        .chart-placeholder {
            text-align: center;
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-item {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .stat-value.positive { color: var(--accent-green); }
        .stat-value.negative { color: var(--accent-red); }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Monitoring Panel */
        .monitoring-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .alert-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .alert-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .alert-success { background: var(--accent-green); color: white; }
        .alert-warning { background: var(--accent-gold); color: black; }
        .alert-error { background: var(--accent-red); color: white; }

        .alert-content {
            flex: 1;
        }

        .alert-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .alert-time {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Activity Log */
        .activity-log {
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
        }

        .log-entry {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
                padding: 0 1rem;
            }

            .main-container {
                padding: 1rem;
            }

            .trading-controls {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                flex-direction: column;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Glow Effects */
        .glow-success {
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.3);
        }

        .glow-danger {
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .4s;
            border-radius: 34px;
            border: 1px solid var(--border-color);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: var(--gradient-success);
            border-color: var(--accent-green);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="bg-animated"></div>
    
    <header>
        <div class="header-content">
            <div class="logo">
                <span>⚡</span>
                <span>SLM TRADE</span>
            </div>
            <div class="status-indicators">
                <div class="status-item">
                    <div class="status-dot connected"></div>
                    <span>API Bybit</span>
                </div>
                <div class="status-item">
                    <div class="status-dot connected"></div>
                    <span>WebSocket</span>
                </div>
                <div class="status-item">
                    <div class="status-dot warning"></div>
                    <span>Bot: Standby</span>
                </div>
            </div>
        </div>
    </header>

    <main class="main-container">
        <!-- Configuration Panel -->
        <section class="card config-panel">
            <div class="card-header">
                <h2 class="card-title">⚙️ Configuration</h2>
                <label class="toggle-switch">
                    <input type="checkbox" id="botToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="form-group">
                <label class="form-label">Paire de Trading</label>
                <select class="form-select" id="tradingPair">
                    <option value="BTCUSDT">BTC/USDT</option>
                    <option value="ETHUSDT">ETH/USDT</option>
                    <option value="ADAUSDT">ADA/USDT</option>
                    <option value="SOLUSDT">SOL/USDT</option>
                    <option value="DOTUSDT">DOT/USDT</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Montant par Trade (USDT)</label>
                <input type="number" class="form-input" id="tradeAmount" value="100" min="1" step="1">
            </div>

            <div class="form-group">
                <label class="form-label">Stop Loss (%)</label>
                <input type="number" class="form-input" id="stopLoss" value="2" min="0.1" step="0.1">
            </div>

            <div class="form-group">
                <label class="form-label">Take Profit (%)</label>
                <input type="number" class="form-input" id="takeProfit" value="3" min="0.1" step="0.1">
            </div>

            <div class="form-group">
                <label class="form-label">Stratégie</label>
                <select class="form-select" id="strategy">
                    <option value="scalping">Scalping</option>
                    <option value="swing">Swing Trading</option>
                    <option value="grid">Grid Trading</option>
                    <option value="dca">DCA</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Risk Management</label>
                <select class="form-select" id="riskLevel">
                    <option value="conservative">Conservateur</option>
                    <option value="moderate">Modéré</option>
                    <option value="aggressive">Agressif</option>
                </select>
            </div>

            <button class="btn btn-primary" id="saveConfig">
                💾 Sauvegarder Configuration
            </button>

            <button class="btn btn-outline" id="resetConfig">
                🔄 Reset par Défaut
            </button>
        </section>

        <!-- Trading Panel -->
        <section class="card trading-panel">
            <div class="card-header">
                <h2 class="card-title">📈 Trading Dashboard</h2>
                <div class="quick-actions">
                    <button class="btn btn-success" id="startBot">▶️ Démarrer</button>
                    <button class="btn btn-danger" id="stopBot">⏹️ Arrêter</button>
                    <button class="btn btn-outline" id="pauseBot">⏸️ Pause</button>
                </div>
            </div>

            <!-- Statistics -->
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value positive" id="totalProfit">+€0.00</div>
                    <div class="stat-label">Profit Total</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalTrades">0</div>
                    <div class="stat-label">Trades Total</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value positive" id="winRate">0%</div>
                    <div class="stat-label">Taux de Réussite</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="currentPrice">€0.00</div>
                    <div class="stat-label">Prix Actuel</div>
                </div>
            </div>

            <!-- Chart -->
            <div class="chart-container" id="tradingChart">
                <div class="chart-placeholder">
                    <div>📊 Graphique Trading</div>
                    <div style="font-size: 0.875rem; margin-top: 0.5rem;">
                        Le graphique sera intégré dans le Module 3
                    </div>
                </div>
            </div>

            <!-- Trading Controls -->
            <div class="trading-controls">
                <button class="btn btn-success" id="manualBuy">
                    📈 Achat Manuel
                </button>
                <button class="btn btn-danger" id="manualSell">
                    📉 Vente Manuel
                </button>
                <button class="btn btn-outline" id="closeAllPositions">
                    🚪 Fermer Toutes Positions
                </button>
                <button class="btn btn-outline" id="emergencyStop">
                    🚨 Arrêt d'Urgence
                </button>
            </div>
        </section>

        <!-- Monitoring Panel -->
        <section class="card monitoring-panel">
            <div class="card-header">
                <h2 class="card-title">🔍 Monitoring</h2>
                <span class="text-muted" id="lastUpdate">Dernière MAJ: --:--</span>
            </div>

            <!-- Alerts -->
            <div class="alerts-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">🚨 Alertes</h3>
                <div class="alert-item">
                    <div class="alert-icon alert-success">✓</div>
                    <div class="alert-content">
                        <div class="alert-title">Bot Connecté</div>
                        <div class="alert-time">Il y a 2 minutes</div>
                    </div>
                </div>
                <div class="alert-item">
                    <div class="alert-icon alert-warning">⚠</div>
                    <div class="alert-content">
                        <div class="alert-title">Volatilité Élevée</div>
                        <div class="alert-time">Il y a 5 minutes</div>
                    </div>
                </div>
            </div>

            <!-- Portfolio Info -->
            <div class="portfolio-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">💼 Portfolio</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="accountBalance">€0.00</div>
                        <div class="stat-label">Solde Compte</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="openPositions">0</div>
                        <div class="stat-label">Positions Ouvertes</div>
                    </div>
                </div>
            </div>

            <!-- Activity Log -->
            <div class="activity-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">📋 Activité Récente</h3>
                <div class="activity-log" id="activityLog">
                    <div class="log-entry">
                        <span>Bot démarré</span>
                        <span class="log-time">12:30:45</span>
                    </div>
                    <div class="log-entry">
                        <span>Configuration sauvegardée</span>
                        <span class="log-time">12:25:12</span>
                    </div>
                    <div class="log-entry">
                        <span>Connexion API établie</span>
                        <span class="log-time">12:20:33</span>
                    </div>
                </div>
            </div>

            <!-- API Status -->
            <div class="api-status">
                <button class="btn btn-outline" id="testConnection">
                    🔗 Test Connexion API
                </button>
                <button class="btn btn-outline" id="refreshData">
                    🔄 Actualiser Données
                </button>
            </div>
        </section>
    </main>

    <script>
        // Interface State Management
        class UIManager {
            constructor() {
                this.botActive = false;
                this.initializeEventListeners();
                this.updateTimestamp();
                setInterval(() => this.updateTimestamp(), 1000);
            }

            initializeEventListeners() {
                // Bot Toggle
                document.getElementById('botToggle').addEventListener('change', (e) => {
                    this.toggleBot(e.target.checked);
                });

                // Control Buttons
                document.getElementById('startBot').addEventListener('click', () => this.startBot());
                document.getElementById('stopBot').addEventListener('click', () => this.stopBot());
                document.getElementById('pauseBot').addEventListener('click', () => this.pauseBot());

                // Configuration
                document.getElementById('saveConfig').addEventListener('click', () => this.saveConfiguration());
                document.getElementById('resetConfig').addEventListener('click', () => this.resetConfiguration());

                // Manual Trading
                document.getElementById('manualBuy').addEventListener('click', () => this.executeManualTrade('BUY'));
                document.getElementById('manualSell').addEventListener('click', () => this.executeManualTrade('SELL'));

                // Emergency Actions
                document.getElementById('closeAllPositions').addEventListener('click', () => this.closeAllPositions());
                document.getElementById('emergencyStop').addEventListener('click', () => this.emergencyStop());

                // API Testing
                document.getElementById('testConnection').addEventListener('click', () => this.testAPIConnection());
                document.getElementById('refreshData').addEventListener('click', () => this.refreshData());
            }

            toggleBot(active) {
                this.botActive = active;
                this.updateBotStatus(active ? 'Active' : 'Standby');
                this.logActivity(active ? 'Bot activé' : 'Bot désactivé');
                
                if (active) {
                    this.showNotification('Bot démarré avec succès', 'success');
                } else {
                    this.showNotification('Bot arrêté', 'warning');
                }
            }

            startBot() {
                document.getElementById('botToggle').checked = true;
                this.toggleBot(true);
            }

            stopBot() {
                document.getElementById('botToggle').checked = false;
                this.toggleBot(false);
            }

            pauseBot() {
                this.updateBotStatus('En Pause');
                this.logActivity('Bot mis en pause');
                this.showNotification('Bot en pause', 'warning');
            }

            saveConfiguration() {
                const config = {
                    tradingPair: document.getElementById('tradingPair').value,
                    tradeAmount: document.getElementById('tradeAmount').value,
                    stopLoss: document.getElementById('stopLoss').value,
                    takeProfit: document.getElementById('takeProfit').value,
                    strategy: document.getElementById('strategy').value,
                    riskLevel: document.getElementById('riskLevel').value
                };

                // Simulate API call with loading
                const btn = document.getElementById('saveConfig');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Sauvegarde...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.logActivity('Configuration sauvegardée');
                    this.showNotification('Configuration sauvegardée', 'success');
                }, 1500);
            }

            resetConfiguration() {
                document.getElementById('tradingPair').value = 'BTCUSDT';
                document.getElementById('tradeAmount').value = '100';
                document.getElementById('stopLoss').value = '2';
                document.getElementById('takeProfit').value = '3';
                document.getElementById('strategy').value = 'scalping';
                document.getElementById('riskLevel').value = 'moderate';
                
                this.logActivity('Configuration réinitialisée');
                this.showNotification('Configuration réinitialisée', 'success');
            }

            executeManualTrade(type) {
                const amount = document.getElementById('tradeAmount').value;
                const pair = document.getElementById('tradingPair').value;
                
                this.logActivity(`Trade manuel ${type}: ${amount} USDT sur ${pair}`);
                this.showNotification(`Trade ${type} exécuté`, 'success');
                
                // Update stats (simulation)
                this.updateStats();
            }

            closeAllPositions() {
                this.logActivity('Fermeture de toutes les positions');
                this.showNotification('Toutes les positions fermées', 'warning');
                document.getElementById('openPositions').textContent = '0';
            }

            emergencyStop() {
                document.getElementById('botToggle').checked = false;
                this.toggleBot(false);
                this.closeAllPositions();
                this.showNotification('ARRÊT D\'URGENCE ACTIVÉ', 'error');
                this.logActivity('🚨 ARRÊT D\'URGENCE');
            }

            testAPIConnection() {
                const btn = document.getElementById('testConnection');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Test...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.logActivity('Test de connexion API réussi');
                    this.showNotification('Connexion API OK', 'success');
                }, 2000);
            }

            refreshData() {
                const btn = document.getElementById('refreshData');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Actualisation...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.updateStats();
                    this.logActivity('Données actualisées');
                    this.showNotification('Données mises à jour', 'success');
                }, 1500);
            }

            updateStats() {
                // Simulate real trading data
                const profits = [125.67, -45.23, 89.12, 234.56, -12.34];
                const randomProfit = profits[Math.floor(Math.random() * profits.length)];
                const totalTrades = Math.floor(Math.random() * 50) + 1;
                const winRate = Math.floor(Math.random() * 40) + 60;
                const currentPrice = (Math.random() * 50000 + 30000).toFixed(2);
                const balance = (Math.random() * 5000 + 1000).toFixed(2);

                document.getElementById('totalProfit').textContent = `${randomProfit >= 0 ? '+' : ''}€${randomProfit.toFixed(2)}`;
                document.getElementById('totalProfit').className = `stat-value ${randomProfit >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('totalTrades').textContent = totalTrades;
                document.getElementById('winRate').textContent = `${winRate}%`;
                document.getElementById('currentPrice').textContent = `€${currentPrice}`;
                document.getElementById('accountBalance').textContent = `€${balance}`;
                document.getElementById('openPositions').textContent = Math.floor(Math.random() * 5);
            }

            updateBotStatus(status) {
                const statusItems = document.querySelectorAll('.status-item');
                const botStatus = Array.from(statusItems).find(item => item.textContent.includes('Bot:'));
                if (botStatus) {
                    const dot = botStatus.querySelector('.status-dot');
                    const text = botStatus.querySelector('span');
                    text.textContent = `Bot: ${status}`;
                    
                    dot.className = 'status-dot';
                    if (status === 'Active') {
                        dot.classList.add('connected');
                    } else if (status === 'En Pause') {
                        dot.classList.add('warning');
                    } else {
                        dot.classList.add('disconnected');
                    }
                }
            }

            logActivity(message) {
                const log = document.getElementById('activityLog');
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `
                    <span>${message}</span>
                    <span class="log-time">${time}</span>
                `;
                log.insertBefore(entry, log.firstChild);
                
                // Keep only last 10 entries
                while (log.children.length > 10) {
                    log.removeChild(log.lastChild);
                }
            }

            showNotification(message, type) {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">${this.getNotificationIcon(type)}</span>
                        <span class="notification-message">${message}</span>
                    </div>
                `;
                
                // Add notification styles
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? 'var(--gradient-success)' : 
                                type === 'error' ? 'var(--gradient-danger)' : 
                                'linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)'};
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 12px;
                    box-shadow: var(--shadow-lg);
                    z-index: 10000;
                    animation: slideInRight 0.3s ease-out forwards;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.1);
                `;

                document.body.appendChild(notification);

                // Auto remove after 3 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.3s ease-out forwards';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            getNotificationIcon(type) {
                switch(type) {
                    case 'success': return '✅';
                    case 'error': return '❌';
                    case 'warning': return '⚠️';
                    default: return 'ℹ️';
                }
            }

            updateTimestamp() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = `Dernière MAJ: ${timeString}`;
            }
        }

        // Add notification animations
        const notificationStyles = document.createElement('style');
        notificationStyles.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }

            .notification-content {
                display: flex;
                align-items: center;
                gap: 0.75rem;
            }

            .notification-icon {
                font-size: 1.2rem;
            }

            .notification-message {
                font-weight: 600;
                font-size: 0.9rem;
            }
        `;
        document.head.appendChild(notificationStyles);

        // Market Data Simulator
        class MarketSimulator {
            constructor() {
                this.currentPrice = 45000;
                this.startPriceUpdates();
            }

            startPriceUpdates() {
                setInterval(() => {
                    // Simulate price movements
                    const change = (Math.random() - 0.5) * 1000;
                    this.currentPrice += change;
                    this.currentPrice = Math.max(30000, Math.min(80000, this.currentPrice));
                    
                    document.getElementById('currentPrice').textContent = `€${this.currentPrice.toFixed(2)}`;
                    
                    // Add some visual feedback for price changes
                    const priceElement = document.getElementById('currentPrice');
                    priceElement.style.transform = 'scale(1.05)';
                    priceElement.style.transition = 'transform 0.2s ease';
                    
                    setTimeout(() => {
                        priceElement.style.transform = 'scale(1)';
                    }, 200);
                }, 5000);
            }
        }

        // Performance Monitor
        class PerformanceMonitor {
            constructor() {
                this.trades = [];
                this.startMonitoring();
            }

            startMonitoring() {
                // Simulate random trading activity
                setInterval(() => {
                    if (Math.random() > 0.7) { // 30% chance every 10 seconds
                        this.simulateTrade();
                    }
                }, 10000);
            }

            simulateTrade() {
                const trade = {
                    type: Math.random() > 0.5 ? 'BUY' : 'SELL',
                    amount: Math.random() * 200 + 50,
                    profit: (Math.random() - 0.5) * 100,
                    timestamp: new Date()
                };

                this.trades.push(trade);
                
                // Update UI
                const uiManager = window.uiManager;
                uiManager.logActivity(`Trade ${trade.type}: €${trade.profit.toFixed(2)}`);
                
                if (Math.abs(trade.profit) > 50) {
                    uiManager.showNotification(
                        `Trade ${trade.type}: ${trade.profit >= 0 ? '+' : ''}€${trade.profit.toFixed(2)}`,
                        trade.profit >= 0 ? 'success' : 'error'
                    );
                }
            }
        }

        // Advanced Chart Placeholder
        class ChartManager {
            constructor() {
                this.initializeChart();
            }

            initializeChart() {
                const chartContainer = document.getElementById('tradingChart');
                
                // Add some animated elements to make it look more dynamic
                chartContainer.innerHTML = `
                    <div class="chart-placeholder">
                        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                            <div class="loading"></div>
                            <span>📊 Graphique de Trading en Temps Réel</span>
                        </div>
                        <div style="font-size: 0.875rem; color: var(--text-muted); text-align: center;">
                            <p>• Chandelier japonais interactif</p>
                            <p>• Indicateurs techniques (RSI, MACD, Bollinger)</p>
                            <p>• Volume et profondeur de marché</p>
                            <p>• Zones de support/résistance</p>
                            <br>
                            <p><strong>Sera intégré dans le Module 3 - Graphiques</strong></p>
                        </div>
                    </div>
                `;

                // Add some visual effects
                setInterval(() => {
                    const placeholder = chartContainer.querySelector('.chart-placeholder');
                    if (placeholder) {
                        placeholder.style.background = `linear-gradient(45deg, 
                            rgba(79, 70, 229, 0.05) 0%, 
                            rgba(0, 212, 170, 0.05) 50%, 
                            rgba(255, 107, 107, 0.05) 100%)`;
                        
                        setTimeout(() => {
                            placeholder.style.background = '';
                        }, 1000);
                    }
                }, 8000);
            }
        }

        // Risk Management Display
        class RiskManager {
            constructor() {
                this.updateRiskMetrics();
                setInterval(() => this.updateRiskMetrics(), 30000);
            }

            updateRiskMetrics() {
                // Simulate risk calculations
                const drawdown = (Math.random() * 10).toFixed(1);
                const sharpeRatio = (Math.random() * 2 + 0.5).toFixed(2);
                const volatility = (Math.random() * 30 + 10).toFixed(1);

                // Add risk metrics to monitoring panel
                const monitoringPanel = document.querySelector('.monitoring-panel .card');
                let riskSection = document.getElementById('riskMetrics');
                
                if (!riskSection) {
                    riskSection = document.createElement('div');
                    riskSection.id = 'riskMetrics';
                    riskSection.innerHTML = `
                        <h3 style="font-size: 1rem; margin: 2rem 0 1rem 0; color: var(--text-secondary);">⚠️ Gestion des Risques</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="maxDrawdown">${drawdown}%</div>
                                <div class="stat-label">Drawdown Max</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="sharpeRatio">${sharpeRatio}</div>
                                <div class="stat-label">Ratio Sharpe</div>
                            </div>
                        </div>
                    `;
                    monitoringPanel.appendChild(riskSection);
                } else {
                    document.getElementById('maxDrawdown').textContent = `${drawdown}%`;
                    document.getElementById('sharpeRatio').textContent = sharpeRatio;
                }
            }
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize all managers
            window.uiManager = new UIManager();
            window.marketSimulator = new MarketSimulator();
            window.performanceMonitor = new PerformanceMonitor();
            window.chartManager = new ChartManager();
            window.riskManager = new RiskManager();

            // Initial data load
            window.uiManager.updateStats();
            window.uiManager.logActivity('Application SLM TRADE initialisée');
            window.uiManager.showNotification('SLM TRADE prêt à trader !', 'success');

            // Add some initial activity
            setTimeout(() => {
                window.uiManager.logActivity('Connexion WebSocket établie');
                window.uiManager.logActivity('Données de marché synchronisées');
            }, 2000);

            console.log('🚀 SLM TRADE Interface initialisée avec succès!');
            console.log('📊 Modules chargés: UI, Market Simulator, Performance Monitor, Chart Manager, Risk Manager');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 's':
                        event.preventDefault();
                        window.uiManager.saveConfiguration();
                        break;
                    case 'r':
                        event.preventDefault();
                        window.uiManager.refreshData();
                        break;
                    case ' ':
                        event.preventDefault();
                        const toggle = document.getElementById('botToggle');
                        toggle.checked = !toggle.checked;
                        window.uiManager.toggleBot(toggle.checked);
                        break;
                }
            }

            // Emergency stop with ESC key
            if (event.key === 'Escape') {
                window.uiManager.emergencyStop();
            }
        });
    </script>
</body>
</html>

# Module 2 

// SLM TRADE - Module 2: Connexions API Bybit Réelles
// Intégration complète avec l'API Bybit (REST + WebSocket)

class BybitAPI {
    constructor() {
        this.apiKey = '';
        this.apiSecret = '';
        this.baseURL = 'https://api.bybit.com';
        this.testnetURL = 'https://api-testnet.bybit.com';
        this.isTestnet = true; // Basculer en false pour le trading réel
        this.ws = null;
        this.isConnected = false;
        this.subscriptions = new Set();
        this.orderBook = new Map();
        this.klineData = new Map();
        this.positions = new Map();
        this.orders = new Map();
        this.callbacks = new Map();
    }

    // Configuration API
    setCredentials(apiKey, apiSecret, isTestnet = true) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.isTestnet = isTestnet;
        this.log('API credentials configured', 'info');
    }

    // Génération de signature pour l'authentification
    generateSignature(timestamp, queryString) {
        const message = timestamp + this.apiKey + queryString;
        return CryptoJS.HmacSHA256(message, this.apiSecret).toString();
    }

    // Requête REST API authentifiée
    async makeRequest(endpoint, method = 'GET', params = {}) {
        const timestamp = Date.now().toString();
        const baseUrl = this.isTestnet ? this.testnetURL : this.baseURL;
        
        let queryString = '';
        if (method === 'GET' && Object.keys(params).length > 0) {
            queryString = new URLSearchParams(params).toString();
        }

        const signature = this.generateSignature(timestamp, queryString);
        
        const headers = {
            'X-BAPI-API-KEY': this.apiKey,
            'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp,
            'Content-Type': 'application/json'
        };

        const url = `${baseUrl}${endpoint}${queryString ? '?' + queryString : ''}`;
        
        const options = {
            method,
            headers,
        };

        if (method === 'POST' && Object.keys(params).length > 0) {
            options.body = JSON.stringify(params);
        }

        try {
            const response = await fetch(url, options);
            const data = await response.json();
            
            if (data.retCode !== 0) {
                throw new Error(`API Error: ${data.retMsg}`);
            }
            
            return data.result;
        } catch (error) {
            this.log(`API Request Error: ${error.message}`, 'error');
            throw error;
        }
    }

    // Connexion WebSocket
    async connectWebSocket() {
        const wsUrl = this.isTestnet 
            ? 'wss://stream-testnet.bybit.com/v5/public/linear'
            : 'wss://stream.bybit.com/v5/public/linear';

        try {
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                this.isConnected = true;
                this.log('WebSocket connected successfully', 'success');
                this.updateConnectionStatus(true);
                
                // Authentification WebSocket si nécessaire
                if (this.apiKey && this.apiSecret) {
                    this.authenticateWebSocket();
                }
            };

            this.ws.onmessage = (event) => {
                this.handleWebSocketMessage(JSON.parse(event.data));
            };

            this.ws.onclose = () => {
                this.isConnected = false;
                this.log('WebSocket connection closed', 'warning');
                this.updateConnectionStatus(false);
                this.reconnectWebSocket();
            };

            this.ws.onerror = (error) => {
                this.log(`WebSocket error: ${error.message}`, 'error');
            };

        } catch (error) {
            this.log(`WebSocket connection failed: ${error.message}`, 'error');
        }
    }

    // Authentification WebSocket
    authenticateWebSocket() {
        const timestamp = Date.now();
        const signature = CryptoJS.HmacSHA256(`GET/realtime${timestamp}`, this.apiSecret).toString();
        
        const authMessage = {
            op: 'auth',
            args: [this.apiKey, timestamp, signature]
        };
        
        this.ws.send(JSON.stringify(authMessage));
    }

    // Gestion des messages WebSocket
    handleWebSocketMessage(data) {
        if (data.topic) {
            const topic = data.topic;
            
            if (topic.includes('orderbook')) {
                this.updateOrderBook(data);
            } else if (topic.includes('kline')) {
                this.updateKlineData(data);
            } else if (topic.includes('position')) {
                this.updatePositions(data);
            } else if (topic.includes('order')) {
                this.updateOrders(data);
            }
            
            // Notifier les callbacks
            if (this.callbacks.has(topic)) {
                this.callbacks.get(topic)(data);
            }
        }
    }

    // Souscription à un topic WebSocket
    subscribe(topic, callback = null) {
        if (!this.isConnected) {
            this.log('WebSocket not connected', 'error');
            return;
        }

        const subscribeMessage = {
            op: 'subscribe',
            args: [topic]
        };

        this.ws.send(JSON.stringify(subscribeMessage));
        this.subscriptions.add(topic);
        
        if (callback) {
            this.callbacks.set(topic, callback);
        }
        
        this.log(`Subscribed to ${topic}`, 'info');
    }

    // Désabonnement d'un topic
    unsubscribe(topic) {
        if (!this.isConnected) return;

        const unsubscribeMessage = {
            op: 'unsubscribe',
            args: [topic]
        };

        this.ws.send(JSON.stringify(unsubscribeMessage));
        this.subscriptions.delete(topic);
        this.callbacks.delete(topic);
        
        this.log(`Unsubscribed from ${topic}`, 'info');
    }

    // Reconnexion automatique WebSocket
    reconnectWebSocket() {
        setTimeout(() => {
            if (!this.isConnected) {
                this.log('Attempting to reconnect WebSocket...', 'info');
                this.connectWebSocket();
            }
        }, 5000);
    }

    // === FONCTIONS DE TRADING ===

    // Récupérer les informations du compte
    async getAccountBalance() {
        try {
            const result = await this.makeRequest('/v5/account/wallet-balance', 'GET', {
                accountType: 'UNIFIED'
            });
            this.log('Account balance retrieved', 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get account balance: ${error.message}`, 'error');
            throw error;
        }
    }

    // Récupérer les positions
    async getPositions(symbol = '') {
        try {
            const params = {
                category: 'linear',
                settleCoin: 'USDT'
            };
            
            if (symbol) {
                params.symbol = symbol;
            }

            const result = await this.makeRequest('/v5/position/list', 'GET', params);
            this.log(`Positions retrieved${symbol ? ' for ' + symbol : ''}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get positions: ${error.message}`, 'error');
            throw error;
        }
    }

    // Passer un ordre
    async placeOrder(symbol, side, orderType, qty, price = null, timeInForce = 'GTC', options = {}) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                side: side, // 'Buy' ou 'Sell'
                orderType: orderType, // 'Market' ou 'Limit'
                qty: qty.toString(),
                timeInForce: timeInForce,
                ...options
            };

            if (orderType === 'Limit' && price) {
                params.price = price.toString();
            }

            const result = await this.makeRequest('/v5/order/create', 'POST', params);
            this.log(`Order placed: ${side} ${qty} ${symbol} at ${price || 'market'}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to place order: ${error.message}`, 'error');
            throw error;
        }
    }

    // Annuler un ordre
    async cancelOrder(symbol, orderId) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                orderId: orderId
            };

            const result = await this.makeRequest('/v5/order/cancel', 'POST', params);
            this.log(`Order cancelled: ${orderId}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to cancel order: ${error.message}`, 'error');
            throw error;
        }
    }

    // Fermer une position
    async closePosition(symbol, side) {
        try {
            const positions = await this.getPositions(symbol);
            const position = positions.list.find(p => p.symbol === symbol && p.side === side);
            
            if (!position || parseFloat(position.size) === 0) {
                throw new Error('No position to close');
            }

            const closeSide = side === 'Buy' ? 'Sell' : 'Buy';
            const result = await this.placeOrder(symbol, closeSide, 'Market', Math.abs(parseFloat(position.size)));
            
            this.log(`Position closed: ${side} ${symbol}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to close position: ${error.message}`, 'error');
            throw error;
        }
    }

    // Récupérer l'historique des ordres
    async getOrderHistory(symbol = '', limit = 50) {
        try {
            const params = {
                category: 'linear',
                limit: limit
            };
            
            if (symbol) {
                params.symbol = symbol;
            }

            const result = await this.makeRequest('/v5/order/history', 'GET', params);
            this.log('Order history retrieved', 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get order history: ${error.message}`, 'error');
            throw error;
        }
    }

    // Récupérer les données de prix
    async getTicker(symbol) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol
            };

            const result = await this.makeRequest('/v5/market/tickers', 'GET', params);
            return result.list[0];
        } catch (error) {
            this.log(`Failed to get ticker for ${symbol}: ${error.message}`, 'error');
            throw error;
        }
    }

    // Récupérer les données kline/chandelier
    async getKlineData(symbol, interval = '1', limit = 200) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                interval: interval,
                limit: limit
            };

            const result = await this.makeRequest('/v5/market/kline', 'GET', params);
            this.log(`Kline data retrieved for ${symbol}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get kline data: ${error.message}`, 'error');
            throw error;
        }
    }

    // === FONCTIONS DE MISE À JOUR DES DONNÉES ===

    updateOrderBook(data) {
        const symbol = data.data.s;
        this.orderBook.set(symbol, data.data);
        
        // Mettre à jour l'interface si elle existe
        if (typeof updateOrderBookUI === 'function') {
            updateOrderBookUI(symbol, data.data);
        }
    }

    updateKlineData(data) {
        const symbol = data.data.symbol;
        if (!this.klineData.has(symbol)) {
            this.klineData.set(symbol, []);
        }
        
        const klines = this.klineData.get(symbol);
        klines.push(data.data);
        
        // Garder seulement les 1000 dernières bougies
        if (klines.length > 1000) {
            klines.shift();
        }
        
        // Mettre à jour l'interface si elle existe
        if (typeof updateChartUI === 'function') {
            updateChartUI(symbol, data.data);
        }
    }

    updatePositions(data) {
        data.data.forEach(position => {
            this.positions.set(position.symbol, position);
        });
        
        // Mettre à jour l'interface si elle existe
        if (typeof updatePositionsUI === 'function') {
            updatePositionsUI(data.data);
        }
    }

    updateOrders(data) {
        data.data.forEach(order => {
            this.orders.set(order.orderId, order);
        });
        
        // Mettre à jour l'interface si elle existe
        if (typeof updateOrdersUI === 'function') {
            updateOrdersUI(data.data);
        }
    }

    // === FONCTIONS UTILITAIRES ===

    // Test de connexion API
    async testConnection() {
        try {
            await this.makeRequest('/v5/market/time', 'GET');
            this.log('API connection test successful', 'success');
            return true;
        } catch (error) {
            this.log(`API connection test failed: ${error.message}`, 'error');
            return false;
        }
    }

    // Mise à jour du statut de connexion dans l'UI
    updateConnectionStatus(connected) {
        const statusElement = document.getElementById('api-status');
        if (statusElement) {
            statusElement.textContent = connected ? 'Connecté' : 'Déconnecté';
            statusElement.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }

        const wsStatusElement = document.getElementById('ws-status');
        if (wsStatusElement) {
            wsStatusElement.textContent = connected ? 'Connecté' : 'Déconnecté';
            wsStatusElement.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    // Logger avec gestion UI
    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logMessage = `[${timestamp}] ${message}`;
        
        console.log(logMessage);
        
        // Ajouter au log UI si disponible
        if (typeof addToActivityLog === 'function') {
            addToActivityLog(message, type);
        }
    }

    // Déconnexion propre
    disconnect() {
        if (this.ws) {
            this.ws.close();
        }
        this.isConnected = false;
        this.subscriptions.clear();
        this.callbacks.clear();
        this.log('API disconnected', 'info');
    }
}

// === GESTIONNAIRE PRINCIPAL DE L'API ===

class APIManager {
    constructor() {
        this.bybitAPI = new BybitAPI();
        this.isInitialized = false;
        this.activeSymbol = 'BTCUSDT';
        this.monitoringInterval = null;
    }

    // Initialisation de l'API
    async initialize(apiKey, apiSecret, isTestnet = true) {
        try {
            this.bybitAPI.setCredentials(apiKey, apiSecret, isTestnet);
            
            // Test de connexion
            const connected = await this.bybitAPI.testConnection();
            if (!connected) {
                throw new Error('Failed to connect to Bybit API');
            }

            // Connexion WebSocket
            await this.bybitAPI.connectWebSocket();
            
            // Souscriptions de base
            this.setupSubscriptions();
            
            // Démarrage du monitoring
            this.startMonitoring();
            
            this.isInitialized = true;
            this.bybitAPI.log('API Manager initialized successfully', 'success');
            
            return true;
        } catch (error) {
            this.bybitAPI.log(`API initialization failed: ${error.message}`, 'error');
            return false;
        }
    }

    // Configuration des souscriptions WebSocket
    setupSubscriptions() {
        // Souscription aux données de prix
        this.bybitAPI.subscribe(`tickers.${this.activeSymbol}`, (data) => {
            this.handleTickerUpdate(data);
        });

        // Souscription aux positions (si authentifié)
        if (this.bybitAPI.apiKey) {
            this.bybitAPI.subscribe('position', (data) => {
                this.handlePositionUpdate(data);
            });
        }
    }

    // Gestion des mises à jour de prix
    handleTickerUpdate(data) {
        const ticker = data.data;
        
        // Mettre à jour l'interface de prix
        if (typeof updatePriceDisplay === 'function') {
            updatePriceDisplay(ticker);
        }
    }

    // Gestion des mises à jour de positions
    handlePositionUpdate(data) {
        // Mettre à jour l'interface des positions
        if (typeof updatePositionDisplay === 'function') {
            updatePositionDisplay(data.data);
        }
    }

    // Démarrage du monitoring périodique
    startMonitoring() {
        this.monitoringInterval = setInterval(async () => {
            try {
                // Récupération périodique des données de compte
                if (this.bybitAPI.apiKey) {
                    const balance = await this.bybitAPI.getAccountBalance();
                    if (typeof updateAccountBalance === 'function') {
                        updateAccountBalance(balance);
                    }
                }
            } catch (error) {
                this.bybitAPI.log(`Monitoring error: ${error.message}`, 'error');
            }
        }, 10000); // Toutes les 10 secondes
    }

    // Arrêt du monitoring
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
    }

    // Changement de symbole de trading
    changeSymbol(symbol) {
        // Désabonnement de l'ancien symbole
        this.bybitAPI.unsubscribe(`tickers.${this.activeSymbol}`);
        
        // Changement de symbole actif
        this.activeSymbol = symbol;
        
        // Souscription au nouveau symbole
        this.bybitAPI.subscribe(`tickers.${symbol}`, (data) => {
            this.handleTickerUpdate(data);
        });
        
        this.bybitAPI.log(`Active symbol changed to ${symbol}`, 'info');
    }

    // Exécution d'un trade
    async executeTrade(side, quantity, orderType = 'Market', price = null) {
        try {
            const result = await this.bybitAPI.placeOrder(
                this.activeSymbol,
                side,
                orderType,
                quantity,
                price
            );
            
            // Notification de succès
            if (typeof showNotification === 'function') {
                showNotification(`Ordre ${side} exécuté avec succès`, 'success');
            }
            
            return result;
        } catch (error) {
            // Notification d'erreur
            if (typeof showNotification === 'function') {
                showNotification(`Erreur lors de l'exécution: ${error.message}`, 'error');
            }
            throw error;
        }
    }

    // Fermeture de toutes les positions
    async closeAllPositions() {
        try {
            const positions = await this.bybitAPI.getPositions();
            const openPositions = positions.list.filter(p => parseFloat(p.size) !== 0);
            
            for (const position of openPositions) {
                await this.bybitAPI.closePosition(position.symbol, position.side);
            }
            
            if (typeof showNotification === 'function') {
                showNotification('Toutes les positions fermées', 'success');
            }
        } catch (error) {
            if (typeof showNotification === 'function') {
                showNotification(`Erreur fermeture positions: ${error.message}`, 'error');
            }
            throw error;
        }
    }

    // Arrêt propre
    shutdown() {
        this.stopMonitoring();
        this.bybitAPI.disconnect();
        this.isInitialized = false;
        this.bybitAPI.log('API Manager shut down', 'info');
    }
}

// Instance globale de l'API Manager
const apiManager = new APIManager();

// === FONCTIONS D'INTÉGRATION AVEC L'INTERFACE ===

// Fonction d'initialisation à appeler depuis l'interface
async function initializeAPI(apiKey, apiSecret, isTestnet = true) {
    return await apiManager.initialize(apiKey, apiSecret, isTestnet);
}

// Fonctions de trading à appeler depuis l'interface
async function buyMarket(quantity) {
    return await apiManager.executeTrade('Buy', quantity, 'Market');
}

async function sellMarket(quantity) {
    return await apiManager.executeTrade('Sell', quantity, 'Market');
}

async function buyLimit(quantity, price) {
    return await apiManager.executeTrade('Buy', quantity, 'Limit', price);
}

async function sellLimit(quantity, price) {
    return await apiManager.executeTrade('Sell', quantity, 'Limit', price);
}

// Export des classes pour utilisation modulaire
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { BybitAPI, APIManager, apiManager };
}

# Module 3 

// SLM TRADE - Module 3: Intégration TradingView Complète
// Graphiques professionnels avec indicateurs techniques avancés

class TradingViewManager {
    constructor() {
        this.widget = null;
        this.activeSymbol = 'BYBIT:BTCUSDT';
        this.indicators = new Map();
        this.patterns = [];
        this.alerts = [];
        this.chartData = [];
        this.timeframe = '15';
        
        this.init();
    }

    async init() {
        await this.loadTradingViewLibrary();
        this.createChart();
        this.setupIndicators();
        this.initializePatternDetection();
        console.log('📊 TradingView Module initialisé');
    }

    async loadTradingViewLibrary() {
        return new Promise((resolve) => {
            if (window.TradingView) {
                resolve();
                return;
            }

            const script = document.createElement('script');
            script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
            script.async = true;
            script.onload = resolve;
            document.head.appendChild(script);
        });
    }

    createChart() {
        const chartContainer = document.getElementById('tradingview-chart') || this.createChartContainer();
        
        // Configuration avancée du widget TradingView
        this.widget = new TradingView.widget({
            "autosize": true,
            "symbol": this.activeSymbol,
            "interval": this.timeframe,
            "timezone": "Europe/Paris",
            "theme": "dark",
            "style": "1",
            "locale": "fr",
            "toolbar_bg": "#1a1a1a",
            "enable_publishing": false,
            "hide_top_toolbar": false,
            "hide_legend": false,
            "save_image": false,
            "container_id": "tradingview-chart",
            "studies": [
                "RSI@tv-basicstudies",
                "MACD@tv-basicstudies",
                "BB@tv-basicstudies",
                "Volume@tv-basicstudies"
            ],
            "overrides": {
                "paneProperties.background": "#0d1421",
                "paneProperties.vertGridProperties.color": "#1e293b",
                "paneProperties.horzGridProperties.color": "#1e293b",
                "symbolWatermarkProperties.transparency": 90,
                "scalesProperties.textColor": "#64748b",
                "mainSeriesProperties.candleStyle.upColor": "#22c55e",
                "mainSeriesProperties.candleStyle.downColor": "#ef4444",
                "mainSeriesProperties.candleStyle.borderUpColor": "#22c55e",
                "mainSeriesProperties.candleStyle.borderDownColor": "#ef4444",
            },
            "studies_overrides": {
                "volume.volume.color.0": "#ef444480",
                "volume.volume.color.1": "#22c55e80",
                "RSI.RSI.color": "#3b82f6",
                "MACD.MACD.color": "#8b5cf6",
                "MACD.signal.color": "#f59e0b",
                "Bollinger Bands.median.color": "#64748b",
                "Bollinger Bands.upper.color": "#f59e0b",
                "Bollinger Bands.lower.color": "#f59e0b"
            }
        });

        this.widget.onChartReady(() => {
            console.log('📈 Graphique TradingView chargé');
            this.setupRealtimeData();
            this.addCustomIndicators();
        });
    }

    createChartContainer() {
        const container = document.createElement('div');
        container.id = 'tradingview-chart';
        container.style.cssText = `
            height: 600px;
            width: 100%;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            border-radius: 12px;
            border: 1px solid #334155;
            margin: 10px 0;
        `;
        
        // Insérer dans l'interface principale
        const dashboardContent = document.querySelector('.dashboard-content') || document.body;
        dashboardContent.appendChild(container);
        return container;
    }

    setupRealtimeData() {
        // Connexion aux données temps réel via WebSocket Bybit
        if (window.bybitAPI) {
            // Abonnement aux données de prix
            window.bybitAPI.subscribeToTicker(this.activeSymbol.split(':')[1], (data) => {
                this.updateChartData(data);
            });

            // Abonnement aux données de profondeur
            window.bybitAPI.subscribeToOrderbook(this.activeSymbol.split(':')[1], (data) => {
                this.updateOrderbookAnalysis(data);
            });
        }
    }

    addCustomIndicators() {
        // Indicateur SLM personnalisé
        this.addSLMIndicator();
        
        // Indicateur de Force du Trend
        this.addTrendStrengthIndicator();
        
        // Indicateur de Support/Résistance automatique
        this.addSupportResistanceIndicator();
        
        // Volume Profile
        this.addVolumeProfileIndicator();
    }

    addSLMIndicator() {
        const slmStudy = {
            name: "SLM Signal",
            metainfo: {
                _metainfoVersion: 51,
                id: "SLM_Signal@tv-basicstudies",
                description: "SLM Trading Signal",
                shortDescription: "SLM",
                format: {
                    type: "price",
                    precision: 4
                },
                plots: [{
                    id: "signal",
                    type: "line"
                }],
                defaults: {
                    styles: {
                        signal: {
                            linestyle: 0,
                            linewidth: 2,
                            plottype: 1,
                            trackPrice: false,
                            transparency: 0,
                            color: "#00d4ff"
                        }
                    }
                },
                styles: {
                    signal: {
                        title: "SLM Signal",
                        histogramBase: 0
                    }
                },
                inputs: []
            },
            constructor: function() {
                this.main = function(context, inputCallback) {
                    this._context = context;
                    this._input = inputCallback;
                    
                    const close = this._input(0);
                    const high = this._input(1);
                    const low = this._input(2);
                    const volume = this._input(3);
                    
                    // Calcul SLM personnalisé
                    const slmValue = this.calculateSLM(close, high, low, volume);
                    return [slmValue];
                };
                
                this.calculateSLM = function(close, high, low, volume) {
                    // Algorithme SLM propriétaire
                    const hl2 = (high + low) / 2;
                    const hlc3 = (high + low + close) / 3;
                    const volumeWeight = Math.log(volume) / 10;
                    
                    return hlc3 * (1 + volumeWeight * 0.1);
                };
            }
        };

        this.indicators.set('SLM', slmStudy);
    }

    addTrendStrengthIndicator() {
        // Force du trend basé sur ADX amélioré
        const trendStrength = {
            calculate: (highs, lows, closes, period = 14) => {
                const tr = [];
                const plusDM = [];
                const minusDM = [];
                
                for (let i = 1; i < closes.length; i++) {
                    const high = highs[i];
                    const low = lows[i];
                    const close = closes[i];
                    const prevHigh = highs[i-1];
                    const prevLow = lows[i-1];
                    const prevClose = closes[i-1];
                    
                    // True Range
                    tr.push(Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    ));
                    
                    // Directional Movement
                    const highDiff = high - prevHigh;
                    const lowDiff = prevLow - low;
                    
                    plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
                    minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
                }
                
                // Calcul ADX amélioré
                return this.calculateEnhancedADX(tr, plusDM, minusDM, period);
            }
        };
        
        this.indicators.set('TrendStrength', trendStrength);
    }

    addSupportResistanceIndicator() {
        const srLevels = {
            calculate: (highs, lows, closes, lookback = 20, minTouches = 3) => {
                const levels = [];
                
                for (let i = lookback; i < closes.length - lookback; i++) {
                    // Recherche des pivots
                    const isHighPivot = this.isPivotHigh(highs, i, lookback);
                    const isLowPivot = this.isPivotLow(lows, i, lookback);
                    
                    if (isHighPivot) {
                        const level = {
                            price: highs[i],
                            type: 'resistance',
                            strength: this.calculateLevelStrength(highs, lows, closes, highs[i], minTouches),
                            index: i
                        };
                        if (level.strength >= minTouches) levels.push(level);
                    }
                    
                    if (isLowPivot) {
                        const level = {
                            price: lows[i],
                            type: 'support',
                            strength: this.calculateLevelStrength(highs, lows, closes, lows[i], minTouches),
                            index: i
                        };
                        if (level.strength >= minTouches) levels.push(level);
                    }
                }
                
                return levels.sort((a, b) => b.strength - a.strength);
            }
        };
        
        this.indicators.set('SupportResistance', srLevels);
    }

    addVolumeProfileIndicator() {
        const volumeProfile = {
            calculate: (highs, lows, volumes, bins = 50) => {
                const profile = [];
                const priceRange = Math.max(...highs) - Math.min(...lows);
                const binSize = priceRange / bins;
                const minPrice = Math.min(...lows);
                
                // Initialiser les bins
                for (let i = 0; i < bins; i++) {
                    profile.push({
                        price: minPrice + (i * binSize),
                        volume: 0,
                        buyVolume: 0,
                        sellVolume: 0
                    });
                }
                
                // Distribuer les volumes
                for (let i = 0; i < highs.length; i++) {
                    const high = highs[i];
                    const low = lows[i];
                    const volume = volumes[i];
                    const avgPrice = (high + low) / 2;
                    
                    const binIndex = Math.floor((avgPrice - minPrice) / binSize);
                    if (binIndex >= 0 && binIndex < bins) {
                        profile[binIndex].volume += volume;
                        // Estimation buy/sell basée sur la position dans la bougie
                        const closePercent = (closes[i] - low) / (high - low);
                        profile[binIndex].buyVolume += volume * closePercent;
                        profile[binIndex].sellVolume += volume * (1 - closePercent);
                    }
                }
                
                return profile;
            }
        };
        
        this.indicators.set('VolumeProfile', volumeProfile);
    }

    detectPatterns(ohlcData) {
        const patterns = [];
        
        // Détection de patterns de chandeliers
        patterns.push(...this.detectCandlestickPatterns(ohlcData));
        
        // Détection de patterns techniques
        patterns.push(...this.detectTechnicalPatterns(ohlcData));
        
        // Détection de patterns harmoniques
        patterns.push(...this.detectHarmonicPatterns(ohlcData));
        
        return patterns;
    }

    detectCandlestickPatterns(data) {
        const patterns = [];
        
        for (let i = 2; i < data.length; i++) {
            const current = data[i];
            const prev = data[i-1];
            const prev2 = data[i-2];
            
            // Doji
            if (this.isDoji(current)) {
                patterns.push({
                    name: 'Doji',
                    type: 'reversal',
                    reliability: 0.6,
                    index: i,
                    signal: 'indecision'
                });
            }
            
            // Hammer / Hanging Man
            const hammerResult = this.isHammer(current, prev);
            if (hammerResult) {
                patterns.push({
                    name: hammerResult.name,
                    type: 'reversal',
                    reliability: 0.7,
                    index: i,
                    signal: hammerResult.signal
                });
            }
            
            // Engulfing Pattern
            const engulfing = this.isEngulfing(current, prev);
            if (engulfing) {
                patterns.push({
                    name: engulfing.name,
                    type: 'reversal',
                    reliability: 0.8,
                    index: i,
                    signal: engulfing.signal
                });
            }
            
            // Three White Soldiers / Three Black Crows
            const threePattern = this.isThreePattern(current, prev, prev2);
            if (threePattern) {
                patterns.push({
                    name: threePattern.name,
                    type: 'continuation',
                    reliability: 0.85,
                    index: i,
                    signal: threePattern.signal
                });
            }
        }
        
        return patterns;
    }

    detectTechnicalPatterns(data) {
        const patterns = [];
        
        // Head and Shoulders
        const headShoulders = this.detectHeadAndShoulders(data);
        patterns.push(...headShoulders);
        
        // Double Top/Bottom
        const doubles = this.detectDoubleTopBottom(data);
        patterns.push(...doubles);
        
        // Triangle Patterns
        const triangles = this.detectTriangles(data);
        patterns.push(...triangles);
        
        // Flag and Pennant
        const flags = this.detectFlagsAndPennants(data);
        patterns.push(...flags);
        
        return patterns;
    }

    detectHarmonicPatterns(data) {
        const patterns = [];
        
        // Gartley Pattern
        const gartley = this.detectGartley(data);
        patterns.push(...gartley);
        
        // Butterfly Pattern
        const butterfly = this.detectButterfly(data);
        patterns.push(...butterfly);
        
        // Bat Pattern
        const bat = this.detectBat(data);
        patterns.push(...bat);
        
        // Crab Pattern
        const crab = this.detectCrab(data);
        patterns.push(...crab);
        
        return patterns;
    }

    // Méthodes utilitaires pour la détection de patterns
    isDoji(candle) {
        const bodySize = Math.abs(candle.close - candle.open);
        const totalRange = candle.high - candle.low;
        return bodySize / totalRange < 0.1;
    }

    isHammer(candle, prevCandle) {
        const bodySize = Math.abs(candle.close - candle.open);
        const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
        const upperShadow = candle.high - Math.max(candle.open, candle.close);
        const totalRange = candle.high - candle.low;
        
        if (lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5) {
            const trend = this.getTrend(prevCandle);
            if (trend === 'down') {
                return { name: 'Hammer', signal: 'bullish' };
            } else if (trend === 'up') {
                return { name: 'Hanging Man', signal: 'bearish' };
            }
        }
        return null;
    }

    isEngulfing(current, prev) {
        const currentBull = current.close > current.open;
        const prevBull = prev.close > prev.open;
        
        if (currentBull && !prevBull) {
            // Bullish Engulfing
            if (current.open < prev.close && current.close > prev.open) {
                return { name: 'Bullish Engulfing', signal: 'bullish' };
            }
        } else if (!currentBull && prevBull) {
            // Bearish Engulfing
            if (current.open > prev.close && current.close < prev.open) {
                return { name: 'Bearish Engulfing', signal: 'bearish' };
            }
        }
        return null;
    }

    createPatternAlert(pattern) {
        const alert = {
            id: Date.now(),
            timestamp: new Date(),
            pattern: pattern.name,
            signal: pattern.signal,
            reliability: pattern.reliability,
            price: this.getCurrentPrice(),
            message: `Pattern ${pattern.name} détecté - Signal ${pattern.signal}`,
            type: pattern.reliability > 0.7 ? 'high' : 'medium'
        };
        
        this.alerts.push(alert);
        this.showPatternNotification(alert);
        
        // Callback vers l'interface principale
        if (window.updatePatternDetection) {
            window.updatePatternDetection(pattern, alert);
        }
        
        return alert;
    }

    showPatternNotification(alert) {
        // Créer une notification toast
        const notification = document.createElement('div');
        notification.className = `pattern-notification ${alert.type}`;
        notification.innerHTML = `
            <div class="notification-icon">📊</div>
            <div class="notification-content">
                <div class="notification-title">Pattern Détecté</div>
                <div class="notification-message">${alert.message}</div>
                <div class="notification-time">${alert.timestamp.toLocaleTimeString()}</div>
            </div>
        `;
        
        // Styles
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease-out;
            max-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        // Suppression automatique après 5 secondes
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    }

    // Méthodes d'analyse technique avancée
    calculateRSI(closes, period = 14) {
        const gains = [];
        const losses = [];
        
        for (let i = 1; i < closes.length; i++) {
            const change = closes[i] - closes[i-1];
            gains.push(change > 0 ? change : 0);
            losses.push(change < 0 ? Math.abs(change) : 0);
        }
        
        const avgGain = gains.slice(-period).reduce((a, b) => a + b) / period;
        const avgLoss = losses.slice(-period).reduce((a, b) => a + b) / period;
        
        if (avgLoss === 0) return 100;
        
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }

    calculateMACD(closes, fast = 12, slow = 26, signal = 9) {
        const emaFast = this.calculateEMA(closes, fast);
        const emaSlow = this.calculateEMA(closes, slow);
        
        const macdLine = emaFast.map((fast, i) => fast - emaSlow[i]);
        const signalLine = this.calculateEMA(macdLine, signal);
        const histogram = macdLine.map((macd, i) => macd - signalLine[i]);
        
        return {
            macd: macdLine,
            signal: signalLine,
            histogram: histogram
        };
    }

    calculateEMA(data, period) {
        const ema = [];
        const multiplier = 2 / (period + 1);
        
        ema[0] = data[0];
        
        for (let i = 1; i < data.length; i++) {
            ema[i] = (data[i] * multiplier) + (ema[i-1] * (1 - multiplier));
        }
        
        return ema;
    }

    calculateBollingerBands(closes, period = 20, stdDev = 2) {
        const sma = this.calculateSMA(closes, period);
        const bands = {
            upper: [],
            middle: sma,
            lower: []
        };
        
        for (let i = period - 1; i < closes.length; i++) {
            const slice = closes.slice(i - period + 1, i + 1);
            const mean = sma[i];
            const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
            const standardDeviation = Math.sqrt(variance);
            
            bands.upper[i] = mean + (standardDeviation * stdDev);
            bands.lower[i] = mean - (standardDeviation * stdDev);
        }
        
        return bands;
    }

    calculateSMA(data, period) {
        const sma = [];
        
        for (let i = period - 1; i < data.length; i++) {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b);
            sma[i] = sum / period;
        }
        
        return sma;
    }

    // Interface de contrôle
    changeSymbol(symbol) {
        this.activeSymbol = symbol;
        if (this.widget) {
            this.widget.setSymbol(symbol, () => {
                console.log(`📊 Symbole changé vers: ${symbol}`);
                this.setupRealtimeData();
            });
        }
    }

    changeTimeframe(timeframe) {
        this.timeframe = timeframe;
        if (this.widget) {
            this.widget.chart().setResolution(timeframe, () => {
                console.log(`⏱️ Timeframe changé vers: ${timeframe}`);
            });
        }
    }

    addIndicator(indicatorName, params = {}) {
        if (this.widget && this.widget.chart) {
            this.widget.chart().createStudy(indicatorName, false, false, params);
            console.log(`📈 Indicateur ajouté: ${indicatorName}`);
        }
    }

    removeIndicator(indicatorId) {
        if (this.widget && this.widget.chart) {
            this.widget.chart().removeEntity(indicatorId);
            console.log(`❌ Indicateur supprimé: ${indicatorId}`);
        }
    }

    takeScreenshot() {
        if (this.widget && this.widget.chart) {
            this.widget.chart().takeScreenshot();
            console.log('📸 Capture d\'écran du graphique prise');
        }
    }

    exportData() {
        const exportData = {
            symbol: this.activeSymbol,
            timeframe: this.timeframe,
            indicators: Array.from(this.indicators.keys()),
            patterns: this.patterns,
            alerts: this.alerts,
            timestamp: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `slm-trade-analysis-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        console.log('💾 Données d\'analyse exportées');
    }

    // Méthodes utilitaires
    getCurrentPrice() {
        return this.chartData.length > 0 ? this.chartData[this.chartData.length - 1].close : 0;
    }

    getTrend(candle, period = 10) {
        // Logique simplifiée pour détecter la tendance
        if (candle.close > candle.open) return 'up';
        if (candle.close < candle.open) return 'down';
        return 'neutral';
    }

    isPivotHigh(highs, index, lookback) {
        const currentHigh = highs[index];
        for (let i = index - lookback; i <= index + lookback; i++) {
            if (i !== index && i >= 0 && i < highs.length) {
                if (highs[i] >= currentHigh) return false;
            }
        }
        return true;
    }

    isPivotLow(lows, index, lookback) {
        const currentLow = lows[index];
        for (let i = index - lookback; i <= index + lookback; i++) {
            if (i !== index && i >= 0 && i < lows.length) {
                if (lows[i] <= currentLow) return false;
            }
        }
        return true;
    }

    calculateLevelStrength(highs, lows, closes, level, tolerance = 0.001) {
        let touches = 0;
        const toleranceAmount = level * tolerance;
        
        for (let i = 0; i < closes.length; i++) {
            if (Math.abs(highs[i] - level) <= toleranceAmount ||
                Math.abs(lows[i] - level) <= toleranceAmount ||
                Math.abs(closes[i] - level) <= toleranceAmount) {
                touches++;
            }
        }
        
        return touches;
    }

    // Interface de gestion des alertes
    createAlert(condition, message, type = 'info') {
        const alert = {
            id: Date.now(),
            condition: condition,
            message: message,
            type: type,
            active: true,
            triggered: false,
            createdAt: new Date()
        };
        
        this.alerts.push(alert);
        return alert;
    }

    checkAlerts() {
        const currentPrice = this.getCurrentPrice();
        
        this.alerts.filter(alert => alert.active && !alert.triggered).forEach(alert => {
            if (this.evaluateAlertCondition(alert.condition, currentPrice)) {
                alert.triggered = true;
                this.triggerAlert(alert);
            }
        });
    }

    evaluateAlertCondition(condition, currentPrice) {
        // Évaluation simple des conditions d'alerte
        try {
            return eval(condition.replace('PRICE', currentPrice));
        } catch (error) {
            console.error('Erreur dans la condition d\'alerte:', error);
            return false;
        }
    }

    triggerAlert(alert) {
        console.log(`🚨 Alerte déclenchée: ${alert.message}`);
        this.showPatternNotification({
            type: alert.type,
            message: alert.message,
            timestamp: new Date()
        });
        
        // Callback vers l'interface principale
        if (window.onAlertTriggered) {
            window.onAlertTriggered(alert);
        }
    }
}

// Initialisation automatique
let tradingViewManager;

document.addEventListener('DOMContentLoaded', () => {
    tradingViewManager = new TradingViewManager();
});

// Fonctions d'interface globales
window.changeTradingSymbol = (symbol) => {
    if (tradingViewManager) {
        tradingViewManager.changeSymbol(symbol);
    }
};

window.changeTradingTimeframe = (timeframe) => {
    if (tradingViewManager) {
        tradingViewManager.changeTimeframe(timeframe);
    }
};

window.addTradingIndicator = (indicator, params) => {
    if (tradingViewManager) {
        tradingViewManager.addIndicator(indicator, params);
    }
};

window.exportTradingData = () => {
    if (tradingViewManager) {
        tradingViewManager.exportData();
    }
};

window.createTradingAlert = (condition, message, type) => {
    if (tradingViewManager) {
        return tradingViewManager.createAlert(condition, message, type);
    }
};

// Styles CSS pour les notifications
const notificationStyles = document.createElement('style');
notificationStyles.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
    
    .pattern-notification {
        font-family: 'Inter', sans-serif;
    }
    
    .pattern-notification.high {
        border-color: #22c55e;
        box-shadow: 0 10px 30px rgba(34, 197, 94, 0.3);
    }
    
    .pattern-notification.medium {
        border-color: #f59e0b;
        box-shadow: 0 10px 30px rgba(245, 158, 11, 0.3);
    }
    
    .notification-icon {
        font-size: 24px;
        flex-shrink: 0;
    }
    
    .notification-content {
        flex-grow: 1;
    }
    
    .notification-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 4px;
    }
    
    .notification-message {
        font-size: 12px;
        opacity: 0.8;
        margin-bottom: 2px;
    }
    
    .notification-time {
        font-size: 10px;
        opacity: 0.6;
    }
`;

document.head.appendChild(notificationStyles);

// Extension pour l'analyse de sentiment et flux d'ordres
class MarketSentimentAnalyzer {
    constructor() {
        this.orderFlow = [];
        this.sentimentScore = 0;
        this.volumeAnalysis = {
            buyPressure: 0,
            sellPressure: 0,
            netFlow: 0
        };
        this.init();
    }

    init() {
        this.startOrderFlowAnalysis();
        this.initializeSentimentTracking();
        console.log('📊 Analyseur de sentiment de marché initialisé');
    }

    startOrderFlowAnalysis() {
        // Analyse du flux d'ordres en temps réel
        if (window.bybitAPI) {
            window.bybitAPI.subscribeToTrades('BTCUSDT', (trade) => {
                this.analyzeOrderFlow(trade);
            });
        }
    }

    analyzeOrderFlow(trade) {
        const orderFlowData = {
            timestamp: trade.timestamp,
            price: parseFloat(trade.price),
            size: parseFloat(trade.size),
            side: trade.side, // 'Buy' or 'Sell'
            isBlockTrade: parseFloat(trade.size) > this.getAverageTradeSize() * 5
        };

        this.orderFlow.unshift(orderFlowData);
        
        // Garder seulement les 1000 derniers trades
        if (this.orderFlow.length > 1000) {
            this.orderFlow = this.orderFlow.slice(0, 1000);
        }

        this.updateVolumeAnalysis();
        this.calculateSentimentScore();
        this.detectLargeOrders(orderFlowData);
    }

    updateVolumeAnalysis() {
        const recentTrades = this.orderFlow.slice(0, 100); // 100 derniers trades
        
        let buyVolume = 0;
        let sellVolume = 0;
        
        recentTrades.forEach(trade => {
            if (trade.side === 'Buy') {
                buyVolume += trade.size;
            } else {
                sellVolume += trade.size;
            }
        });
        
        this.volumeAnalysis = {
            buyPressure: buyVolume,
            sellPressure: sellVolume,
            netFlow: buyVolume - sellVolume,
            dominance: buyVolume > sellVolume ? 'buyers' : 'sellers',
            ratio: sellVolume > 0 ? (buyVolume / sellVolume).toFixed(2) : 'N/A'
        };
    }

    calculateSentimentScore() {
        if (this.orderFlow.length < 50) return;
        
        const recentTrades = this.orderFlow.slice(0, 100);
        let score = 0;
        let weightedScore = 0;
        let totalWeight = 0;
        
        recentTrades.forEach((trade, index) => {
            const weight = Math.exp(-index * 0.05); // Poids décroissant
            const tradeScore = trade.side === 'Buy' ? 1 : -1;
            const sizeMultiplier = Math.log(trade.size + 1);
            
            weightedScore += tradeScore * weight * sizeMultiplier;
            totalWeight += weight * sizeMultiplier;
        });
        
        this.sentimentScore = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 0;
        
        // Callback vers l'interface
        if (window.updateSentimentDisplay) {
            window.updateSentimentDisplay(this.sentimentScore, this.volumeAnalysis);
        }
    }

    detectLargeOrders(trade) {
        if (trade.isBlockTrade) {
            const alert = {
                type: 'large_order',
                timestamp: new Date(),
                message: `Ordre important détecté: ${trade.side} ${trade.size} à ${trade.price}`,
                trade: trade
            };
            
            this.showLargeOrderAlert(alert);
            
            // Log pour analyse
            console.log('🐋 Ordre important détecté:', trade);
        }
    }

    showLargeOrderAlert(alert) {
        const notification = document.createElement('div');
        notification.className = 'large-order-notification';
        notification.innerHTML = `
            <div class="notification-icon">🐋</div>
            <div class="notification-content">
                <div class="notification-title">Ordre Important</div>
                <div class="notification-message">${alert.message}</div>
                <div class="notification-time">${alert.timestamp.toLocaleTimeString()}</div>
            </div>
        `;
        
        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease-out;
            max-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        }, 7000);
    }

    getAverageTradeSize() {
        if (this.orderFlow.length === 0) return 1;
        
        const total = this.orderFlow.reduce((sum, trade) => sum + trade.size, 0);
        return total / this.orderFlow.length;
    }

    getSentimentSummary() {
        return {
            score: this.sentimentScore,
            interpretation: this.interpretSentiment(this.sentimentScore),
            volumeAnalysis: this.volumeAnalysis,
            recentActivity: this.getRecentActivity(),
            marketPressure: this.getMarketPressure()
        };
    }

    interpretSentiment(score) {
        if (score > 50) return 'Très Haussier';
        if (score > 20) return 'Haussier';
        if (score > -20) return 'Neutre';
        if (score > -50) return 'Baissier';
        return 'Très Baissier';
    }

    getRecentActivity() {
        const recent = this.orderFlow.slice(0, 20);
        return {
            averageSize: recent.reduce((sum, t) => sum + t.size, 0) / recent.length,
            priceMovement: recent.length > 1 ? recent[0].price - recent[recent.length - 1].price : 0,
            frequency: recent.length
        };
    }

    getMarketPressure() {
        const ratio = this.volumeAnalysis.ratio;
        if (ratio === 'N/A') return 'Indéterminé';
        
        const r = parseFloat(ratio);
        if (r > 2) return 'Forte pression acheteuse';
        if (r > 1.5) return 'Pression acheteuse modérée';
        if (r > 0.67) return 'Équilibré';
        if (r > 0.5) return 'Pression vendeuse modérée';
        return 'Forte pression vendeuse';
    }
}

// Gestionnaire d'alertes avancées
class AdvancedAlertManager {
    constructor() {
        this.alerts = new Map();
        this.alertHistory = [];
        this.alertTypes = {
            PRICE: 'price',
            VOLUME: 'volume',
            PATTERN: 'pattern',
            INDICATOR: 'indicator',
            SENTIMENT: 'sentiment',
            ORDER_FLOW: 'order_flow'
        };
        this.init();
    }

    init() {
        this.setupDefaultAlerts();
        this.startAlertMonitoring();
        console.log('🚨 Gestionnaire d\'alertes avancées initialisé');
    }

    setupDefaultAlerts() {
        // Alertes de prix par défaut
        this.createAlert({
            name: 'Support cassé',
            type: this.alertTypes.PRICE,
            condition: 'PRICE < SUPPORT_LEVEL',
            message: 'Le prix a cassé le niveau de support',
            priority: 'high',
            autoTrade: false
        });

        this.createAlert({
            name: 'Résistance franchie',
            type: this.alertTypes.PRICE,
            condition: 'PRICE > RESISTANCE_LEVEL',
            message: 'Le prix a franchi le niveau de résistance',
            priority: 'high',
            autoTrade: false
        });

        // Alertes de volume
        this.createAlert({
            name: 'Volume anormal',
            type: this.alertTypes.VOLUME,
            condition: 'VOLUME > AVERAGE_VOLUME * 3',
            message: 'Volume anormalement élevé détecté',
            priority: 'medium',
            autoTrade: false
        });
    }

    createAlert(alertConfig) {
        const alert = {
            id: Date.now() + Math.random(),
            ...alertConfig,
            created: new Date(),
            triggered: false,
            triggerCount: 0,
            lastTriggered: null,
            active: true
        };

        this.alerts.set(alert.id, alert);
        return alert;
    }

    startAlertMonitoring() {
        setInterval(() => {
            this.checkAllAlerts();
        }, 1000); // Vérification chaque seconde
    }

    checkAllAlerts() {
        const currentData = this.getCurrentMarketData();
        
        this.alerts.forEach(alert => {
            if (alert.active && this.shouldCheckAlert(alert)) {
                if (this.evaluateAlertCondition(alert, currentData)) {
                    this.triggerAlert(alert, currentData);
                }
            }
        });
    }

    shouldCheckAlert(alert) {
        // Éviter les alertes trop fréquentes
        if (alert.lastTriggered) {
            const timeSinceLastTrigger = Date.now() - alert.lastTriggered.getTime();
            const cooldownPeriod = this.getCooldownPeriod(alert.priority);
            return timeSinceLastTrigger > cooldownPeriod;
        }
        return true;
    }

    getCooldownPeriod(priority) {
        switch (priority) {
            case 'high': return 30000; // 30 secondes
            case 'medium': return 60000; // 1 minute
            case 'low': return 300000; // 5 minutes
            default: return 60000;
        }
    }

    evaluateAlertCondition(alert, marketData) {
        try {
            let condition = alert.condition;
            
            // Remplacer les variables par les valeurs réelles
            condition = condition.replace(/PRICE/g, marketData.price);
            condition = condition.replace(/VOLUME/g, marketData.volume);
            condition = condition.replace(/RSI/g, marketData.rsi || 50);
            condition = condition.replace(/MACD/g, marketData.macd || 0);
            condition = condition.replace(/SUPPORT_LEVEL/g, marketData.supportLevel || 0);
            condition = condition.replace(/RESISTANCE_LEVEL/g, marketData.resistanceLevel || 999999);
            condition = condition.replace(/AVERAGE_VOLUME/g, marketData.averageVolume || 1000);
            
            return eval(condition);
        } catch (error) {
            console.error('Erreur évaluation alerte:', error);
            return false;
        }
    }

    triggerAlert(alert, marketData) {
        alert.triggered = true;
        alert.triggerCount++;
        alert.lastTriggered = new Date();

        const alertEvent = {
            alert: alert,
            marketData: marketData,
            timestamp: new Date()
        };

        this.alertHistory.unshift(alertEvent);
        
        // Garder seulement les 100 dernières alertes
        if (this.alertHistory.length > 100) {
            this.alertHistory = this.alertHistory.slice(0, 100);
        }

        this.showAlert(alertEvent);
        this.logAlert(alertEvent);

        // Auto-trading si activé
        if (alert.autoTrade && window.executeAutoTrade) {
            window.executeAutoTrade(alert, marketData);
        }

        // Callback vers l'interface
        if (window.onAdvancedAlert) {
            window.onAdvancedAlert(alertEvent);
        }
    }

    showAlert(alertEvent) {
        const { alert, marketData } = alertEvent;
        
        const notification = document.createElement('div');
        notification.className = `advanced-alert ${alert.priority}`;
        notification.innerHTML = `
            <div class="alert-icon">${this.getAlertIcon(alert.type)}</div>
            <div class="alert-content">
                <div class="alert-title">${alert.name}</div>
                <div class="alert-message">${alert.message}</div>
                <div class="alert-details">Prix: ${marketData.price} | Vol: ${marketData.volume}</div>
                <div class="alert-time">${alertEvent.timestamp.toLocaleTimeString()}</div>
            </div>
            <div class="alert-actions">
                <button onclick="window.dismissAlert('${alert.id}')" class="dismiss-btn">×</button>
            </div>
        `;
        
        const colors = {
            high: '#ef4444',
            medium: '#f59e0b',
            low: '#10b981'
        };
        
        notification.style.cssText = `
            position: fixed;
            top: ${20 + (this.getActiveNotifications() * 90)}px;
            right: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid ${colors[alert.priority]};
            border-radius: 12px;
            padding: 16px;
            color: #ffffff;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: slideInRight 0.4s ease-out;
            max-width: 350px;
            min-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        // Auto-suppression basée sur la priorité
        const autoRemoveTime = alert.priority === 'high' ? 10000 : 
                              alert.priority === 'medium' ? 7000 : 5000;
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutRight 0.4s ease-in';
                setTimeout(() => notification.remove(), 400);
            }
        }, autoRemoveTime);
    }

    getAlertIcon(type) {
        const icons = {
            [this.alertTypes.PRICE]: '💰',
            [this.alertTypes.VOLUME]: '📊',
            [this.alertTypes.PATTERN]: '📈',
            [this.alertTypes.INDICATOR]: '⚡',
            [this.alertTypes.SENTIMENT]: '🎭',
            [this.alertTypes.ORDER_FLOW]: '🌊'
        };
        return icons[type] || '🚨';
    }

    getActiveNotifications() {
        return document.querySelectorAll('.advanced-alert').length;
    }

    getCurrentMarketData() {
        // Récupération des données de marché actuelles
        return {
            price: window.tradingViewManager ? window.tradingViewManager.getCurrentPrice() : 50000,
            volume: Math.random() * 1000 + 500, // Simulé pour l'exemple
            rsi: Math.random() * 100,
            macd: (Math.random() - 0.5) * 2,
            supportLevel: 48000,
            resistanceLevel: 52000,
            averageVolume: 750,
            timestamp: new Date()
        };
    }

    logAlert(alertEvent) {
        console.log(`🚨 ALERTE [${alertEvent.alert.priority.toUpperCase()}]: ${alertEvent.alert.name}`, {
            message: alertEvent.alert.message,
            price: alertEvent.marketData.price,
            time: alertEvent.timestamp.toLocaleString()
        });
    }

    // Interface de gestion des alertes
    getAlertById(id) {
        return this.alerts.get(id);
    }

    updateAlert(id, updates) {
        const alert = this.alerts.get(id);
        if (alert) {
            Object.assign(alert, updates);
            return alert;
        }
        return null;
    }

    deleteAlert(id) {
        return this.alerts.delete(id);
    }

    toggleAlert(id) {
        const alert = this.alerts.get(id);
        if (alert) {
            alert.active = !alert.active;
            return alert;
        }
        return null;
    }

    getAlertHistory(limit = 50) {
        return this.alertHistory.slice(0, limit);
    }

    getAlertStatistics() {
        const total = this.alerts.size;
        const active = Array.from(this.alerts.values()).filter(a => a.active).length;
        const triggered = Array.from(this.alerts.values()).filter(a => a.triggered).length;
        
        return {
            total,
            active,
            inactive: total - active,
            triggered,
            triggerRate: total > 0 ? (triggered / total * 100).toFixed(1) + '%' : '0%',
            recentTriggers: this.alertHistory.slice(0, 10)
        };
    }
}

// Initialisation des modules étendus
let marketSentimentAnalyzer;
let advancedAlertManager;

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        marketSentimentAnalyzer = new MarketSentimentAnalyzer();
        advancedAlertManager = new AdvancedAlertManager();
    }, 2000);
});

// Fonctions globales pour l'interface
window.dismissAlert = (alertId) => {
    const notifications = document.querySelectorAll('.advanced-alert');
    notifications.forEach(notification => {
        if (notification.innerHTML.includes(alertId)) {
            notification.remove();
        }
    });
};

window.getSentimentAnalysis = () => {
    return marketSentimentAnalyzer ? marketSentimentAnalyzer.getSentimentSummary() : null;
};

window.createCustomAlert = (config) => {
    return advancedAlertManager ? advancedAlertManager.createAlert(config) : null;
};

window.getAlertStatistics = () => {
    return advancedAlertManager ? advancedAlertManager.getAlertStatistics() : null;
};

# Module 4

"""
SLM TRADE - Module 4: Stratégies de Trading Algorithmiques & IA
================================================================

Ce module implémente des stratégies de trading avancées avec:
- Machine Learning pour la prédiction de prix
- Backtesting sophistiqué avec métriques détaillées
- Optimisation automatique des paramètres
- Signaux multi-timeframes
- Exécution automatique des trades
- Stratégies adaptatives basées sur l'IA

Auteur: Assistant IA
Version: 4.0
"""

import pandas as pd
import numpy as np
import yfinance as yf
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import ta
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class SLMAlgorithmicTrader:
    """
    Système de trading algorithmique avancé avec IA
    """
    
    def __init__(self):
        self.strategies = {}
        self.models = {}
        self.scalers = {}
        self.backtest_results = {}
        self.active_positions = {}
        self.performance_metrics = {}
        
    def fetch_data(self, symbol, period="2y", interval="1d"):
        """Récupère les données de marché"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period, interval=interval)
            
            if data.empty:
                print(f"❌ Aucune donnée trouvée pour {symbol}")
                return None
                
            # Calcul des indicateurs techniques
            data = self.calculate_technical_indicators(data)
            print(f"✅ Données récupérées pour {symbol}: {len(data)} barres")
            return data
            
        except Exception as e:
            print(f"❌ Erreur lors de la récupération des données: {e}")
            return None
    
    def calculate_technical_indicators(self, data):
        """Calcule tous les indicateurs techniques nécessaires"""
        # Moyennes mobiles
        data['SMA_20'] = ta.trend.sma_indicator(data['Close'], window=20)
        data['SMA_50'] = ta.trend.sma_indicator(data['Close'], window=50)
        data['EMA_12'] = ta.trend.ema_indicator(data['Close'], window=12)
        data['EMA_26'] = ta.trend.ema_indicator(data['Close'], window=26)
        
        # MACD
        data['MACD'] = ta.trend.macd_diff(data['Close'])
        data['MACD_signal'] = ta.trend.macd_signal(data['Close'])
        
        # RSI
        data['RSI'] = ta.momentum.rsi(data['Close'])
        
        # Bollinger Bands
        data['BB_upper'] = ta.volatility.bollinger_hband(data['Close'])
        data['BB_lower'] = ta.volatility.bollinger_lband(data['Close'])
        data['BB_middle'] = ta.volatility.bollinger_mavg(data['Close'])
        
        # Stochastic
        data['Stoch_K'] = ta.momentum.stoch(data['High'], data['Low'], data['Close'])
        data['Stoch_D'] = ta.momentum.stoch_signal(data['High'], data['Low'], data['Close'])
        
        # ATR
        data['ATR'] = ta.volatility.average_true_range(data['High'], data['Low'], data['Close'])
        
        # Volume indicators
        data['Volume_SMA'] = data['Volume'].rolling(window=20).mean()
        data['OBV'] = ta.volume.on_balance_volume(data['Close'], data['Volume'])
        
        # Momentum
        data['ROC'] = ta.momentum.roc(data['Close'], window=12)
        data['Williams_R'] = ta.momentum.williams_r(data['High'], data['Low'], data['Close'])
        
        # Volatilité
        data['Close_returns'] = data['Close'].pct_change()
        data['Volatility'] = data['Close_returns'].rolling(window=20).std()
        
        return data
    
    def prepare_ml_features(self, data):
        """Prépare les features pour le machine learning"""
        features = []
        
        # Features techniques
        feature_columns = [
            'SMA_20', 'SMA_50', 'EMA_12', 'EMA_26', 'MACD', 'MACD_signal',
            'RSI', 'BB_upper', 'BB_lower', 'Stoch_K', 'Stoch_D', 'ATR',
            'Volume_SMA', 'OBV', 'ROC', 'Williams_R', 'Volatility'
        ]
        
        # Ratios et relations
        data['Price_to_SMA20'] = data['Close'] / data['SMA_20']
        data['Price_to_SMA50'] = data['Close'] / data['SMA_50']
        data['BB_position'] = (data['Close'] - data['BB_lower']) / (data['BB_upper'] - data['BB_lower'])
        data['Volume_ratio'] = data['Volume'] / data['Volume_SMA']
        
        feature_columns.extend(['Price_to_SMA20', 'Price_to_SMA50', 'BB_position', 'Volume_ratio'])
        
        # Features de lag
        for col in ['Close', 'Volume', 'RSI', 'MACD']:
            for lag in [1, 2, 3, 5]:
                data[f'{col}_lag_{lag}'] = data[col].shift(lag)
                feature_columns.append(f'{col}_lag_{lag}')
        
        # Target: rendement futur
        data['Future_return'] = data['Close'].shift(-1) / data['Close'] - 1
        
        # Nettoyage des NaN
        data_clean = data[feature_columns + ['Future_return']].dropna()
        
        return data_clean[feature_columns], data_clean['Future_return']
    
    def train_ml_models(self, symbol, data):
        """Entraîne les modèles de machine learning"""
        print(f"\n🤖 Entraînement des modèles ML pour {symbol}...")
        
        X, y = self.prepare_ml_features(data)
        
        if len(X) < 100:
            print("❌ Pas assez de données pour l'entraînement ML")
            return False
        
        # Division train/test
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
        
        # Normalisation
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
        
        self.scalers[symbol] = scaler
        
        # Modèles
        models = {
            'RandomForest': RandomForestRegressor(n_estimators=100, random_state=42),
            'GradientBoosting': GradientBoostingRegressor(n_estimators=100, random_state=42),
            'LinearRegression': LinearRegression()
        }
        
        self.models[symbol] = {}
        model_scores = {}
        
        for name, model in models.items():
            if name == 'LinearRegression':
                model.fit(X_train_scaled, y_train)
                y_pred = model.predict(X_test_scaled)
            else:
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)
            
            score = r2_score(y_test, y_pred)
            mse = mean_squared_error(y_test, y_pred)
            
            self.models[symbol][name] = model
            model_scores[name] = {'R2': score, 'MSE': mse}
            
            print(f"  {name}: R² = {score:.4f}, MSE = {mse:.6f}")
        
        # Sélection du meilleur modèle
        best_model = max(model_scores.keys(), key=lambda x: model_scores[x]['R2'])
        print(f"✅ Meilleur modèle: {best_model}")
        
        return True
    
    def get_ml_signal(self, symbol, current_data):
        """Obtient un signal de trading basé sur ML"""
        if symbol not in self.models or not self.models[symbol]:
            return 0, 0.5  # Signal neutre si pas de modèle
        
        try:
            # Préparation des features actuelles
            X_current, _ = self.prepare_ml_features(current_data.tail(100))
            
            if len(X_current) == 0:
                return 0, 0.5
            
            X_latest = X_current.iloc[-1:].values
            
            # Prédictions de tous les modèles
            predictions = []
            for name, model in self.models[symbol].items():
                if name == 'LinearRegression':
                    X_scaled = self.scalers[symbol].transform(X_latest)
                    pred = model.predict(X_scaled)[0]
                else:
                    pred = model.predict(X_latest)[0]
                predictions.append(pred)
            
            # Prédiction moyenne
            avg_prediction = np.mean(predictions)
            confidence = 1 - np.std(predictions)  # Confiance basée sur consensus
            
            # Signal basé sur la prédiction
            if avg_prediction > 0.005:  # +0.5%
                signal = 1  # Achat
            elif avg_prediction < -0.005:  # -0.5%
                signal = -1  # Vente
            else:
                signal = 0  # Neutre
            
            return signal, min(max(confidence, 0), 1)
            
        except Exception as e:
            print(f"⚠️ Erreur ML signal: {e}")
            return 0, 0.5
    
    def multi_timeframe_analysis(self, symbol):
        """Analyse multi-timeframes"""
        timeframes = {
            '1h': {'period': '30d', 'interval': '1h', 'weight': 0.2},
            '4h': {'period': '60d', 'interval': '4h', 'weight': 0.3},
            '1d': {'period': '1y', 'interval': '1d', 'weight': 0.5}
        }
        
        signals = {}
        
        for tf, params in timeframes.items():
            data = self.fetch_data(symbol, params['period'], params['interval'])
            if data is not None and len(data) > 50:
                signal = self.get_combined_signal(data)
                signals[tf] = {
                    'signal': signal['signal'],
                    'strength': signal['strength'],
                    'weight': params['weight']
                }
        
        if not signals:
            return {'signal': 0, 'strength': 0.5, 'timeframes': {}}
        
        # Signal pondéré
        weighted_signal = sum(s['signal'] * s['weight'] for s in signals.values())
        weighted_strength = sum(s['strength'] * s['weight'] for s in signals.values())
        
        final_signal = 1 if weighted_signal > 0.3 else (-1 if weighted_signal < -0.3 else 0)
        
        return {
            'signal': final_signal,
            'strength': weighted_strength,
            'timeframes': signals,
            'weighted_signal': weighted_signal
        }
    
    def get_combined_signal(self, data):
        """Combine plusieurs signaux pour une décision finale"""
        if len(data) < 50:
            return {'signal': 0, 'strength': 0.5}
        
        signals = []
        current = data.iloc[-1]
        prev = data.iloc[-2]
        
        # Signal 1: Croisement moyennes mobiles
        if current['SMA_20'] > current['SMA_50'] and prev['SMA_20'] <= prev['SMA_50']:
            signals.append(1)  # Golden cross
        elif current['SMA_20'] < current['SMA_50'] and prev['SMA_20'] >= prev['SMA_50']:
            signals.append(-1)  # Death cross
        
        # Signal 2: RSI
        if current['RSI'] < 30:
            signals.append(1)  # Survente
        elif current['RSI'] > 70:
            signals.append(-1)  # Surachat
        
        # Signal 3: MACD
        if current['MACD'] > current['MACD_signal'] and prev['MACD'] <= prev['MACD_signal']:
            signals.append(1)  # Croisement haussier
        elif current['MACD'] < current['MACD_signal'] and prev['MACD'] >= prev['MACD_signal']:
            signals.append(-1)  # Croisement baissier
        
        # Signal 4: Bollinger Bands
        if current['Close'] < current['BB_lower']:
            signals.append(1)  # Rebond potentiel
        elif current['Close'] > current['BB_upper']:
            signals.append(-1)  # Correction potentielle
        
        # Signal 5: Stochastic
        if current['Stoch_K'] < 20 and current['Stoch_K'] > current['Stoch_D']:
            signals.append(1)
        elif current['Stoch_K'] > 80 and current['Stoch_K'] < current['Stoch_D']:
            signals.append(-1)
        
        if not signals:
            return {'signal': 0, 'strength': 0.5}
        
        # Calcul du signal final
        avg_signal = np.mean(signals)
        strength = abs(avg_signal)
        
        final_signal = 1 if avg_signal > 0.2 else (-1 if avg_signal < -0.2 else 0)
        
        return {'signal': final_signal, 'strength': min(strength, 1.0)}
    
    def backtest_strategy(self, symbol, data, strategy_name="Combined", 
                         initial_capital=10000, commission=0.001):
        """Backtesting complet d'une stratégie"""
        print(f"\n📊 Backtesting de la stratégie {strategy_name} pour {symbol}")
        
        if len(data) < 100:
            print("❌ Pas assez de données pour le backtesting")
            return None
        
        # Initialisation
        capital = initial_capital
        position = 0  # 0: neutre, 1: long, -1: short
        entry_price = 0
        trades = []
        equity_curve = []
        
        for i in range(50, len(data)):
            current_data = data.iloc[:i+1]
            current_row = data.iloc[i]
            
            # Obtenir le signal
            signal_data = self.get_combined_signal(current_data)
            signal = signal_data['signal']
            strength = signal_data['strength']
            
            date = current_row.name
            price = current_row['Close']
            
            # Gestion des positions
            if position == 0 and signal != 0 and strength > 0.6:
                # Entrée en position
                position = signal
                entry_price = price
                trade_capital = capital * 0.95  # 95% du capital
                shares = trade_capital / price
                commission_cost = trade_capital * commission
                capital -= commission_cost
                
                trades.append({
                    'date': date,
                    'type': 'ENTRY',
                    'signal': signal,
                    'price': price,
                    'shares': shares,
                    'capital': capital,
                    'strength': strength
                })
                
            elif position != 0:
                # Gestion de la sortie
                exit_signal = False
                
                # Stop loss et take profit
                if position == 1:  # Position longue
                    pnl_pct = (price - entry_price) / entry_price
                    if pnl_pct <= -0.05 or pnl_pct >= 0.15:  # -5% stop loss, +15% take profit
                        exit_signal = True
                    elif signal == -1 and strength > 0.6:  # Signal contraire fort
                        exit_signal = True
                        
                elif position == -1:  # Position courte
                    pnl_pct = (entry_price - price) / entry_price
                    if pnl_pct <= -0.05 or pnl_pct >= 0.15:
                        exit_signal = True
                    elif signal == 1 and strength > 0.6:
                        exit_signal = True
                
                if exit_signal:
                    # Sortie de position
                    trade_value = shares * price
                    commission_cost = trade_value * commission
                    capital = trade_value - commission_cost
                    
                    pnl = capital - initial_capital if len(trades) == 1 else capital - trades[-1]['capital']
                    
                    trades.append({
                        'date': date,
                        'type': 'EXIT',
                        'signal': -position,
                        'price': price,
                        'shares': shares,
                        'capital': capital,
                        'pnl': pnl,
                        'pnl_pct': pnl / entry_price if entry_price > 0 else 0
                    })
                    
                    position = 0
                    entry_price = 0
            
            # Courbe de capital
            if position == 0:
                current_capital = capital
            else:
                current_value = shares * price
                current_capital = current_value - (shares * entry_price - capital)
            
            equity_curve.append({
                'date': date,
                'equity': current_capital,
                'price': price
            })
        
        # Calcul des métriques de performance
        if len(trades) < 2:
            print("❌ Pas assez de trades pour l'analyse")
            return None
        
        metrics = self.calculate_performance_metrics(trades, equity_curve, initial_capital)
        
        self.backtest_results[f"{symbol}_{strategy_name}"] = {
            'trades': trades,
            'equity_curve': equity_curve,
            'metrics': metrics
        }
        
        self.print_backtest_results(symbol, strategy_name, metrics)
        return metrics
    
    def calculate_performance_metrics(self, trades, equity_curve, initial_capital):
        """Calcule les métriques de performance détaillées"""
        # Extraction des PnL
        completed_trades = [t for t in trades if t['type'] == 'EXIT']
        
        if not completed_trades:
            return {}
        
        pnls = [trade['pnl'] for trade in completed_trades]
        
        # Métriques de base
        total_trades = len(completed_trades)
        winning_trades = len([p for p in pnls if p > 0])
        losing_trades = len([p for p in pnls if p < 0])
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_return = (equity_curve[-1]['equity'] - initial_capital) / initial_capital
        avg_return_per_trade = np.mean(pnls) / initial_capital if pnls else 0
        
        # Drawdown
        peak = initial_capital
        max_drawdown = 0
        drawdowns = []
        
        for point in equity_curve:
            if point['equity'] > peak:
                peak = point['equity']
            drawdown = (peak - point['equity']) / peak
            drawdowns.append(drawdown)
            if drawdown > max_drawdown:
                max_drawdown = drawdown
        
        # Ratio de Sharpe (approximatif)
        if len(pnls) > 1:
            returns_std = np.std(pnls) / initial_capital
            sharpe_ratio = avg_return_per_trade / returns_std if returns_std > 0 else 0
        else:
            sharpe_ratio = 0
        
        # Profit factor
        gross_profit = sum([p for p in pnls if p > 0])
        gross_loss = abs(sum([p for p in pnls if p < 0]))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        return {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': win_rate,
            'total_return': total_return,
            'total_return_pct': total_return * 100,
            'avg_return_per_trade': avg_return_per_trade,
            'max_drawdown': max_drawdown,
            'max_drawdown_pct': max_drawdown * 100,
            'sharpe_ratio': sharpe_ratio,
            'profit_factor': profit_factor,
            'gross_profit': gross_profit,
            'gross_loss': gross_loss,
            'final_capital': equity_curve[-1]['equity']
        }
    
    def print_backtest_results(self, symbol, strategy, metrics):
        """Affiche les résultats du backtesting"""
        print(f"\n{'='*60}")
        print(f"📈 RÉSULTATS BACKTESTING - {symbol} ({strategy})")
        print(f"{'='*60}")
        
        print(f"💰 Performance Globale:")
        print(f"   Rendement Total: {metrics['total_return_pct']:.2f}%")
        print(f"   Capital Final: ${metrics['final_capital']:,.2f}")
        print(f"   Drawdown Max: {metrics['max_drawdown_pct']:.2f}%")
        
        print(f"\n📊 Statistiques de Trading:")
        print(f"   Nombre de Trades: {metrics['total_trades']}")
        print(f"   Trades Gagnants: {metrics['winning_trades']}")
        print(f"   Trades Perdants: {metrics['losing_trades']}")
        print(f"   Taux de Réussite: {metrics['win_rate']*100:.1f}%")
        
        print(f"\n📏 Métriques de Risque:")
        print(f"   Ratio de Sharpe: {metrics['sharpe_ratio']:.2f}")
        print(f"   Profit Factor: {metrics['profit_factor']:.2f}")
        print(f"   Profit Brut: ${metrics['gross_profit']:,.2f}")
        print(f"   Perte Brute: ${metrics['gross_loss']:,.2f}")
    
    def optimize_strategy_parameters(self, symbol, data):
        """Optimise automatiquement les paramètres de stratégie"""
        print(f"\n🔧 Optimisation des paramètres pour {symbol}...")
        
        # Paramètres à optimiser
        rsi_thresholds = [(20, 80), (25, 75), (30, 70)]
        sma_periods = [(10, 30), (20, 50), (15, 45)]
        stop_loss_levels = [0.03, 0.05, 0.07]  # 3%, 5%, 7%
        take_profit_levels = [0.10, 0.15, 0.20]  # 10%, 15%, 20%
        
        best_params = None
        best_performance = -float('inf')
        
        optimization_results = []
        
        for rsi_low, rsi_high in rsi_thresholds:
            for sma_short, sma_long in sma_periods:
                for stop_loss in stop_loss_levels:
                    for take_profit in take_profit_levels:
                        
                        # Simulation avec ces paramètres
                        performance = self.simulate_with_parameters(
                            data, rsi_low, rsi_high, sma_short, sma_long, 
                            stop_loss, take_profit
                        )
                        
                        optimization_results.append({
                            'params': {
                                'rsi_low': rsi_low,
                                'rsi_high': rsi_high,
                                'sma_short': sma_short,
                                'sma_long': sma_long,
                                'stop_loss': stop_loss,
                                'take_profit': take_profit
                            },
                            'performance': performance,
                            'score': performance.get('total_return', 0) - performance.get('max_drawdown', 1)
                        })
        
        # Sélection des meilleurs paramètres
        if optimization_results:
            best_result = max(optimization_results, key=lambda x: x['score'])
            best_params = best_result['params']
            best_performance = best_result['performance']
            
            print(f"✅ Meilleurs paramètres trouvés:")
            for param, value in best_params.items():
                print(f"   {param}: {value}")
            print(f"   Score: {best_result['score']:.4f}")
            print(f"   Rendement: {best_performance.get('total_return_pct', 0):.2f}%")
        
        return best_params, optimization_results
    
    def simulate_with_parameters(self, data, rsi_low, rsi_high, sma_short, sma_long, 
                                stop_loss, take_profit, initial_capital=10000):
        """Simule une stratégie avec des paramètres spécifiques"""
        if len(data) < max(sma_long, 50):
            return {'total_return': -1, 'max_drawdown': 1}
        
        # Recalcul des indicateurs avec nouveaux paramètres
        data_copy = data.copy()
        data_copy[f'SMA_{sma_short}'] = ta.trend.sma_indicator(data_copy['Close'], window=sma_short)
        data_copy[f'SMA_{sma_long}'] = ta.trend.sma_indicator(data_copy['Close'], window=sma_long)
        
        capital = initial_capital
        position = 0
        entry_price = 0
        equity_curve = []
        
        for i in range(sma_long, len(data_copy)):
            current = data_copy.iloc[i]
            prev = data_copy.iloc[i-1]
            
            price = current['Close']
            
            # Signaux avec paramètres optimisés
            signal = 0
            
            # Croisement moyennes mobiles
            if (current[f'SMA_{sma_short}'] > current[f'SMA_{sma_long}'] and 
                prev[f'SMA_{sma_short}'] <= prev[f'SMA_{sma_long}']):
                signal = 1
            elif (current[f'SMA_{sma_short}'] < current[f'SMA_{sma_long}'] and 
                  prev[f'SMA_{sma_short}'] >= prev[f'SMA_{sma_long}']):
                signal = -1
            
            # Confirmation RSI
            if signal == 1 and current['RSI'] > rsi_high:
                signal = 0  # Pas d'achat si surachat
            elif signal == -1 and current['RSI'] < rsi_low:
                signal = 0  # Pas de vente si survente
            
            # Gestion des positions
            if position == 0 and signal != 0:
                position = signal
                entry_price = price
                shares = capital * 0.95 / price
                
            elif position != 0:
                pnl_pct = (price - entry_price) / entry_price * position
                
                if pnl_pct <= -stop_loss or pnl_pct >= take_profit or signal == -position:
                    capital = shares * price * 0.999  # Commission
                    position = 0
                    entry_price = 0
            
            # Équité courante
            if position == 0:
                current_equity = capital
            else:
                current_equity = shares * price * 0.999
            
            equity_curve.append(current_equity)
        
        if not equity_curve:
            return {'total_return': -1, 'max_drawdown': 1}
        
        # Calcul des métriques simplifiées
        final_equity = equity_curve[-1]
        total_return = (final_equity - initial_capital) / initial_capital
        
        # Drawdown
        peak = initial_capital
        max_drawdown = 0
        for equity in equity_curve:
            if equity > peak:
                peak = equity
            drawdown = (peak - equity) / peak
            if drawdown > max_drawdown:
                max_drawdown = drawdown
        
        return {
            'total_return': total_return,
            'total_return_pct': total_return * 100,
            'max_drawdown': max_drawdown,
            'final_equity': final_equity
        }
    
    def generate_trading_report(self, symbol):
        """Génère un rapport de trading complet"""
        print(f"\n📋 RAPPORT DE TRADING COMPLET - {symbol}")
        print("="*70)
        
        # Analyse multi-timeframes
        mtf_analysis = self.multi_timeframe_analysis(symbol)
        
        print(f"\n🔍 ANALYSE MULTI-TIMEFRAMES:")
        print(f"Signal Global: {self.signal_to_text(mtf_analysis['signal'])}")
        print(f"Force du Signal: {mtf_analysis['strength']:.2f}")
        print(f"Score Pondéré: {mtf_analysis.get('weighted_signal', 0):.2f}")
        
        for tf, data in mtf_analysis.get('timeframes', {}).items():
            print(f"  {tf}: {self.signal_to_text(data['signal'])} (Force: {data['strength']:.2f})")
        
        # Analyse ML si disponible
        if symbol in self.models and self.models[symbol]:
            daily_data = self.fetch_data(symbol, period="1y", interval="1d")
            if daily_data is not None:
                ml_signal, ml_confidence = self.get_ml_signal(symbol, daily_data)
                print(f"\n🤖 ANALYSE MACHINE LEARNING:")
                print(f"Signal ML: {self.signal_to_text(ml_signal)}")
                print(f"Confiance: {ml_confidence:.2f}")
                
                # Prédictions individuelles des modèles
                X, _ = self.prepare_ml_features(daily_data.tail(100))
                if len(X) > 0:
                    X_latest = X.iloc[-1:].values
                    print(f"Prédictions des modèles:")
                    for name, model in self.models[symbol].items():
                        try:
                            if name == 'LinearRegression':
                                X_scaled = self.scalers[symbol].transform(X_latest)
                                pred = model.predict(X_scaled)[0]
                            else:
                                pred = model.predict(X_latest)[0]
                            print(f"  {name}: {pred*100:.2f}% de rendement prédit")
                        except:
                            pass
        
        # Recommandations finales
        print(f"\n💡 RECOMMANDATIONS:")
        overall_signal = mtf_analysis['signal']
        overall_strength = mtf_analysis['strength']
        
        if overall_signal == 1 and overall_strength > 0.7:
            print("🟢 FORTE RECOMMANDATION D'ACHAT")
            print("   - Signaux haussiers convergents sur plusieurs timeframes")
            print("   - Niveau de confiance élevé")
        elif overall_signal == 1 and overall_strength > 0.5:
            print("🟡 RECOMMANDATION D'ACHAT MODÉRÉE")
            print("   - Signaux haussiers présents mais force modérée")
            print("   - Surveiller les confirmations")
        elif overall_signal == -1 and overall_strength > 0.7:
            print("🔴 FORTE RECOMMANDATION DE VENTE")
            print("   - Signaux baissiers convergents")
            print("   - Risque de correction important")
        elif overall_signal == -1 and overall_strength > 0.5:
            print("🟡 RECOMMANDATION DE VENTE MODÉRÉE")
            print("   - Signaux baissiers présents")
            print("   - Prudence recommandée")
        else:
            print("⚪ POSITION NEUTRE")
            print("   - Signaux mixtes ou faibles")
            print("   - Attendre des signaux plus clairs")
        
        return {
            'symbol': symbol,
            'multi_timeframe': mtf_analysis,
            'ml_analysis': {'signal': ml_signal, 'confidence': ml_confidence} if symbol in self.models else None,
            'recommendation': overall_signal,
            'strength': overall_strength
        }
    
    def signal_to_text(self, signal):
        """Convertit un signal numérique en texte"""
        if signal == 1:
            return "🟢 ACHAT"
        elif signal == -1:
            return "🔴 VENTE"
        else:
            return "⚪ NEUTRE"
    
    def auto_trade_execution(self, symbol, signal_data, position_size=0.1):
        """Exécution automatique des trades (simulation)"""
        print(f"\n🚀 EXÉCUTION AUTOMATIQUE - {symbol}")
        
        signal = signal_data['signal']
        strength = signal_data['strength']
        
        if signal == 0 or strength < 0.6:
            print("❌ Signal trop faible pour l'exécution automatique")
            return False
        
        # Récupération du prix actuel
        current_data = self.fetch_data(symbol, period="5d", interval="1h")
        if current_data is None or len(current_data) == 0:
            print("❌ Impossible de récupérer le prix actuel")
            return False
        
        current_price = current_data['Close'].iloc[-1]
        
        # Calcul de la taille de position
        risk_per_trade = 0.02  # 2% du capital par trade
        stop_loss_pct = 0.05  # Stop loss à 5%
        
        # Simulation d'exécution
        if symbol not in self.active_positions:
            self.active_positions[symbol] = []
        
        trade = {
            'timestamp': datetime.now(),
            'signal': signal,
            'entry_price': current_price,
            'position_size': position_size,
            'stop_loss': current_price * (1 - stop_loss_pct) if signal == 1 else current_price * (1 + stop_loss_pct),
            'take_profit': current_price * (1 + 0.15) if signal == 1 else current_price * (1 - 0.15),
            'strength': strength,
            'status': 'ACTIVE'
        }
        
        self.active_positions[symbol].append(trade)
        
        print(f"✅ Trade exécuté:")
        print(f"   Signal: {self.signal_to_text(signal)}")
        print(f"   Prix d'entrée: ${current_price:.2f}")
        print(f"   Stop Loss: ${trade['stop_loss']:.2f}")
        print(f"   Take Profit: ${trade['take_profit']:.2f}")
        print(f"   Force du signal: {strength:.2f}")
        
        return True
    
    def monitor_active_positions(self):
        """Surveillance des positions actives"""
        if not self.active_positions:
            print("📊 Aucune position active à surveiller")
            return
        
        print(f"\n👁️ SURVEILLANCE DES POSITIONS ACTIVES")
        print("="*50)
        
        for symbol, positions in self.active_positions.items():
            active_positions = [p for p in positions if p['status'] == 'ACTIVE']
            
            if not active_positions:
                continue
                
            print(f"\n📈 {symbol}:")
            
            # Prix actuel
            current_data = self.fetch_data(symbol, period="2d", interval="1h")
            if current_data is None:
                continue
                
            current_price = current_data['Close'].iloc[-1]
            
            for i, position in enumerate(active_positions):
                entry_price = position['entry_price']
                signal = position['signal']
                
                # Calcul du PnL
                if signal == 1:  # Position longue
                    pnl_pct = (current_price - entry_price) / entry_price * 100
                else:  # Position courte
                    pnl_pct = (entry_price - current_price) / entry_price * 100
                
                pnl_color = "🟢" if pnl_pct > 0 else "🔴"
                
                print(f"  Position #{i+1}:")
                print(f"    Signal: {self.signal_to_text(signal)}")
                print(f"    Prix d'entrée: ${entry_price:.2f}")
                print(f"    Prix actuel: ${current_price:.2f}")
                print(f"    PnL: {pnl_color} {pnl_pct:+.2f}%")
                print(f"    Stop Loss: ${position['stop_loss']:.2f}")
                print(f"    Take Profit: ${position['take_profit']:.2f}")
                
                # Vérification des conditions de sortie
                if signal == 1:  # Position longue
                    if current_price <= position['stop_loss']:
                        print(f"    ⚠️ STOP LOSS ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'STOP_LOSS'
                    elif current_price >= position['take_profit']:
                        print(f"    🎯 TAKE PROFIT ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'TAKE_PROFIT'
                else:  # Position courte
                    if current_price >= position['stop_loss']:
                        print(f"    ⚠️ STOP LOSS ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'STOP_LOSS'
                    elif current_price <= position['take_profit']:
                        print(f"    🎯 TAKE PROFIT ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'TAKE_PROFIT'
                
                print()
    
    def run_complete_analysis(self, symbol):
        """Lance une analyse complète avec toutes les fonctionnalités"""
        print(f"\n🎯 ANALYSE COMPLÈTE - {symbol}")
        print("="*60)
        
        # 1. Récupération des données
        data = self.fetch_data(symbol, period="2y", interval="1d")
        if data is None:
            return None
        
        # 2. Entraînement des modèles ML
        ml_success = self.train_ml_models(symbol, data)
        
        # 3. Backtesting
        backtest_results = self.backtest_strategy(symbol, data)
        
        # 4. Optimisation des paramètres
        if len(data) > 200:  # Seulement si assez de données
            best_params, optimization_results = self.optimize_strategy_parameters(symbol, data)
        
        # 5. Rapport de trading
        trading_report = self.generate_trading_report(symbol)
        
        # 6. Recommandation finale
        final_recommendation = self.get_final_recommendation(symbol, trading_report, backtest_results)
        
        return {
            'symbol': symbol,
            'ml_trained': ml_success,
            'backtest': backtest_results,
            'trading_report': trading_report,
            'recommendation': final_recommendation
        }
    
    def get_final_recommendation(self, symbol, trading_report, backtest_results):
        """Formule une recommandation finale basée sur toutes les analyses"""
        print(f"\n🎯 RECOMMANDATION FINALE - {symbol}")
        print("="*50)
        
        score = 0
        factors = []
        
        # Facteur 1: Signal multi-timeframes
        mtf_signal = trading_report['multi_timeframe']['signal']
        mtf_strength = trading_report['multi_timeframe']['strength']
        
        if mtf_signal == 1 and mtf_strength > 0.7:
            score += 3
            factors.append("✅ Signaux haussiers forts multi-timeframes")
        elif mtf_signal == 1 and mtf_strength > 0.5:
            score += 1
            factors.append("🟡 Signaux haussiers modérés")
        elif mtf_signal == -1 and mtf_strength > 0.7:
            score -= 3
            factors.append("❌ Signaux baissiers forts")
        elif mtf_signal == -1 and mtf_strength > 0.5:
            score -= 1
            factors.append("🟡 Signaux baissiers modérés")
        
        # Facteur 2: Performance du backtesting
        if backtest_results:
            win_rate = backtest_results.get('win_rate', 0)
            total_return = backtest_results.get('total_return', 0)
            max_drawdown = backtest_results.get('max_drawdown', 1)
            
            if win_rate > 0.6 and total_return > 0.15 and max_drawdown < 0.15:
                score += 2
                factors.append("✅ Excellent historique de performance")
            elif win_rate > 0.5 and total_return > 0:
                score += 1
                factors.append("🟡 Performance historique correcte")
            else:
                score -= 1
                factors.append("❌ Performance historique faible")
        
        # Facteur 3: ML si disponible
        if trading_report.get('ml_analysis'):
            ml_signal = trading_report['ml_analysis']['signal']
            ml_confidence = trading_report['ml_analysis']['confidence']
            
            if ml_signal == mtf_signal and ml_confidence > 0.7:
                score += 1
                factors.append("✅ Confirmation par IA")
            elif ml_signal != mtf_signal:
                score -= 1
                factors.append("⚠️ Divergence avec l'IA")
        
        # Recommandation finale
        if score >= 4:
            recommendation = "FORTE RECOMMANDATION D'ACHAT"
            action = "🟢 ACHETER"
            risk_level = "Faible à Modéré"
        elif score >= 2:
            recommendation = "RECOMMANDATION D'ACHAT"
            action = "🟡 ACHETER (avec prudence)"
            risk_level = "Modéré"
        elif score <= -4:
            recommendation = "FORTE RECOMMANDATION DE VENTE"
            action = "🔴 VENDRE"
            risk_level = "Élevé"
        elif score <= -2:
            recommendation = "RECOMMANDATION DE VENTE"
            action = "🟡 VENDRE (avec prudence)"
            risk_level = "Modéré à Élevé"
        else:
            recommendation = "POSITION NEUTRE"
            action = "⚪ ATTENDRE"
            risk_level = "Variable"
        
        print(f"Action Recommandée: {action}")
        print(f"Niveau de Risque: {risk_level}")
        print(f"Score Global: {score}/10")
        print(f"\nFacteurs Analysés:")
        for factor in factors:
            print(f"  {factor}")
        
        print(f"\n💼 CONSEILS DE GESTION:")
        if score > 0:
            print("  • Taille de position recommandée: 2-5% du portefeuille")
            print("  • Stop loss suggéré: 5-7% sous le prix d'entrée")
            print("  • Take profit: 15-20% au-dessus du prix d'entrée")
        elif score < 0:
            print("  • Éviter les nouvelles positions longues")
            print("  • Considérer une position courte si expertise suffisante")
            print("  • Surveiller les signaux de retournement")
        else:
            print("  • Attendre des signaux plus clairs")
            print("  • Surveiller l'évolution des indicateurs")
            print("  • Maintenir la diversification")
        
        return {
            'action': action,
            'recommendation': recommendation,
            'score': score,
            'risk_level': risk_level,
            'factors': factors
        }


# Exemple d'utilisation du système complet
def demo_slm_algorithmic_trading():
    """Démonstration du système de trading algorithmique SLM"""
    print("🚀 DÉMONSTRATION SLM ALGORITHMIC TRADER")
    print("="*60)
    
    # Initialisation
    trader = SLMAlgorithmicTrader()
    
    # Symboles à analyser
    symbols = ['AAPL', 'MSFT', 'GOOGL']
    
    print("📊 Analyse en cours des symboles:", symbols)
    print("⏱️ Cela peut prendre quelques minutes...")
    
    results = {}
    
    for symbol in symbols:
        print(f"\n{'='*20} {symbol} {'='*20}")
        
        try:
            # Analyse complète
            result = trader.run_complete_analysis(symbol)
            results[symbol] = result
            
            # Simulation d'exécution automatique si signal fort
            if result and result['recommendation']['score'] >= 3:
                trader.auto_trade_execution(symbol, result['trading_report']['multi_timeframe'])
            
        except Exception as e:
            print(f"❌ Erreur lors de l'analyse de {symbol}: {e}")
            continue
    
    # Surveillance des positions
    trader.monitor_active_positions()
    
    # Résumé final
    print(f"\n📋 RÉSUMÉ FINAL")
    print("="*40)
    
    for symbol, result in results.items():
        if result:
            rec = result['recommendation']
            print(f"{symbol}: {rec['action']} (Score: {rec['score']})")
    
    return trader, results


if __name__ == "__main__":
    # Démonstration
    trader, results = demo_slm_algorithmic_trading()
    
    print("\n🎉 Démonstration terminée!")
    print("\nFonctionnalités implémentées:")
    print("✅ Machine Learning multi-modèles")
    print("✅ Backtesting complet avec métriques")
    print("✅ Optimisation automatique des paramètres")
    print("✅ Analyse multi-timeframes")
    print("✅ Exécution automatique simulée")
    print("✅ Surveillance des positions")
    print("✅ Recommandations basées sur l'IA")
    
    print(f"\n💡 Le Module 4 de SLM TRADE est maintenant opérationnel!")
    print("Prêt pour l'intégration avec les autres modules du système.")

# Module 5

"""
SLM TRADE - Module 5: Gestion Avancée des Risques
==================================================

Ce module implémente un système complet de gestion des risques avec:
- Value at Risk (VaR) et Expected Shortfall (ES)
- Position sizing dynamique avec Kelly Criterion
- Gestion de portefeuille multi-actifs
- Corrélations et diversification
- Stress testing et Monte Carlo
- Alertes de risque en temps réel
- Dashboard de visualisation des risques

Auteur: SLM TRADE System
Version: 5.0
"""

import numpy as np
import pandas as pd
import yfinance as yf
from scipy import stats
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class SLMRiskManager:
    """Gestionnaire de risques avancé pour SLM TRADE"""
    
    def __init__(self):
        """Initialisation du gestionnaire de risques"""
        
        # Paramètres de risque
        self.max_portfolio_var = 0.02  # VaR max 2% du capital
        self.max_position_weight = 0.20  # 20% max par position
        self.confidence_levels = [0.90, 0.95, 0.99]
        self.lookback_days = 252  # 1 an pour calculs historiques
        
        # Capital et portfolio
        self.total_capital = 100000
        self.available_capital = 100000
        self.portfolio_positions = {}
        self.portfolio_weights = {}
        
        # Cache des données
        self.price_data = {}
        self.returns_data = {}
        self.correlation_matrix = None
        self.last_update = None
        
        print("🛡️ SLM Risk Manager initialisé avec succès!")
    
    def set_capital(self, capital):
        """Définir le capital total"""
        self.total_capital = capital
        self.available_capital = capital
        print(f"💰 Capital défini: ${capital:,.2f}")
    
    def fetch_risk_data(self, symbols, period="1y"):
        """Récupération des données pour analyse de risque"""
        
        print(f"📊 Récupération données risque pour {len(symbols)} actifs...")
        
        try:
            for symbol in symbols:
                # Télécharger les données
                ticker = yf.Ticker(symbol)
                data = ticker.history(period=period)
                
                if len(data) > 20:
                    self.price_data[symbol] = data['Close']
                    # Calcul des rendements
                    returns = data['Close'].pct_change().dropna()
                    self.returns_data[symbol] = returns
            
            # Calculer matrice de corrélation
            if len(self.returns_data) > 1:
                returns_df = pd.DataFrame(self.returns_data)
                self.correlation_matrix = returns_df.corr()
            
            self.last_update = datetime.now()
            print(f"✅ Données mises à jour: {len(self.price_data)} actifs")
            
        except Exception as e:
            print(f"❌ Erreur récupération données: {e}")
    
    def calculate_var(self, returns, confidence_level=0.95, method='historical'):
        """Calcul du Value at Risk (VaR)"""
        
        if len(returns) < 30:
            return 0
        
        if method == 'historical':
            # VaR historique
            var = np.percentile(returns, (1 - confidence_level) * 100)
        
        elif method == 'parametric':
            # VaR paramétrique (distribution normale)
            mean_return = returns.mean()
            std_return = returns.std()
            z_score = stats.norm.ppf(1 - confidence_level)
            var = mean_return + z_score * std_return
        
        elif method == 'monte_carlo':
            # VaR Monte Carlo
            simulated_returns = np.random.normal(
                returns.mean(), returns.std(), 10000
            )
            var = np.percentile(simulated_returns, (1 - confidence_level) * 100)
        
        return abs(var)
    
    def calculate_expected_shortfall(self, returns, confidence_level=0.95):
        """Calcul de l'Expected Shortfall (ES)"""
        
        var = self.calculate_var(returns, confidence_level)
        # ES = moyenne des pertes au-delà du VaR
        tail_losses = returns[returns <= -var]
        
        if len(tail_losses) > 0:
            es = abs(tail_losses.mean())
        else:
            es = var
        
        return es
    
    def calculate_position_size_kelly(self, symbol, win_prob, avg_win, avg_loss):
        """Position sizing avec Kelly Criterion"""
        
        if avg_loss == 0 or win_prob <= 0:
            return 0
        
        # Formule Kelly: f = (bp - q) / b
        # b = avg_win/avg_loss, p = win_prob, q = 1-win_prob
        b = avg_win / abs(avg_loss)
        p = win_prob
        q = 1 - win_prob
        
        kelly_fraction = (b * p - q) / b
        
        # Limitation à 25% pour sécurité
        kelly_fraction = max(0, min(kelly_fraction, 0.25))
        
        # Calcul taille position
        position_value = self.available_capital * kelly_fraction
        
        return {
            'kelly_fraction': kelly_fraction,
            'position_value': position_value,
            'recommended_allocation': kelly_fraction * 100
        }
    
    def calculate_optimal_position_size(self, symbol, target_volatility=0.15):
        """Calcul taille position optimale basée sur volatilité cible"""
        
        if symbol not in self.returns_data:
            return {'position_value': 0, 'shares': 0, 'weight': 0}
        
        returns = self.returns_data[symbol]
        asset_volatility = returns.std() * np.sqrt(252)  # Volatilité annualisée
        
        if asset_volatility == 0:
            return {'position_value': 0, 'shares': 0, 'weight': 0}
        
        # Position sizing basé sur volatilité
        position_weight = target_volatility / asset_volatility
        position_weight = min(position_weight, self.max_position_weight)
        
        position_value = self.available_capital * position_weight
        
        # Calcul nombre d'actions
        if symbol in self.price_data:
            current_price = self.price_data[symbol].iloc[-1]
            shares = int(position_value / current_price)
        else:
            shares = 0
        
        return {
            'position_value': position_value,
            'shares': shares,
            'weight': position_weight,
            'asset_volatility': asset_volatility
        }
    
    def analyze_portfolio_risk(self):
        """Analyse complète du risque portefeuille"""
        
        if not self.portfolio_positions:
            return {"error": "Aucune position dans le portefeuille"}
        
        # Calculs de base
        portfolio_value = sum(self.portfolio_positions.values())
        weights = np.array([pos/portfolio_value for pos in self.portfolio_positions.values()])
        symbols = list(self.portfolio_positions.keys())
        
        # VaR individuel de chaque position
        individual_vars = {}
        for symbol in symbols:
            if symbol in self.returns_data:
                returns = self.returns_data[symbol]
                var_95 = self.calculate_var(returns, 0.95)
                position_var = self.portfolio_positions[symbol] * var_95
                individual_vars[symbol] = position_var
        
        # VaR portefeuille (en tenant compte des corrélations)
        portfolio_var = self.calculate_portfolio_var(symbols, weights)
        
        # Expected Shortfall portefeuille
        portfolio_es = portfolio_var * 1.3  # Approximation ES ≈ 1.3 * VaR
        
        # Bénéfice de diversification
        sum_individual_vars = sum(individual_vars.values())
        diversification_benefit = (sum_individual_vars - portfolio_var) / sum_individual_vars if sum_individual_vars > 0 else 0
        
        # Concentration du portefeuille (indice Herfindahl)
        herfindahl_index = sum(w**2 for w in weights)
        effective_positions = 1 / herfindahl_index if herfindahl_index > 0 else 0
        
        return {
            'portfolio_value': portfolio_value,
            'portfolio_var_95': portfolio_var,
            'portfolio_es_95': portfolio_es,
            'var_percentage': (portfolio_var / portfolio_value) * 100,
            'individual_vars': individual_vars,
            'diversification_benefit': diversification_benefit * 100,
            'concentration_index': herfindahl_index,
            'effective_positions': effective_positions,
            'largest_position_weight': max(weights) * 100
        }
    
    def calculate_portfolio_var(self, symbols, weights):
        """Calcul VaR portefeuille avec corrélations"""
        
        if len(symbols) < 2 or self.correlation_matrix is None:
            return 0
        
        # Matrice de covariance des rendements
        returns_matrix = pd.DataFrame({symbol: self.returns_data[symbol] 
                                     for symbol in symbols if symbol in self.returns_data})
        
        if returns_matrix.empty:
            return 0
        
        cov_matrix = returns_matrix.cov() * 252  # Annualisée
        
        # VaR portefeuille = sqrt(w' * Σ * w) * z_score
        portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights))
        portfolio_volatility = np.sqrt(portfolio_variance)
        
        # Z-score pour 95% de confiance
        z_score = stats.norm.ppf(0.95)
        portfolio_var = portfolio_volatility * z_score
        
        return portfolio_var * sum(self.portfolio_positions.values())
    
    def stress_test_portfolio(self, scenarios=None):
        """Tests de stress sur le portefeuille"""
        
        if not scenarios:
            scenarios = {
                'Crash 2008': {'market_drop': -0.37, 'vol_increase': 2.5},
                'COVID Mars 2020': {'market_drop': -0.34, 'vol_increase': 3.0},
                'Dot-com 2000': {'market_drop': -0.49, 'vol_increase': 2.0},
                'Crise personnalisée': {'market_drop': -0.25, 'vol_increase': 2.0}
            }
        
        stress_results = {}
        current_portfolio_value = sum(self.portfolio_positions.values())
        
        for scenario_name, params in scenarios.items():
            scenario_loss = 0
            
            for symbol, position_value in self.portfolio_positions.items():
                if symbol in self.returns_data:
                    # Simuler l'impact du scénario
                    base_loss = position_value * abs(params['market_drop'])
                    
                    # Ajuster selon la volatilité de l'actif
                    returns = self.returns_data[symbol]
                    asset_vol = returns.std() * np.sqrt(252)
                    vol_adjustment = asset_vol * params['vol_increase']
                    
                    total_loss = base_loss * (1 + vol_adjustment)
                    scenario_loss += total_loss
            
            loss_percentage = (scenario_loss / current_portfolio_value) * 100
            
            stress_results[scenario_name] = {
                'loss_amount': scenario_loss,
                'loss_percentage': loss_percentage,
                'remaining_capital': max(0, current_portfolio_value - scenario_loss)
            }
        
        return stress_results
    
    def generate_risk_alerts(self):
        """Génération d'alertes de risque"""
        
        alerts = []
        
        if not self.portfolio_positions:
            return alerts
        
        # Analyse du portefeuille
        risk_analysis = self.analyze_portfolio_risk()
        
        # Alerte VaR dépassé
        if risk_analysis['var_percentage'] > 2.0:
            alerts.append({
                'type': 'HIGH_VAR',
                'severity': 'HIGH',
                'message': f"VaR portefeuille élevé: {risk_analysis['var_percentage']:.1f}% (>2%)",
                'action': 'Réduire les positions à risque'
            })
        
        # Alerte concentration
        if risk_analysis['largest_position_weight'] > 25:
            alerts.append({
                'type': 'CONCENTRATION',
                'severity': 'MEDIUM',
                'message': f"Position trop concentrée: {risk_analysis['largest_position_weight']:.1f}% (>25%)",
                'action': 'Diversifier le portefeuille'
            })
        
        # Alerte faible diversification
        if risk_analysis['effective_positions'] < 3:
            alerts.append({
                'type': 'LOW_DIVERSIFICATION',
                'severity': 'MEDIUM',
                'message': f"Faible diversification: {risk_analysis['effective_positions']:.1f} positions effectives",
                'action': 'Ajouter des actifs non corrélés'
            })
        
        # Tests de stress
        stress_results = self.stress_test_portfolio()
        for scenario, result in stress_results.items():
            if result['loss_percentage'] > 30:
                alerts.append({
                    'type': 'STRESS_TEST',
                    'severity': 'HIGH',
                    'message': f"Scénario {scenario}: perte potentielle {result['loss_percentage']:.1f}%",
                    'action': 'Renforcer la couverture'
                })
        
        return alerts
    
    def update_portfolio(self, positions):
        """Mise à jour du portefeuille"""
        
        self.portfolio_positions = positions.copy()
        total_value = sum(positions.values())
        self.portfolio_weights = {symbol: value/total_value 
                                for symbol, value in positions.items()}
        
        print(f"📊 Portefeuille mis à jour: {len(positions)} positions, valeur ${total_value:,.2f}")
    
    def optimize_portfolio_allocation(self, expected_returns=None, max_risk=0.15):
        """Optimisation allocation portefeuille (Markowitz)"""
        
        if len(self.returns_data) < 2:
            return {"error": "Données insuffisantes pour optimisation"}
        
        symbols = list(self.returns_data.keys())
        returns_matrix = pd.DataFrame({symbol: self.returns_data[symbol] 
                                     for symbol in symbols})
        
        # Rendements moyens annualisés
        if expected_returns is None:
            expected_returns = returns_matrix.mean() * 252
        
        # Matrice de covariance annualisée
        cov_matrix = returns_matrix.cov() * 252
        
        n_assets = len(symbols)
        
        # Fonction objectif: minimiser la variance
        def objective(weights):
            return np.dot(weights, np.dot(cov_matrix, weights))
        
        # Contraintes
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # Somme = 1
        ]
        
        # Bornes (0% à 30% par actif)
        bounds = [(0, 0.3) for _ in range(n_assets)]
        
        # Poids initiaux égaux
        initial_weights = np.array([1/n_assets] * n_assets)
        
        # Optimisation
        try:
            result = minimize(
                objective, 
                initial_weights,
                method='SLSQP',
                bounds=bounds,
                constraints=constraints
            )
            
            if result.success:
                optimal_weights = result.x
                optimal_risk = np.sqrt(objective(optimal_weights))
                optimal_return = np.dot(optimal_weights, expected_returns)
                
                # Allocation en dollars
                allocations = {}
                for i, symbol in enumerate(symbols):
                    allocation_value = self.available_capital * optimal_weights[i]
                    if allocation_value > 100:  # Minimum $100
                        allocations[symbol] = {
                            'weight': optimal_weights[i],
                            'value': allocation_value,
                            'percentage': optimal_weights[i] * 100
                        }
                
                return {
                    'optimal_weights': dict(zip(symbols, optimal_weights)),
                    'expected_return': optimal_return,
                    'expected_risk': optimal_risk,
                    'sharpe_ratio': optimal_return / optimal_risk if optimal_risk > 0 else 0,
                    'allocations': allocations
                }
            else:
                return {"error": "Optimisation échouée"}
                
        except Exception as e:
            return {"error": f"Erreur optimisation: {e}"}

    def create_risk_dashboard(self):
        """Création dashboard de visualisation des risques"""
        
        if not self.portfolio_positions:
            print("❌ Aucune position pour créer le dashboard")
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        fig.suptitle('🛡️ SLM TRADE - Dashboard de Gestion des Risques', fontsize=16, fontweight='bold')
        
        # 1. Répartition du portefeuille
        ax1 = axes[0, 0]
        symbols = list(self.portfolio_positions.keys())
        values = list(self.portfolio_positions.values())
        colors = plt.cm.Set3(np.linspace(0, 1, len(symbols)))
        
        wedges, texts, autotexts = ax1.pie(values, labels=symbols, autopct='%1.1f%%', 
                                          colors=colors, startangle=90)
        ax1.set_title('Répartition du Portefeuille')
        
        # 2. VaR par position
        ax2 = axes[0, 1]
        individual_vars = []
        for symbol in symbols:
            if symbol in self.returns_data:
                returns = self.returns_data[symbol]
                var = self.calculate_var(returns, 0.95)
                position_var = self.portfolio_positions[symbol] * var
                individual_vars.append(position_var)
            else:
                individual_vars.append(0)
        
        bars = ax2.bar(symbols, individual_vars, color=colors)
        ax2.set_title('VaR 95% par Position')
        ax2.set_ylabel('VaR ($)')
        ax2.tick_params(axis='x', rotation=45)
        
        # 3. Matrice de corrélation
        ax3 = axes[1, 0]
        if self.correlation_matrix is not None and len(self.correlation_matrix) > 1:
            sns.heatmap(self.correlation_matrix, annot=True, cmap='RdYlBu_r', 
                       center=0, ax=ax3, square=True)
            ax3.set_title('Matrice de Corrélation')
        else:
            ax3.text(0.5, 0.5, 'Données insuffisantes\npour corrélation', 
                    ha='center', va='center', transform=ax3.transAxes)
            ax3.set_title('Matrice de Corrélation')
        
        # 4. Analyse de risque
        ax4 = axes[1, 1]
        risk_analysis = self.analyze_portfolio_risk()
        
        risk_metrics = [
            f"VaR Portfolio: ${risk_analysis.get('portfolio_var_95', 0):,.0f}",
            f"VaR %: {risk_analysis.get('var_percentage', 0):.1f}%",
            f"Diversification: {risk_analysis.get('diversification_benefit', 0):.1f}%",
            f"Positions effectives: {risk_analysis.get('effective_positions', 0):.1f}",
            f"Plus grosse position: {risk_analysis.get('largest_position_weight', 0):.1f}%"
        ]
        
        ax4.text(0.1, 0.8, '\n'.join(risk_metrics), transform=ax4.transAxes, 
                fontsize=12, verticalalignment='top')
        ax4.set_title('Métriques de Risque')
        ax4.axis('off')
        
        plt.tight_layout()
        plt.show()
    
    def generate_risk_report(self):
        """Génération rapport complet de risque"""
        
        report = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'portfolio_summary': {
                'total_value': sum(self.portfolio_positions.values()),
                'number_of_positions': len(self.portfolio_positions),
                'available_capital': self.available_capital
            }
        }
        
        # Analyse de risque
        if self.portfolio_positions:
            risk_analysis = self.analyze_portfolio_risk()
            report['risk_analysis'] = risk_analysis
            
            # Tests de stress
            stress_results = self.stress_test_portfolio()
            report['stress_tests'] = stress_results
            
            # Alertes
            alerts = self.generate_risk_alerts()
            report['alerts'] = alerts
            
            # Optimisation recommandée
            optimization = self.optimize_portfolio_allocation()
            report['optimization_recommendation'] = optimization
        
        return report


def demo_risk_management():
    """Démonstration du module de gestion des risques"""
    
    print("🚀 DÉMONSTRATION SLM TRADE - MODULE 5: GESTION DES RISQUES")
    print("=" * 60)
    
    # Initialisation
    risk_manager = SLMRiskManager()
    risk_manager.set_capital(100000)
    
    # Portfolio d'exemple
    test_symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'NVDA']
    print(f"\n📊 Test avec portfolio: {test_symbols}")
    
    # Récupération des données
    risk_manager.fetch_risk_data(test_symbols)
    
    # Portfolio positions d'exemple
    portfolio_positions = {
        'AAPL': 25000,
        'GOOGL': 20000,
        'MSFT': 18000,
        'TSLA': 15000,
        'NVDA': 12000
    }
    
    risk_manager.update_portfolio(portfolio_positions)
    
    # 1. Analyse de risque portefeuille
    print("\n🛡️ ANALYSE DE RISQUE PORTEFEUILLE")
    print("-" * 40)
    risk_analysis = risk_manager.analyze_portfolio_risk()
    
    print(f"Valeur portefeuille: ${risk_analysis['portfolio_value']:,.2f}")
    print(f"VaR 95% (1 jour): ${risk_analysis['portfolio_var_95']:,.2f}")
    print(f"VaR en %: {risk_analysis['var_percentage']:.2f}%")
    print(f"Bénéfice diversification: {risk_analysis['diversification_benefit']:.1f}%")
    print(f"Positions effectives: {risk_analysis['effective_positions']:.1f}")
    
    # 2. Position sizing optimal
    print("\n💰 POSITION SIZING OPTIMAL")
    print("-" * 40)
    for symbol in ['AAPL', 'TSLA']:
        pos_size = risk_manager.calculate_optimal_position_size(symbol)
        print(f"{symbol}:")
        print(f"  Taille recommandée: ${pos_size['position_value']:,.0f}")
        print(f"  Nombre d'actions: {pos_size['shares']}")
        print(f"  Poids portfolio: {pos_size['weight']*100:.1f}%")
        print(f"  Volatilité: {pos_size.get('asset_volatility', 0)*100:.1f}%")
    
    # 3. Tests de stress
    print("\n⚠️ TESTS DE STRESS")
    print("-" * 40)
    stress_results = risk_manager.stress_test_portfolio()
    
    for scenario, result in stress_results.items():
        print(f"{scenario}:")
        print(f"  Perte: ${result['loss_amount']:,.0f} ({result['loss_percentage']:.1f}%)")
        print(f"  Capital restant: ${result['remaining_capital']:,.0f}")
    
    # 4. Alertes de risque
    print("\n🚨 ALERTES DE RISQUE")
    print("-" * 40)
    alerts = risk_manager.generate_risk_alerts()
    
    if alerts:
        for alert in alerts:
            severity_icon = "🔴" if alert['severity'] == 'HIGH' else "🟡"
            print(f"{severity_icon} {alert['message']}")
            print(f"   Action: {alert['action']}")
    else:
        print("✅ Aucune alerte de risque détectée")
    
    # 5. Optimisation portefeuille
    print("\n🎯 OPTIMISATION PORTEFEUILLE")
    print("-" * 40)
    optimization = risk_manager.optimize_portfolio_allocation()
    
    if 'error' not in optimization:
        print(f"Rendement attendu: {optimization['expected_return']*100:.2f}%")
        print(f"Risque attendu: {optimization['expected_risk']*100:.2f}%")
        print(f"Ratio de Sharpe: {optimization['sharpe_ratio']:.2f}")
        
        print("\nAllocation optimale recommandée:")
        for symbol, alloc in optimization['allocations'].items():
            print(f"  {symbol}: {alloc['percentage']:.1f}% (${alloc['value']:,.0f})")
    
    # 6. Dashboard visuel
    print("\n📊 Génération du dashboard de risque...")
    try:
        risk_manager.create_risk_dashboard()
    except:
        print("Dashboard non disponible dans cet environnement")
    
    # 7. Rapport complet
    print("\n📋 GÉNÉRATION RAPPORT COMPLET")
    print("-" * 40)
    report = risk_manager.generate_risk_report()
    print(f"Rapport généré le: {report['timestamp']}")
    print(f"Nombre d'alertes: {len(report.get('alerts', []))}")
    
    print("\n🎉 Démonstration terminée!")
    return risk_manager

# Lancement de la démonstration
if __name__ == "__main__":
    demo_risk_manager = demo_risk_management()

# Module 6 

"""
SLM TRADE - Module 6: Base de Données & Système Complet Final
===========================================================

Ce module final intègre tous les modules précédents avec:
- Base de données SQLite optimisée pour trading
- Cache intelligent Redis-like en mémoire
- Synchronisation multi-sources en temps réel
- API unifiée pour toutes les fonctionnalités
- Interface web complète
- Système de notifications avancé
"""

import sqlite3
import pandas as pd
import numpy as np
import json
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import yfinance as yf
from dataclasses import dataclass, asdict
import hashlib
import pickle
import logging
from concurrent.futures import ThreadPoolExecutor
import asyncio
from flask import Flask, jsonify, request, render_template_string
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class TradeSignal:
    """Structure pour les signaux de trading"""
    symbol: str
    timestamp: datetime
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    price: float
    confidence: float
    strategy: str
    timeframe: str
    indicators: Dict[str, float]
    risk_metrics: Dict[str, float]

@dataclass
class Portfolio:
    """Structure pour le portefeuille"""
    cash: float
    positions: Dict[str, Dict[str, float]]  # {symbol: {shares: x, avg_price: y}}
    total_value: float
    daily_pnl: float
    unrealized_pnl: float
    realized_pnl: float

class SLMCache:
    """Système de cache intelligent pour les données de trading"""
    
    def __init__(self, max_size: int = 10000, ttl: int = 300):
        self.cache = {}
        self.timestamps = {}
        self.max_size = max_size
        self.ttl = ttl  # Time to live en secondes
        self.access_count = {}
        self._lock = threading.RLock()
    
    def _generate_key(self, *args, **kwargs) -> str:
        """Génère une clé unique pour le cache"""
        key_data = str(args) + str(sorted(kwargs.items()))
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def get(self, key: str) -> Optional[Any]:
        """Récupère une valeur du cache"""
        with self._lock:
            if key in self.cache:
                # Vérifier l'expiration
                if time.time() - self.timestamps[key] > self.ttl:
                    self._remove(key)
                    return None
                
                self.access_count[key] = self.access_count.get(key, 0) + 1
                return self.cache[key]
            return None
    
    def set(self, key: str, value: Any) -> None:
        """Stocke une valeur dans le cache"""
        with self._lock:
            # Nettoyage si nécessaire
            if len(self.cache) >= self.max_size:
                self._cleanup()
            
            self.cache[key] = value
            self.timestamps[key] = time.time()
            self.access_count[key] = 1
    
    def _remove(self, key: str) -> None:
        """Supprime une entrée du cache"""
        self.cache.pop(key, None)
        self.timestamps.pop(key, None)
        self.access_count.pop(key, None)
    
    def _cleanup(self) -> None:
        """Nettoie le cache en supprimant les entrées les moins utilisées"""
        # Supprimer les entrées expirées
        current_time = time.time()
        expired_keys = [
            key for key, timestamp in self.timestamps.items()
            if current_time - timestamp > self.ttl
        ]
        for key in expired_keys:
            self._remove(key)
        
        # Si encore trop d'entrées, supprimer les moins utilisées
        if len(self.cache) >= self.max_size:
            sorted_keys = sorted(self.access_count.items(), key=lambda x: x[1])
            keys_to_remove = [key for key, _ in sorted_keys[:len(sorted_keys)//4]]
            for key in keys_to_remove:
                self._remove(key)
    
    def clear(self) -> None:
        """Vide complètement le cache"""
        with self._lock:
            self.cache.clear()
            self.timestamps.clear()
            self.access_count.clear()
    
    def stats(self) -> Dict[str, Any]:
        """Retourne les statistiques du cache"""
        with self._lock:
            return {
                'size': len(self.cache),
                'max_size': self.max_size,
                'hit_rate': sum(self.access_count.values()) / max(len(self.cache), 1),
                'ttl': self.ttl
            }

class SLMDatabase:
    """Gestionnaire de base de données optimisé pour le trading"""
    
    def __init__(self, db_path: str = "slm_trade.db"):
        self.db_path = db_path
        self.cache = SLMCache()
        self._init_database()
    
    def _init_database(self) -> None:
        """Initialise la structure de la base de données"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Table pour les données OHLCV
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS market_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    timeframe TEXT NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    volume INTEGER NOT NULL,
                    adj_close REAL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, timestamp, timeframe)
                )
            """)
            
            # Table pour les signaux de trading
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS trading_signals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    signal_type TEXT NOT NULL,
                    price REAL NOT NULL,
                    confidence REAL NOT NULL,
                    strategy TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    indicators TEXT,  -- JSON
                    risk_metrics TEXT,  -- JSON
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour les trades exécutés
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS executed_trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    trade_type TEXT NOT NULL,  -- 'BUY' or 'SELL'
                    quantity REAL NOT NULL,
                    price REAL NOT NULL,
                    timestamp DATETIME NOT NULL,
                    commission REAL DEFAULT 0,
                    strategy TEXT,
                    pnl REAL DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour le portefeuille
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS portfolio_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp DATETIME NOT NULL,
                    cash REAL NOT NULL,
                    total_value REAL NOT NULL,
                    daily_pnl REAL NOT NULL,
                    unrealized_pnl REAL NOT NULL,
                    realized_pnl REAL NOT NULL,
                    positions TEXT,  -- JSON
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour les métriques de performance
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE NOT NULL,
                    symbol TEXT,
                    strategy TEXT,
                    total_return REAL,
                    sharpe_ratio REAL,
                    max_drawdown REAL,
                    win_rate REAL,
                    profit_factor REAL,
                    var_95 REAL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(date, symbol, strategy)
                )
            """)
            
            # Index pour optimiser les requêtes
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_market_data_symbol_time ON market_data(symbol, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_signals_symbol_time ON trading_signals(symbol, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol_time ON executed_trades(symbol, timestamp)")
            
            conn.commit()
            logger.info("Base de données initialisée avec succès")
    
    def store_market_data(self, symbol: str, data: pd.DataFrame, timeframe: str) -> None:
        """Stocke les données de marché"""
        with sqlite3.connect(self.db_path) as conn:
            try:
                records = []
                for timestamp, row in data.iterrows():
                    records.append((
                        symbol, timestamp, timeframe,
                        float(row['Open']), float(row['High']), 
                        float(row['Low']), float(row['Close']),
                        int(row['Volume']), 
                        float(row.get('Adj Close', row['Close']))
                    ))
                
                conn.executemany("""
                    INSERT OR REPLACE INTO market_data 
                    (symbol, timestamp, timeframe, open, high, low, close, volume, adj_close)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, records)
                
                conn.commit()
                logger.info(f"Stocké {len(records)} enregistrements pour {symbol} ({timeframe})")
                
            except Exception as e:
                logger.error(f"Erreur lors du stockage des données de marché: {e}")
    
    def get_market_data(self, symbol: str, timeframe: str, 
                       start_date: Optional[datetime] = None,
                       end_date: Optional[datetime] = None) -> pd.DataFrame:
        """Récupère les données de marché avec cache"""
        cache_key = self.cache._generate_key(symbol, timeframe, start_date, end_date)
        cached_data = self.cache.get(cache_key)
        if cached_data is not None:
            return cached_data
        
        with sqlite3.connect(self.db_path) as conn:
            query = """
                SELECT timestamp, open, high, low, close, volume, adj_close
                FROM market_data
                WHERE symbol = ? AND timeframe = ?
            """
            params = [symbol, timeframe]
            
            if start_date:
                query += " AND timestamp >= ?"
                params.append(start_date)
            
            if end_date:
                query += " AND timestamp <= ?"
                params.append(end_date)
            
            query += " ORDER BY timestamp"
            
            df = pd.read_sql_query(query, conn, params=params, 
                                 parse_dates=['timestamp'], index_col='timestamp')
            
            if not df.empty:
                df.columns = ['Open', 'High', 'Low', 'Close', 'Volume', 'Adj Close']
                self.cache.set(cache_key, df)
            
            return df
    
    def store_signal(self, signal: TradeSignal) -> None:
        """Stocke un signal de trading"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO trading_signals 
                (symbol, timestamp, signal_type, price, confidence, strategy, timeframe, indicators, risk_metrics)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                signal.symbol, signal.timestamp, signal.signal_type,
                signal.price, signal.confidence, signal.strategy, signal.timeframe,
                json.dumps(signal.indicators), json.dumps(signal.risk_metrics)
            ))
            conn.commit()
    
    def store_trade(self, symbol: str, trade_type: str, quantity: float, 
                   price: float, timestamp: datetime, commission: float = 0,
                   strategy: str = None, pnl: float = 0) -> None:
        """Stocke un trade exécuté"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO executed_trades 
                (symbol, trade_type, quantity, price, timestamp, commission, strategy, pnl)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (symbol, trade_type, quantity, price, timestamp, commission, strategy, pnl))
            conn.commit()
    
    def store_portfolio_snapshot(self, portfolio: Portfolio, timestamp: datetime) -> None:
        """Stocke un snapshot du portefeuille"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO portfolio_history 
                (timestamp, cash, total_value, daily_pnl, unrealized_pnl, realized_pnl, positions)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                timestamp, portfolio.cash, portfolio.total_value,
                portfolio.daily_pnl, portfolio.unrealized_pnl, 
                portfolio.realized_pnl, json.dumps(portfolio.positions)
            ))
            conn.commit()
    
    def get_latest_signals(self, symbol: str = None, limit: int = 100) -> List[Dict]:
        """Récupère les derniers signaux"""
        with sqlite3.connect(self.db_path) as conn:
            query = """
                SELECT * FROM trading_signals
                WHERE 1=1
            """
            params = []
            
            if symbol:
                query += " AND symbol = ?"
                params.append(symbol)
            
            query += " ORDER BY timestamp DESC LIMIT ?"
            params.append(limit)
            
            cursor = conn.execute(query, params)
            columns = [description[0] for description in cursor.description]
            
            signals = []
            for row in cursor.fetchall():
                signal_dict = dict(zip(columns, row))
                # Parse JSON fields
                signal_dict['indicators'] = json.loads(signal_dict.get('indicators', '{}'))
                signal_dict['risk_metrics'] = json.loads(signal_dict.get('risk_metrics', '{}'))
                signals.append(signal_dict)
            
            return signals
    
    def get_performance_summary(self, days: int = 30) -> Dict[str, Any]:
        """Génère un résumé de performance"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        with sqlite3.connect(self.db_path) as conn:
            # Total des trades
            total_trades = conn.execute("""
                SELECT COUNT(*) FROM executed_trades 
                WHERE timestamp >= ?
            """, (start_date,)).fetchone()[0]
            
            # PnL total
            total_pnl = conn.execute("""
                SELECT COALESCE(SUM(pnl), 0) FROM executed_trades 
                WHERE timestamp >= ?
            """, (start_date,)).fetchone()[0]
            
            # Win rate
            winning_trades = conn.execute("""
                SELECT COUNT(*) FROM executed_trades 
                WHERE timestamp >= ? AND pnl > 0
            """, (start_date,)).fetchone()[0]
            
            win_rate = (winning_trades / max(total_trades, 1)) * 100
            
            # Portfolio evolution
            portfolio_data = pd.read_sql_query("""
                SELECT timestamp, total_value FROM portfolio_history 
                WHERE timestamp >= ? ORDER BY timestamp
            """, conn, params=(start_date,), parse_dates=['timestamp'])
            
            max_value = portfolio_data['total_value'].max() if not portfolio_data.empty else 0
            min_value = portfolio_data['total_value'].min() if not portfolio_data.empty else 0
            current_value = portfolio_data['total_value'].iloc[-1] if not portfolio_data.empty else 0
            
            return {
                'period_days': days,
                'total_trades': total_trades,
                'total_pnl': total_pnl,
                'win_rate': win_rate,
                'current_portfolio_value': current_value,
                'max_portfolio_value': max_value,
                'min_portfolio_value': min_value,
                'drawdown_pct': ((max_value - current_value) / max(max_value, 1)) * 100
            }

class SLMDataSyncManager:
    """Gestionnaire de synchronisation multi-sources"""
    
    def __init__(self, database: SLMDatabase):
        self.database = database
        self.active_symbols = set()
        self.sync_threads = {}
        self.running = False
        self.update_callbacks = []
    
    def add_symbol(self, symbol: str, timeframes: List[str] = ['1h', '1d']) -> None:
        """Ajoute un symbole à la synchronisation"""
        self.active_symbols.add(symbol)
        
        if self.running:
            self._start_sync_thread(symbol, timeframes)
        
        logger.info(f"Symbole {symbol} ajouté à la synchronisation")
    
    def remove_symbol(self, symbol: str) -> None:
        """Retire un symbole de la synchronisation"""
        if symbol in self.active_symbols:
            self.active_symbols.remove(symbol)
            
            if symbol in self.sync_threads:
                # Arrêter le thread de synchronisation
                self.sync_threads[symbol]['stop_event'].set()
                del self.sync_threads[symbol]
        
        logger.info(f"Symbole {symbol} retiré de la synchronisation")
    
    def start_sync(self) -> None:
        """Démarre la synchronisation en temps réel"""
        self.running = True
        
        for symbol in self.active_symbols:
            self._start_sync_thread(symbol, ['1h', '1d'])
        
        logger.info("Synchronisation en temps réel démarrée")
    
    def stop_sync(self) -> None:
        """Arrête la synchronisation"""
        self.running = False
        
        for symbol, thread_info in self.sync_threads.items():
            thread_info['stop_event'].set()
        
        self.sync_threads.clear()
        logger.info("Synchronisation arrêtée")
    
    def _start_sync_thread(self, symbol: str, timeframes: List[str]) -> None:
        """Démarre un thread de synchronisation pour un symbole"""
        if symbol in self.sync_threads:
            return
        
        stop_event = threading.Event()
        thread = threading.Thread(
            target=self._sync_worker,
            args=(symbol, timeframes, stop_event),
            daemon=True
        )
        
        self.sync_threads[symbol] = {
            'thread': thread,
            'stop_event': stop_event
        }
        
        thread.start()
    
    def _sync_worker(self, symbol: str, timeframes: List[str], stop_event: threading.Event) -> None:
        """Worker de synchronisation pour un symbole"""
        while not stop_event.is_set():
            try:
                ticker = yf.Ticker(symbol)
                
                for timeframe in timeframes:
                    # Récupérer les données récentes
                    data = ticker.history(period="5d", interval=timeframe)
                    
                    if not data.empty:
                        # Stocker en base
                        self.database.store_market_data(symbol, data, timeframe)
                        
                        # Notifier les callbacks
                        for callback in self.update_callbacks:
                            try:
                                callback(symbol, timeframe, data)
                            except Exception as e:
                                logger.error(f"Erreur dans callback: {e}")
                
                # Attendre avant la prochaine mise à jour
                stop_event.wait(60)  # 1 minute
                
            except Exception as e:
                logger.error(f"Erreur de synchronisation pour {symbol}: {e}")
                stop_event.wait(30)  # Attendre 30s avant de retry
    
    def add_update_callback(self, callback) -> None:
        """Ajoute un callback pour les mises à jour de données"""
        self.update_callbacks.append(callback)

class SLMTradeSystemComplete:
    """Système de trading complet SLM TRADE - Tous modules intégrés"""
    
    def __init__(self, initial_capital: float = 100000):
        # Initialisation des composants
        self.database = SLMDatabase()
        self.sync_manager = SLMDataSyncManager(self.database)
        
        # Portfolio
        self.portfolio = Portfolio(
            cash=initial_capital,
            positions={},
            total_value=initial_capital,
            daily_pnl=0,
            unrealized_pnl=0,
            realized_pnl=0
        )
        
        # Composants des modules précédents
        from datetime import datetime
        import yfinance as yf
        
        # Configuration
        self.commission_rate = 0.001  # 0.1%
        self.max_risk_per_trade = 0.02  # 2%
        self.active_strategies = ['rsi_mean_reversion', 'ma_crossover', 'bollinger_bounce']
        
        # Threads et état
        self.trading_active = False
        self.monitoring_thread = None
        
        logger.info("Système SLM TRADE initialisé avec succès")
    
    def add_symbol_to_watch(self, symbol: str) -> None:
        """Ajoute un symbole à la surveillance"""
        self.sync_manager.add_symbol(symbol)
        logger.info(f"Symbole {symbol} ajouté à la surveillance")
    
    def start_live_trading(self) -> None:
        """Démarre le trading en temps réel"""
        if self.trading_active:
            logger.warning("Le trading est déjà actif")
            return
        
        self.trading_active = True
        
        # Démarrer la synchronisation des données
        self.sync_manager.start_sync()
        
        # Démarrer le monitoring
        self.monitoring_thread = threading.Thread(target=self._trading_loop, daemon=True)
        self.monitoring_thread.start()
        
        logger.info("Trading en temps réel démarré")
    
    def stop_live_trading(self) -> None:
        """Arrête le trading en temps réel"""
        self.trading_active = False
        self.sync_manager.stop_sync()
        
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        
        logger.info("Trading en temps réel arrêté")
    
    def _trading_loop(self) -> None:
        """Boucle principale de trading"""
        while self.trading_active:
            try:
                # Analyser chaque symbole surveillé
                for symbol in self.sync_manager.active_symbols:
                    signals = self._generate_signals(symbol)
                    
                    for signal in signals:
                        if signal.confidence > 0.7:  # Seuil de confiance
                            self._process_signal(signal)
                
                # Mise à jour du portefeuille
                self._update_portfolio()
                
                # Sauvegarde périodique
                self.database.store_portfolio_snapshot(self.portfolio, datetime.now())
                
                time.sleep(30)  # Attendre 30 secondes
                
            except Exception as e:
                logger.error(f"Erreur dans la boucle de trading: {e}")
                time.sleep(60)
    
    def _generate_signals(self, symbol: str) -> List[TradeSignal]:
        """Génère des signaux de trading pour un symbole"""
        signals = []
        
        try:
            # Récupérer les données
            data_1h = self.database.get_market_data(symbol, '1h')
            data_1d = self.database.get_market_data(symbol, '1d')
            
            if data_1h.empty or data_1d.empty:
                return signals
            
            current_price = data_1h['Close'].iloc[-1]
            
            # Calculer les indicateurs
            indicators = self._calculate_indicators(data_1h)
            risk_metrics = self._calculate_risk_metrics(symbol, data_1d)
            
            # Stratégies de trading
            for strategy in self.active_strategies:
                signal_type, confidence = self._evaluate_strategy(strategy, indicators, data_1h)
                
                if signal_type != 'HOLD':
                    signal = TradeSignal(
                        symbol=symbol,
                        timestamp=datetime.now(),
                        signal_type=signal_type,
                        price=current_price,
                        confidence=confidence,
                        strategy=strategy,
                        timeframe='1h',
                        indicators=indicators,
                        risk_metrics=risk_metrics
                    )
                    signals.append(signal)
                    
                    # Stocker le signal
                    self.database.store_signal(signal)
        
        except Exception as e:
            logger.error(f"Erreur génération signaux pour {symbol}: {e}")
        
        return signals
    
    def _calculate_indicators(self, data: pd.DataFrame) -> Dict[str, float]:
        """Calcule les indicateurs techniques"""
        if len(data) < 50:
            return {}
        
        indicators = {}
        
        try:
            # RSI
            delta = data['Close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            indicators['rsi'] = (100 - (100 / (1 + rs))).iloc[-1]
            
            # Moyennes mobiles
            indicators['sma_20'] = data['Close'].rolling(20).mean().iloc[-1]
            indicators['sma_50'] = data['Close'].rolling(50).mean().iloc[-1]
            indicators['ema_12'] = data['Close'].ewm(span=12).mean().iloc[-1]
            indicators['ema_26'] = data['Close'].ewm(span=26).mean().iloc[-1]
            
            # MACD
            macd_line = indicators['ema_12'] - indicators['ema_26']
            signal_line = data['Close'].ewm(span=9).mean().iloc[-1]
            indicators['macd'] = macd_line
            indicators['macd_signal'] = signal_line
            
            # Bollinger Bands
            bb_period = 20
            bb_std = 2
            sma = data['Close'].rolling(bb_period).mean()
            std = data['Close'].rolling(bb_period).std()
            indicators['bb_upper'] = (sma + (std * bb_std)).iloc[-1]
            indicators['bb_lower'] = (sma - (std * bb_std)).iloc[-1]
            indicators['bb_middle'] = sma.iloc[-1]
            
            # Prix actuel
            indicators['current_price'] = data['Close'].iloc[-1]
            
        except Exception as e:
            logger.error(f"Erreur calcul indicateurs: {e}")
        
        return indicators
    
    def _calculate_risk_metrics(self, symbol: str, data: pd.DataFrame) -> Dict[str, float]:
        """Calcule les métriques de risque"""
        if len(data) < 30:
            return {}
        
        metrics = {}
        
        try:
            returns = data['Close'].pct_change().dropna()
            
            # Volatilité
            metrics['volatility'] = returns.std() * np.sqrt(252)
            
            # VaR 95%
            metrics['var_95'] = np.percentile(returns, 5)
            
            # Maximum Drawdown
            cumulative = (1 + returns).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            metrics['max_drawdown'] = drawdown.min()
            
            # Beta (vs SPY approximation)
            metrics['beta'] = 1.0  # Approximation
            
        except Exception as e:
            logger.error(f"Erreur calcul métriques risque: {e}")
        
        return metrics
    
    def _evaluate_strategy(self, strategy: str, indicators: Dict[str, float], data: pd.DataFrame) -> Tuple[str, float]:
        """Évalue une stratégie de trading"""
        if not indicators:
            return 'HOLD', 0.0
        
        try:
            if strategy == 'rsi_mean_reversion':
                rsi = indicators.get('rsi', 50)
                if rsi < 30:
                    return 'BUY', min(0.8, (30 - rsi) / 20)
                elif rsi > 70:
                    return 'SELL', min(0.8, (rsi - 70) / 20)
            
            elif strategy == 'ma_crossover':
                sma_20 = indicators.get('sma_20', 0)
                sma_50 = indicators.get('sma_50', 0)
                current_price = indicators.get('current_price', 0)
                
                if sma_20 > sma_50 and current_price > sma_20:
                    return 'BUY', 0.6
                elif sma_20 < sma_50 and current_price < sma_20:
                    return 'SELL', 0.6
            
            elif strategy == 'bollinger_bounce':
                current_price = indicators.get('current_price', 0)
                bb_upper = indicators.get('bb_upper', 0)
                bb_lower = indicators.get('bb_lower', 0)
                bb_middle = indicators.get('bb_middle', 0)
                
                if current_price <= bb_lower:
                    return 'BUY', 0.7
                elif current_price >= bb_upper:
                    return 'SELL', 0.7
        
        except Exception as e:
            logger.error(f"Erreur évaluation stratégie {strategy}: {e}")
        
        return 'HOLD', 0.0
    
    def _process_signal(self, signal: TradeSignal) -> None:
        """Traite un signal de trading et exécute si nécessaire"""
        try:
            # Vérifier si on a déjà une position
            current_position = self.portfolio.positions.get(signal.symbol, {'shares': 0, 'avg_price': 0})
            
            # Calculer la taille de position
            risk_amount = self.portfolio.total_value * self.max_risk_per_trade
            volatility = signal.risk_metrics.get('volatility', 0.2)
            
            # Position sizing basé sur la volatilité
            position_size = min(
                int(risk_amount / (signal.price * volatility)),
                int(self.portfolio.cash / signal.price * 0.25)  # Max 25% du cash
            )
            
            if signal.signal_type == 'BUY' and current_position['shares'] <= 0 and position_size > 0:
                self._execute_buy(signal.symbol, position_size, signal.price, signal.strategy)
                
            elif signal.signal_type == 'SELL' and current_position['shares'] > 0:
                self._execute_sell(signal.symbol, current_position['shares'], signal.price, signal.strategy)
                
        except Exception as e:
            logger.error(f"Erreur traitement signal: {e}")
    
    def _execute_buy(self, symbol: str, quantity: int, price: float, strategy: str) -> None:
        """Exécute un ordre d'achat"""
        try:
            total_cost = quantity * price
            commission = total_cost * self.commission_rate
            total_with_commission = total_cost + commission
            
            if self.portfolio.cash >= total_with_commission:
                # Mise à jour du portefeuille
                self.portfolio.cash -= total_with_commission
                
                if symbol in self.portfolio.positions:
                    # Position existante - moyenne pondérée
                    old_shares = self.portfolio.positions[symbol]['shares']
                    old_price = self.portfolio.positions[symbol]['avg_price']
                    
                    new_shares = old_shares + quantity
                    new_avg_price = ((old_shares * old_price) + total_cost) / new_shares
                    
                    self.portfolio.positions[symbol] = {
                        'shares': new_shares,
                        'avg_price': new_avg_price
                    }
                else:
                    # Nouvelle position
                    self.portfolio.positions[symbol] = {
                        'shares': quantity,
                        'avg_price': price
                    }
                
                # Enregistrer le trade
                self.database.store_trade(
                    symbol=symbol,
                    trade_type='BUY',
                    quantity=quantity,
                    price=price,
                    timestamp=datetime.now(),
                    commission=commission,
                    strategy=strategy
                )
                
                logger.info(f"ACHAT exécuté: {quantity} {symbol} @ {price:.2f}")
            
        except Exception as e:
            logger.error(f"Erreur exécution achat: {e}")
    
    def _execute_sell(self, symbol: str, quantity: int, price: float, strategy: str) -> None:
        """Exécute un ordre de vente"""
        try:
            if symbol in self.portfolio.positions and self.portfolio.positions[symbol]['shares'] >= quantity:
                total_proceeds = quantity * price
                commission = total_proceeds * self.commission_rate
                net_proceeds = total_proceeds - commission
                
                # Calculer le PnL
                avg_price = self.portfolio.positions[symbol]['avg_price']
                pnl = (price - avg_price) * quantity - commission
                
                # Mise à jour du portefeuille
                self.portfolio.cash += net_proceeds
                self.portfolio.realized_pnl += pnl
                
                # Mise à jour de la position
                remaining_shares = self.portfolio.positions[symbol]['shares'] - quantity
                if remaining_shares > 0:
                    self.portfolio.positions[symbol]['shares'] = remaining_shares
                else:
                    del self.portfolio.positions[symbol]
                
                # Enregistrer le trade
                self.database.store_trade(
                    symbol=symbol,
                    trade_type='SELL',
                    quantity=quantity,
                    price=price,
                    timestamp=datetime.now(),
                    commission=commission,
                    strategy=strategy,
                    pnl=pnl
                )
                
                logger.info(f"VENTE exécutée: {quantity} {symbol} @ {price:.2f} | PnL: {pnl:.2f}")
            
        except Exception as e:
            logger.error(f"Erreur exécution vente: {e}")
    
    def _update_portfolio(self) -> None:
        """Met à jour la valeur du portefeuille"""
        try:
            total_value = self.portfolio.cash
            unrealized_pnl = 0
            
            for symbol, position in self.portfolio.positions.items():
                try:
                    # Récupérer le prix actuel
                    recent_data = self.database.get_market_data(symbol, '1h')
                    if not recent_data.empty:
                        current_price = recent_data['Close'].iloc[-1]
                        position_value = position['shares'] * current_price
                        total_value += position_value
                        
                        # PnL non réalisé
                        position_pnl = (current_price - position['avg_price']) * position['shares']
                        unrealized_pnl += position_pnl
                        
                except Exception as e:
                    logger.warning(f"Erreur mise à jour prix {symbol}: {e}")
            
            # Calculer le PnL journalier
            previous_value = self.portfolio.total_value
            daily_pnl = total_value - previous_value
            
            # Mise à jour
            self.portfolio.total_value = total_value
            self.portfolio.unrealized_pnl = unrealized_pnl
            self.portfolio.daily_pnl = daily_pnl
            
        except Exception as e:
            logger.error(f"Erreur mise à jour portefeuille: {e}")
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """Génère les données pour le dashboard"""
        try:
            # Performance summary
            performance = self.database.get_performance_summary(30)
            
            # Signaux récents
            recent_signals = self.database.get_latest_signals(limit=20)
            
            # Portfolio current state
            portfolio_data = {
                'cash': self.portfolio.cash,
                'total_value': self.portfolio.total_value,
                'daily_pnl': self.portfolio.daily_pnl,
                'unrealized_pnl': self.portfolio.unrealized_pnl,
                'realized_pnl': self.portfolio.realized_pnl,
                'positions': self.portfolio.positions,
                'position_count': len(self.portfolio.positions)
            }
            
            # Cache stats
            cache_stats = self.database.cache.stats()
            
            return {
                'timestamp': datetime.now().isoformat(),
                'performance': performance,
                'portfolio': portfolio_data,
                'recent_signals': recent_signals,
                'cache_stats': cache_stats,
                'active_symbols': list(self.sync_manager.active_symbols),
                'trading_active': self.trading_active
            }
            
        except Exception as e:
            logger.error(f"Erreur génération dashboard: {e}")
            return {}
    
    def create_performance_chart(self, days: int = 30) -> str:
        """Crée un graphique de performance"""
        try:
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            with sqlite3.connect(self.database.db_path) as conn:
                portfolio_data = pd.read_sql_query("""
                    SELECT timestamp, total_value, daily_pnl, unrealized_pnl
                    FROM portfolio_history 
                    WHERE timestamp >= ? 
                    ORDER BY timestamp
                """, conn, params=(start_date,), parse_dates=['timestamp'])
            
            if portfolio_data.empty:
                return "<div>Pas de données de performance disponibles</div>"
            
            # Créer le graphique
            fig = make_subplots(
                rows=2, cols=1,
                subplot_titles=['Valeur du Portefeuille', 'PnL Journalier'],
                vertical_spacing=0.1
            )
            
            # Courbe de valeur du portefeuille
            fig.add_trace(
                go.Scatter(
                    x=portfolio_data['timestamp'],
                    y=portfolio_data['total_value'],
                    mode='lines',
                    name='Valeur Totale',
                    line=dict(color='blue', width=2)
                ),
                row=1, col=1
            )
            
            # PnL journalier
            colors = ['green' if x >= 0 else 'red' for x in portfolio_data['daily_pnl']]
            fig.add_trace(
                go.Bar(
                    x=portfolio_data['timestamp'],
                    y=portfolio_data['daily_pnl'],
                    name='PnL Journalier',
                    marker_color=colors
                ),
                row=2, col=1
            )
            
            fig.update_layout(
                title='Performance du Portefeuille SLM TRADE',
                height=600,
                showlegend=True
            )
            
            return fig.to_html(include_plotlyjs='cdn')
            
        except Exception as e:
            logger.error(f"Erreur création graphique: {e}")
            return f"<div>Erreur génération graphique: {e}</div>"

# Interface Web Flask
class SLMWebInterface:
    """Interface web pour SLM TRADE"""
    
    def __init__(self, trading_system: SLMTradeSystemComplete):
        self.trading_system = trading_system
        self.app = Flask(__name__)
        self._setup_routes()
    
    def _setup_routes(self):
        """Configure les routes de l'interface web"""
        
        @self.app.route('/')
        def dashboard():
            """Page principale du dashboard"""
            dashboard_html = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>SLM TRADE - Dashboard</title>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
                    .container { max-width: 1200px; margin: 0 auto; }
                    .header { text-align: center; color: #2c3e50; margin-bottom: 30px; }
                    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
                    .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                    .card h3 { margin-top: 0; color: #34495e; }
                    .value { font-size: 24px; font-weight: bold; }
                    .positive { color: #27ae60; }
                    .negative { color: #e74c3c; }
                    .neutral { color: #95a5a6; }
                    .chart-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
                    .signals-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
                    .signals-table th, .signals-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                    .signals-table th { background-color: #f8f9fa; }
                    .signal-buy { color: #27ae60; font-weight: bold; }
                    .signal-sell { color: #e74c3c; font-weight: bold; }
                    .signal-hold { color: #95a5a6; }
                    .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
                    .btn { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-right: 10px; }
                    .btn-primary { background: #3498db; color: white; }
                    .btn-success { background: #27ae60; color: white; }
                    .btn-danger { background: #e74c3c; color: white; }
                    .btn:hover { opacity: 0.8; }
                    input[type="text"] { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>🚀 SLM TRADE - Système de Trading Algorithmique</h1>
                        <p>Dashboard de Trading Professionnel avec IA</p>
                    </div>
                    
                    <div class="controls">
                        <h3>Contrôles du Système</h3>
                        <button class="btn btn-success" onclick="startTrading()">▶️ Démarrer Trading</button>
                        <button class="btn btn-danger" onclick="stopTrading()">⏹️ Arrêter Trading</button>
                        <input type="text" id="symbolInput" placeholder="Symbole (ex: AAPL)">
                        <button class="btn btn-primary" onclick="addSymbol()">➕ Ajouter Symbole</button>
                        <button class="btn btn-primary" onclick="refreshData()">🔄 Actualiser</button>
                    </div>
                    
                    <div class="stats-grid" id="statsGrid">
                        <!-- Stats will be loaded here -->
                    </div>
                    
                    <div class="chart-container">
                        <h3>📈 Performance du Portefeuille</h3>
                        <div id="performanceChart"></div>
                    </div>
                    
                    <div class="card">
                        <h3>🎯 Signaux de Trading Récents</h3>
                        <div id="signalsTable"></div>
                    </div>
                </div>
                
                <script>
                    function loadDashboard() {
                        fetch('/api/dashboard')
                            .then(response => response.json())
                            .then(data => updateDashboard(data))
                            .catch(error => console.error('Error:', error));
                    }
                    
                    function updateDashboard(data) {
                        // Update stats
                        const statsGrid = document.getElementById('statsGrid');
                        const portfolio = data.portfolio;
                        const performance = data.performance;
                        
                        statsGrid.innerHTML = `
                            <div class="card">
                                <h3>💰 Valeur Totale</h3>
                                <div class="value">${portfolio.total_value.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}</div>
                            </div>
                            <div class="card">
                                <h3>📊 PnL Journalier</h3>
                                <div class="value ${portfolio.daily_pnl >= 0 ? 'positive' : 'negative'}">
                                    ${portfolio.daily_pnl.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}
                                </div>
                            </div>
                            <div class="card">
                                <h3>💸 Liquidités</h3>
                                <div class="value">${portfolio.cash.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}</div>
                            </div>
                            <div class="card">
                                <h3>📈 PnL Non Réalisé</h3>
                                <div class="value ${portfolio.unrealized_pnl >= 0 ? 'positive' : 'negative'}">
                                    ${portfolio.unrealized_pnl.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}
                                </div>
                            </div>
                            <div class="card">
                                <h3>🎯 Win Rate</h3>
                                <div class="value">${performance.win_rate.toFixed(1)}%</div>
                            </div>
                            <div class="card">
                                <h3>📊 Positions Actives</h3>
                                <div class="value">${portfolio.position_count}</div>
                            </div>
                        `;
                        
                        // Update signals table
                        const signalsTable = document.getElementById('signalsTable');
                        let tableHTML = '<table class="signals-table"><tr><th>Symbole</th><th>Signal</th><th>Prix</th><th>Confiance</th><th>Stratégie</th><th>Timestamp</th></tr>';
                        
                        data.recent_signals.slice(0, 10).forEach(signal => {
                            const signalClass = signal.signal_type === 'BUY' ? 'signal-buy' : 
                                              signal.signal_type === 'SELL' ? 'signal-sell' : 'signal-hold';
                            tableHTML += `
                                <tr>
                                    <td>${signal.symbol}</td>
                                    <td class="${signalClass}">${signal.signal_type}</td>
                                    <td>${signal.price.toFixed(2)}</td>
                                    <td>${(signal.confidence * 100).toFixed(1)}%</td>
                                    <td>${signal.strategy}</td>
                                    <td>${new Date(signal.timestamp).toLocaleString()}</td>
                                </tr>
                            `;
                        });
                        tableHTML += '</table>';
                        signalsTable.innerHTML = tableHTML;
                    }
                    
                    function startTrading() {
                        fetch('/api/start-trading', {method: 'POST'})
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                loadDashboard();
                            });
                    }
                    
                    function stopTrading() {
                        fetch('/api/stop-trading', {method: 'POST'})
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                loadDashboard();
                            });
                    }
                    
                    function addSymbol() {
                        const symbol = document.getElementById('symbolInput').value.toUpperCase();
                        if (symbol) {
                            fetch('/api/add-symbol', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({symbol: symbol})
                            })
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                document.getElementById('symbolInput').value = '';
                                loadDashboard();
                            });
                        }
                    }
                    
                    function refreshData() {
                        loadDashboard();
                    }
                    
                    function loadPerformanceChart() {
                        fetch('/api/performance-chart')
                            .then(response => response.text())
                            .then(html => {
                                document.getElementById('performanceChart').innerHTML = html;
                            });
                    }
                    
                    // Auto-refresh every 30 seconds
                    setInterval(loadDashboard, 30000);
                    
                    // Initial load
                    loadDashboard();
                    loadPerformanceChart();
                </script>
            </body>
            </html>
            """
            return dashboard_html
        
        @self.app.route('/api/dashboard')
        def api_dashboard():
            """API endpoint pour les données du dashboard"""
            return jsonify(self.trading_system.get_dashboard_data())
        
        @self.app.route('/api/start-trading', methods=['POST'])
        def api_start_trading():
            """API endpoint pour démarrer le trading"""
            try:
                self.trading_system.start_live_trading()
                return jsonify({'status': 'success', 'message': 'Trading démarré avec succès'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/stop-trading', methods=['POST'])
        def api_stop_trading():
            """API endpoint pour arrêter le trading"""
            try:
                self.trading_system.stop_live_trading()
                return jsonify({'status': 'success', 'message': 'Trading arrêté avec succès'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/add-symbol', methods=['POST'])
        def api_add_symbol():
            """API endpoint pour ajouter un symbole"""
            try:
                data = request.get_json()
                symbol = data.get('symbol', '').upper()
                if symbol:
                    self.trading_system.add_symbol_to_watch(symbol)
                    return jsonify({'status': 'success', 'message': f'Symbole {symbol} ajouté'})
                else:
                    return jsonify({'status': 'error', 'message': 'Symbole invalide'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/performance-chart')
        def api_performance_chart():
            """API endpoint pour le graphique de performance"""
            return self.trading_system.create_performance_chart()
    
    def run(self, host='localhost', port=5000, debug=False):
        """Lance l'interface web"""
        logger.info(f"Interface web démarrée sur http://{host}:{port}")
        self.app.run(host=host, port=port, debug=debug)

# Fonction principale d'initialisation
def initialize_slm_trade_complete(initial_capital: float = 100000, 
                                web_interface: bool = True) -> SLMTradeSystemComplete:
    """
    Initialise le système complet SLM TRADE
    
    Args:
        initial_capital: Capital initial pour le trading
        web_interface: Si True, lance l'interface web
    
    Returns:
        Instance du système de trading complet
    """
    print("🚀 Initialisation du Système SLM TRADE Complet...")
    print("=" * 60)
    
    # Créer le système de trading
    trading_system = SLMTradeSystemComplete(initial_capital)
    
    # Ajouter quelques symboles populaires par défaut
    default_symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']
    for symbol in default_symbols:
        trading_system.add_symbol_to_watch(symbol)
    
    print(f"✅ Système initialisé avec {len(default_symbols)} symboles")
    print(f"💰 Capital initial: ${initial_capital:,.2f}")
    print(f"🎯 Stratégies actives: {len(trading_system.active_strategies)}")
    
    # Lancer l'interface web si demandée
    if web_interface:
        web_app = SLMWebInterface(trading_system)
        print("\n🌐 Interface Web disponible sur: http://localhost:5000")
        print("📊 Dashboard en temps réel avec toutes les métriques")
        
        # Lancer dans un thread séparé pour ne pas bloquer
        web_thread = threading.Thread(
            target=lambda: web_app.run(host='0.0.0.0', port=5000, debug=False),
            daemon=True
        )
        web_thread.start()
        
        print("\n⚡ Pour démarrer le trading automatique, utilisez l'interface web ou:")
        print("   trading_system.start_live_trading()")
    
    print("\n🎉 Système SLM TRADE prêt à l'utilisation!")
    print("=" * 60)
    
    return trading_system

# Exemple d'utilisation complète
if __name__ == "__main__":
    # Initialiser le système complet
    slm_system = initialize_slm_trade_complete(
        initial_capital=100000,
        web_interface=True
    )
    
    # Garder le programme en vie
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n🛑 Arrêt du système...")
        slm_system.stop_live_trading()
        print("✅ Système arrêté proprement")    