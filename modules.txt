# Module 1 

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLM TRADE - Bot de Trading Professionnel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0b0d;
            --bg-secondary: #1a1d21;
            --bg-tertiary: #2a2d33;
            --accent-green: #00d4aa;
            --accent-red: #ff6b6b;
            --accent-blue: #4f46e5;
            --accent-gold: #ffd700;
            --text-primary: #ffffff;
            --text-secondary: #a0a3a8;
            --text-muted: #6b7280;
            --border-color: #374151;
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #00d4aa 0%, #00b894 100%);
            --gradient-danger: linear-gradient(135deg, #ff6b6b 0%, #e74c3c 100%);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Animated Background */
        .bg-animated {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 107, 107, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(0, 212, 170, 0.3) 0%, transparent 50%);
            z-index: -1;
            animation: backgroundFloat 10s ease-in-out infinite;
        }

        @keyframes backgroundFloat {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(1deg); }
        }

        /* Header */
        header {
            background: rgba(26, 29, 33, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-indicators {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.connected { background: var(--accent-green); }
        .status-dot.disconnected { background: var(--accent-red); }
        .status-dot.warning { background: var(--accent-gold); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Layout */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 2rem;
            min-height: calc(100vh - 120px);
        }

        /* Cards */
        .card {
            background: rgba(26, 29, 33, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-4px);
            border-color: var(--accent-blue);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Configuration Panel */
        .config-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
            transform: translateY(-1px);
        }

        .form-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }

        .btn-success {
            background: var(--gradient-success);
            color: white;
        }

        .btn-danger {
            background: var(--gradient-danger);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0px);
        }

        /* Trading Panel */
        .trading-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .trading-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .quick-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        /* Chart Container */
        .chart-container {
            height: 400px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.125rem;
            color: var(--text-muted);
            position: relative;
            overflow: hidden;
        }

        .chart-placeholder {
            text-align: center;
        }

        /* Statistics */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-item {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .stat-value.positive { color: var(--accent-green); }
        .stat-value.negative { color: var(--accent-red); }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Monitoring Panel */
        .monitoring-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .alert-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .alert-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .alert-success { background: var(--accent-green); color: white; }
        .alert-warning { background: var(--accent-gold); color: black; }
        .alert-error { background: var(--accent-red); color: white; }

        .alert-content {
            flex: 1;
        }

        .alert-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .alert-time {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Activity Log */
        .activity-log {
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
        }

        .log-entry {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.875rem;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
                padding: 0 1rem;
            }

            .main-container {
                padding: 1rem;
            }

            .trading-controls {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .quick-actions {
                flex-direction: column;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Glow Effects */
        .glow-success {
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.3);
        }

        .glow-danger {
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            transition: .4s;
            border-radius: 34px;
            border: 1px solid var(--border-color);
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: var(--gradient-success);
            border-color: var(--accent-green);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="bg-animated"></div>
    
    <header>
        <div class="header-content">
            <div class="logo">
                <span>‚ö°</span>
                <span>SLM TRADE</span>
            </div>
            <div class="status-indicators">
                <div class="status-item">
                    <div class="status-dot connected"></div>
                    <span>API Bybit</span>
                </div>
                <div class="status-item">
                    <div class="status-dot connected"></div>
                    <span>WebSocket</span>
                </div>
                <div class="status-item">
                    <div class="status-dot warning"></div>
                    <span>Bot: Standby</span>
                </div>
            </div>
        </div>
    </header>

    <main class="main-container">
        <!-- Configuration Panel -->
        <section class="card config-panel">
            <div class="card-header">
                <h2 class="card-title">‚öôÔ∏è Configuration</h2>
                <label class="toggle-switch">
                    <input type="checkbox" id="botToggle">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="form-group">
                <label class="form-label">Paire de Trading</label>
                <select class="form-select" id="tradingPair">
                    <option value="BTCUSDT">BTC/USDT</option>
                    <option value="ETHUSDT">ETH/USDT</option>
                    <option value="ADAUSDT">ADA/USDT</option>
                    <option value="SOLUSDT">SOL/USDT</option>
                    <option value="DOTUSDT">DOT/USDT</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Montant par Trade (USDT)</label>
                <input type="number" class="form-input" id="tradeAmount" value="100" min="1" step="1">
            </div>

            <div class="form-group">
                <label class="form-label">Stop Loss (%)</label>
                <input type="number" class="form-input" id="stopLoss" value="2" min="0.1" step="0.1">
            </div>

            <div class="form-group">
                <label class="form-label">Take Profit (%)</label>
                <input type="number" class="form-input" id="takeProfit" value="3" min="0.1" step="0.1">
            </div>

            <div class="form-group">
                <label class="form-label">Strat√©gie</label>
                <select class="form-select" id="strategy">
                    <option value="scalping">Scalping</option>
                    <option value="swing">Swing Trading</option>
                    <option value="grid">Grid Trading</option>
                    <option value="dca">DCA</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Risk Management</label>
                <select class="form-select" id="riskLevel">
                    <option value="conservative">Conservateur</option>
                    <option value="moderate">Mod√©r√©</option>
                    <option value="aggressive">Agressif</option>
                </select>
            </div>

            <button class="btn btn-primary" id="saveConfig">
                üíæ Sauvegarder Configuration
            </button>

            <button class="btn btn-outline" id="resetConfig">
                üîÑ Reset par D√©faut
            </button>
        </section>

        <!-- Trading Panel -->
        <section class="card trading-panel">
            <div class="card-header">
                <h2 class="card-title">üìà Trading Dashboard</h2>
                <div class="quick-actions">
                    <button class="btn btn-success" id="startBot">‚ñ∂Ô∏è D√©marrer</button>
                    <button class="btn btn-danger" id="stopBot">‚èπÔ∏è Arr√™ter</button>
                    <button class="btn btn-outline" id="pauseBot">‚è∏Ô∏è Pause</button>
                </div>
            </div>

            <!-- Statistics -->
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value positive" id="totalProfit">+‚Ç¨0.00</div>
                    <div class="stat-label">Profit Total</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalTrades">0</div>
                    <div class="stat-label">Trades Total</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value positive" id="winRate">0%</div>
                    <div class="stat-label">Taux de R√©ussite</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="currentPrice">‚Ç¨0.00</div>
                    <div class="stat-label">Prix Actuel</div>
                </div>
            </div>

            <!-- Chart -->
            <div class="chart-container" id="tradingChart">
                <div class="chart-placeholder">
                    <div>üìä Graphique Trading</div>
                    <div style="font-size: 0.875rem; margin-top: 0.5rem;">
                        Le graphique sera int√©gr√© dans le Module 3
                    </div>
                </div>
            </div>

            <!-- Trading Controls -->
            <div class="trading-controls">
                <button class="btn btn-success" id="manualBuy">
                    üìà Achat Manuel
                </button>
                <button class="btn btn-danger" id="manualSell">
                    üìâ Vente Manuel
                </button>
                <button class="btn btn-outline" id="closeAllPositions">
                    üö™ Fermer Toutes Positions
                </button>
                <button class="btn btn-outline" id="emergencyStop">
                    üö® Arr√™t d'Urgence
                </button>
            </div>
        </section>

        <!-- Monitoring Panel -->
        <section class="card monitoring-panel">
            <div class="card-header">
                <h2 class="card-title">üîç Monitoring</h2>
                <span class="text-muted" id="lastUpdate">Derni√®re MAJ: --:--</span>
            </div>

            <!-- Alerts -->
            <div class="alerts-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">üö® Alertes</h3>
                <div class="alert-item">
                    <div class="alert-icon alert-success">‚úì</div>
                    <div class="alert-content">
                        <div class="alert-title">Bot Connect√©</div>
                        <div class="alert-time">Il y a 2 minutes</div>
                    </div>
                </div>
                <div class="alert-item">
                    <div class="alert-icon alert-warning">‚ö†</div>
                    <div class="alert-content">
                        <div class="alert-title">Volatilit√© √âlev√©e</div>
                        <div class="alert-time">Il y a 5 minutes</div>
                    </div>
                </div>
            </div>

            <!-- Portfolio Info -->
            <div class="portfolio-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">üíº Portfolio</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="accountBalance">‚Ç¨0.00</div>
                        <div class="stat-label">Solde Compte</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="openPositions">0</div>
                        <div class="stat-label">Positions Ouvertes</div>
                    </div>
                </div>
            </div>

            <!-- Activity Log -->
            <div class="activity-section">
                <h3 style="font-size: 1rem; margin-bottom: 1rem; color: var(--text-secondary);">üìã Activit√© R√©cente</h3>
                <div class="activity-log" id="activityLog">
                    <div class="log-entry">
                        <span>Bot d√©marr√©</span>
                        <span class="log-time">12:30:45</span>
                    </div>
                    <div class="log-entry">
                        <span>Configuration sauvegard√©e</span>
                        <span class="log-time">12:25:12</span>
                    </div>
                    <div class="log-entry">
                        <span>Connexion API √©tablie</span>
                        <span class="log-time">12:20:33</span>
                    </div>
                </div>
            </div>

            <!-- API Status -->
            <div class="api-status">
                <button class="btn btn-outline" id="testConnection">
                    üîó Test Connexion API
                </button>
                <button class="btn btn-outline" id="refreshData">
                    üîÑ Actualiser Donn√©es
                </button>
            </div>
        </section>
    </main>

    <script>
        // Interface State Management
        class UIManager {
            constructor() {
                this.botActive = false;
                this.initializeEventListeners();
                this.updateTimestamp();
                setInterval(() => this.updateTimestamp(), 1000);
            }

            initializeEventListeners() {
                // Bot Toggle
                document.getElementById('botToggle').addEventListener('change', (e) => {
                    this.toggleBot(e.target.checked);
                });

                // Control Buttons
                document.getElementById('startBot').addEventListener('click', () => this.startBot());
                document.getElementById('stopBot').addEventListener('click', () => this.stopBot());
                document.getElementById('pauseBot').addEventListener('click', () => this.pauseBot());

                // Configuration
                document.getElementById('saveConfig').addEventListener('click', () => this.saveConfiguration());
                document.getElementById('resetConfig').addEventListener('click', () => this.resetConfiguration());

                // Manual Trading
                document.getElementById('manualBuy').addEventListener('click', () => this.executeManualTrade('BUY'));
                document.getElementById('manualSell').addEventListener('click', () => this.executeManualTrade('SELL'));

                // Emergency Actions
                document.getElementById('closeAllPositions').addEventListener('click', () => this.closeAllPositions());
                document.getElementById('emergencyStop').addEventListener('click', () => this.emergencyStop());

                // API Testing
                document.getElementById('testConnection').addEventListener('click', () => this.testAPIConnection());
                document.getElementById('refreshData').addEventListener('click', () => this.refreshData());
            }

            toggleBot(active) {
                this.botActive = active;
                this.updateBotStatus(active ? 'Active' : 'Standby');
                this.logActivity(active ? 'Bot activ√©' : 'Bot d√©sactiv√©');
                
                if (active) {
                    this.showNotification('Bot d√©marr√© avec succ√®s', 'success');
                } else {
                    this.showNotification('Bot arr√™t√©', 'warning');
                }
            }

            startBot() {
                document.getElementById('botToggle').checked = true;
                this.toggleBot(true);
            }

            stopBot() {
                document.getElementById('botToggle').checked = false;
                this.toggleBot(false);
            }

            pauseBot() {
                this.updateBotStatus('En Pause');
                this.logActivity('Bot mis en pause');
                this.showNotification('Bot en pause', 'warning');
            }

            saveConfiguration() {
                const config = {
                    tradingPair: document.getElementById('tradingPair').value,
                    tradeAmount: document.getElementById('tradeAmount').value,
                    stopLoss: document.getElementById('stopLoss').value,
                    takeProfit: document.getElementById('takeProfit').value,
                    strategy: document.getElementById('strategy').value,
                    riskLevel: document.getElementById('riskLevel').value
                };

                // Simulate API call with loading
                const btn = document.getElementById('saveConfig');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Sauvegarde...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.logActivity('Configuration sauvegard√©e');
                    this.showNotification('Configuration sauvegard√©e', 'success');
                }, 1500);
            }

            resetConfiguration() {
                document.getElementById('tradingPair').value = 'BTCUSDT';
                document.getElementById('tradeAmount').value = '100';
                document.getElementById('stopLoss').value = '2';
                document.getElementById('takeProfit').value = '3';
                document.getElementById('strategy').value = 'scalping';
                document.getElementById('riskLevel').value = 'moderate';
                
                this.logActivity('Configuration r√©initialis√©e');
                this.showNotification('Configuration r√©initialis√©e', 'success');
            }

            executeManualTrade(type) {
                const amount = document.getElementById('tradeAmount').value;
                const pair = document.getElementById('tradingPair').value;
                
                this.logActivity(`Trade manuel ${type}: ${amount} USDT sur ${pair}`);
                this.showNotification(`Trade ${type} ex√©cut√©`, 'success');
                
                // Update stats (simulation)
                this.updateStats();
            }

            closeAllPositions() {
                this.logActivity('Fermeture de toutes les positions');
                this.showNotification('Toutes les positions ferm√©es', 'warning');
                document.getElementById('openPositions').textContent = '0';
            }

            emergencyStop() {
                document.getElementById('botToggle').checked = false;
                this.toggleBot(false);
                this.closeAllPositions();
                this.showNotification('ARR√äT D\'URGENCE ACTIV√â', 'error');
                this.logActivity('üö® ARR√äT D\'URGENCE');
            }

            testAPIConnection() {
                const btn = document.getElementById('testConnection');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Test...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.logActivity('Test de connexion API r√©ussi');
                    this.showNotification('Connexion API OK', 'success');
                }, 2000);
            }

            refreshData() {
                const btn = document.getElementById('refreshData');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<div class="loading"></div> Actualisation...';
                btn.disabled = true;

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                    this.updateStats();
                    this.logActivity('Donn√©es actualis√©es');
                    this.showNotification('Donn√©es mises √† jour', 'success');
                }, 1500);
            }

            updateStats() {
                // Simulate real trading data
                const profits = [125.67, -45.23, 89.12, 234.56, -12.34];
                const randomProfit = profits[Math.floor(Math.random() * profits.length)];
                const totalTrades = Math.floor(Math.random() * 50) + 1;
                const winRate = Math.floor(Math.random() * 40) + 60;
                const currentPrice = (Math.random() * 50000 + 30000).toFixed(2);
                const balance = (Math.random() * 5000 + 1000).toFixed(2);

                document.getElementById('totalProfit').textContent = `${randomProfit >= 0 ? '+' : ''}‚Ç¨${randomProfit.toFixed(2)}`;
                document.getElementById('totalProfit').className = `stat-value ${randomProfit >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('totalTrades').textContent = totalTrades;
                document.getElementById('winRate').textContent = `${winRate}%`;
                document.getElementById('currentPrice').textContent = `‚Ç¨${currentPrice}`;
                document.getElementById('accountBalance').textContent = `‚Ç¨${balance}`;
                document.getElementById('openPositions').textContent = Math.floor(Math.random() * 5);
            }

            updateBotStatus(status) {
                const statusItems = document.querySelectorAll('.status-item');
                const botStatus = Array.from(statusItems).find(item => item.textContent.includes('Bot:'));
                if (botStatus) {
                    const dot = botStatus.querySelector('.status-dot');
                    const text = botStatus.querySelector('span');
                    text.textContent = `Bot: ${status}`;
                    
                    dot.className = 'status-dot';
                    if (status === 'Active') {
                        dot.classList.add('connected');
                    } else if (status === 'En Pause') {
                        dot.classList.add('warning');
                    } else {
                        dot.classList.add('disconnected');
                    }
                }
            }

            logActivity(message) {
                const log = document.getElementById('activityLog');
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `
                    <span>${message}</span>
                    <span class="log-time">${time}</span>
                `;
                log.insertBefore(entry, log.firstChild);
                
                // Keep only last 10 entries
                while (log.children.length > 10) {
                    log.removeChild(log.lastChild);
                }
            }

            showNotification(message, type) {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">${this.getNotificationIcon(type)}</span>
                        <span class="notification-message">${message}</span>
                    </div>
                `;
                
                // Add notification styles
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? 'var(--gradient-success)' : 
                                type === 'error' ? 'var(--gradient-danger)' : 
                                'linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)'};
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 12px;
                    box-shadow: var(--shadow-lg);
                    z-index: 10000;
                    animation: slideInRight 0.3s ease-out forwards;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.1);
                `;

                document.body.appendChild(notification);

                // Auto remove after 3 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideOutRight 0.3s ease-out forwards';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            getNotificationIcon(type) {
                switch(type) {
                    case 'success': return '‚úÖ';
                    case 'error': return '‚ùå';
                    case 'warning': return '‚ö†Ô∏è';
                    default: return '‚ÑπÔ∏è';
                }
            }

            updateTimestamp() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = `Derni√®re MAJ: ${timeString}`;
            }
        }

        // Add notification animations
        const notificationStyles = document.createElement('style');
        notificationStyles.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }

            .notification-content {
                display: flex;
                align-items: center;
                gap: 0.75rem;
            }

            .notification-icon {
                font-size: 1.2rem;
            }

            .notification-message {
                font-weight: 600;
                font-size: 0.9rem;
            }
        `;
        document.head.appendChild(notificationStyles);

        // Market Data Simulator
        class MarketSimulator {
            constructor() {
                this.currentPrice = 45000;
                this.startPriceUpdates();
            }

            startPriceUpdates() {
                setInterval(() => {
                    // Simulate price movements
                    const change = (Math.random() - 0.5) * 1000;
                    this.currentPrice += change;
                    this.currentPrice = Math.max(30000, Math.min(80000, this.currentPrice));
                    
                    document.getElementById('currentPrice').textContent = `‚Ç¨${this.currentPrice.toFixed(2)}`;
                    
                    // Add some visual feedback for price changes
                    const priceElement = document.getElementById('currentPrice');
                    priceElement.style.transform = 'scale(1.05)';
                    priceElement.style.transition = 'transform 0.2s ease';
                    
                    setTimeout(() => {
                        priceElement.style.transform = 'scale(1)';
                    }, 200);
                }, 5000);
            }
        }

        // Performance Monitor
        class PerformanceMonitor {
            constructor() {
                this.trades = [];
                this.startMonitoring();
            }

            startMonitoring() {
                // Simulate random trading activity
                setInterval(() => {
                    if (Math.random() > 0.7) { // 30% chance every 10 seconds
                        this.simulateTrade();
                    }
                }, 10000);
            }

            simulateTrade() {
                const trade = {
                    type: Math.random() > 0.5 ? 'BUY' : 'SELL',
                    amount: Math.random() * 200 + 50,
                    profit: (Math.random() - 0.5) * 100,
                    timestamp: new Date()
                };

                this.trades.push(trade);
                
                // Update UI
                const uiManager = window.uiManager;
                uiManager.logActivity(`Trade ${trade.type}: ‚Ç¨${trade.profit.toFixed(2)}`);
                
                if (Math.abs(trade.profit) > 50) {
                    uiManager.showNotification(
                        `Trade ${trade.type}: ${trade.profit >= 0 ? '+' : ''}‚Ç¨${trade.profit.toFixed(2)}`,
                        trade.profit >= 0 ? 'success' : 'error'
                    );
                }
            }
        }

        // Advanced Chart Placeholder
        class ChartManager {
            constructor() {
                this.initializeChart();
            }

            initializeChart() {
                const chartContainer = document.getElementById('tradingChart');
                
                // Add some animated elements to make it look more dynamic
                chartContainer.innerHTML = `
                    <div class="chart-placeholder">
                        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                            <div class="loading"></div>
                            <span>üìä Graphique de Trading en Temps R√©el</span>
                        </div>
                        <div style="font-size: 0.875rem; color: var(--text-muted); text-align: center;">
                            <p>‚Ä¢ Chandelier japonais interactif</p>
                            <p>‚Ä¢ Indicateurs techniques (RSI, MACD, Bollinger)</p>
                            <p>‚Ä¢ Volume et profondeur de march√©</p>
                            <p>‚Ä¢ Zones de support/r√©sistance</p>
                            <br>
                            <p><strong>Sera int√©gr√© dans le Module 3 - Graphiques</strong></p>
                        </div>
                    </div>
                `;

                // Add some visual effects
                setInterval(() => {
                    const placeholder = chartContainer.querySelector('.chart-placeholder');
                    if (placeholder) {
                        placeholder.style.background = `linear-gradient(45deg, 
                            rgba(79, 70, 229, 0.05) 0%, 
                            rgba(0, 212, 170, 0.05) 50%, 
                            rgba(255, 107, 107, 0.05) 100%)`;
                        
                        setTimeout(() => {
                            placeholder.style.background = '';
                        }, 1000);
                    }
                }, 8000);
            }
        }

        // Risk Management Display
        class RiskManager {
            constructor() {
                this.updateRiskMetrics();
                setInterval(() => this.updateRiskMetrics(), 30000);
            }

            updateRiskMetrics() {
                // Simulate risk calculations
                const drawdown = (Math.random() * 10).toFixed(1);
                const sharpeRatio = (Math.random() * 2 + 0.5).toFixed(2);
                const volatility = (Math.random() * 30 + 10).toFixed(1);

                // Add risk metrics to monitoring panel
                const monitoringPanel = document.querySelector('.monitoring-panel .card');
                let riskSection = document.getElementById('riskMetrics');
                
                if (!riskSection) {
                    riskSection = document.createElement('div');
                    riskSection.id = 'riskMetrics';
                    riskSection.innerHTML = `
                        <h3 style="font-size: 1rem; margin: 2rem 0 1rem 0; color: var(--text-secondary);">‚ö†Ô∏è Gestion des Risques</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-value" id="maxDrawdown">${drawdown}%</div>
                                <div class="stat-label">Drawdown Max</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="sharpeRatio">${sharpeRatio}</div>
                                <div class="stat-label">Ratio Sharpe</div>
                            </div>
                        </div>
                    `;
                    monitoringPanel.appendChild(riskSection);
                } else {
                    document.getElementById('maxDrawdown').textContent = `${drawdown}%`;
                    document.getElementById('sharpeRatio').textContent = sharpeRatio;
                }
            }
        }

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize all managers
            window.uiManager = new UIManager();
            window.marketSimulator = new MarketSimulator();
            window.performanceMonitor = new PerformanceMonitor();
            window.chartManager = new ChartManager();
            window.riskManager = new RiskManager();

            // Initial data load
            window.uiManager.updateStats();
            window.uiManager.logActivity('Application SLM TRADE initialis√©e');
            window.uiManager.showNotification('SLM TRADE pr√™t √† trader !', 'success');

            // Add some initial activity
            setTimeout(() => {
                window.uiManager.logActivity('Connexion WebSocket √©tablie');
                window.uiManager.logActivity('Donn√©es de march√© synchronis√©es');
            }, 2000);

            console.log('üöÄ SLM TRADE Interface initialis√©e avec succ√®s!');
            console.log('üìä Modules charg√©s: UI, Market Simulator, Performance Monitor, Chart Manager, Risk Manager');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 's':
                        event.preventDefault();
                        window.uiManager.saveConfiguration();
                        break;
                    case 'r':
                        event.preventDefault();
                        window.uiManager.refreshData();
                        break;
                    case ' ':
                        event.preventDefault();
                        const toggle = document.getElementById('botToggle');
                        toggle.checked = !toggle.checked;
                        window.uiManager.toggleBot(toggle.checked);
                        break;
                }
            }

            // Emergency stop with ESC key
            if (event.key === 'Escape') {
                window.uiManager.emergencyStop();
            }
        });
    </script>
</body>
</html>

# Module 2 

// SLM TRADE - Module 2: Connexions API Bybit R√©elles
// Int√©gration compl√®te avec l'API Bybit (REST + WebSocket)

class BybitAPI {
    constructor() {
        this.apiKey = '';
        this.apiSecret = '';
        this.baseURL = 'https://api.bybit.com';
        this.testnetURL = 'https://api-testnet.bybit.com';
        this.isTestnet = true; // Basculer en false pour le trading r√©el
        this.ws = null;
        this.isConnected = false;
        this.subscriptions = new Set();
        this.orderBook = new Map();
        this.klineData = new Map();
        this.positions = new Map();
        this.orders = new Map();
        this.callbacks = new Map();
    }

    // Configuration API
    setCredentials(apiKey, apiSecret, isTestnet = true) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.isTestnet = isTestnet;
        this.log('API credentials configured', 'info');
    }

    // G√©n√©ration de signature pour l'authentification
    generateSignature(timestamp, queryString) {
        const message = timestamp + this.apiKey + queryString;
        return CryptoJS.HmacSHA256(message, this.apiSecret).toString();
    }

    // Requ√™te REST API authentifi√©e
    async makeRequest(endpoint, method = 'GET', params = {}) {
        const timestamp = Date.now().toString();
        const baseUrl = this.isTestnet ? this.testnetURL : this.baseURL;
        
        let queryString = '';
        if (method === 'GET' && Object.keys(params).length > 0) {
            queryString = new URLSearchParams(params).toString();
        }

        const signature = this.generateSignature(timestamp, queryString);
        
        const headers = {
            'X-BAPI-API-KEY': this.apiKey,
            'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp,
            'Content-Type': 'application/json'
        };

        const url = `${baseUrl}${endpoint}${queryString ? '?' + queryString : ''}`;
        
        const options = {
            method,
            headers,
        };

        if (method === 'POST' && Object.keys(params).length > 0) {
            options.body = JSON.stringify(params);
        }

        try {
            const response = await fetch(url, options);
            const data = await response.json();
            
            if (data.retCode !== 0) {
                throw new Error(`API Error: ${data.retMsg}`);
            }
            
            return data.result;
        } catch (error) {
            this.log(`API Request Error: ${error.message}`, 'error');
            throw error;
        }
    }

    // Connexion WebSocket
    async connectWebSocket() {
        const wsUrl = this.isTestnet 
            ? 'wss://stream-testnet.bybit.com/v5/public/linear'
            : 'wss://stream.bybit.com/v5/public/linear';

        try {
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                this.isConnected = true;
                this.log('WebSocket connected successfully', 'success');
                this.updateConnectionStatus(true);
                
                // Authentification WebSocket si n√©cessaire
                if (this.apiKey && this.apiSecret) {
                    this.authenticateWebSocket();
                }
            };

            this.ws.onmessage = (event) => {
                this.handleWebSocketMessage(JSON.parse(event.data));
            };

            this.ws.onclose = () => {
                this.isConnected = false;
                this.log('WebSocket connection closed', 'warning');
                this.updateConnectionStatus(false);
                this.reconnectWebSocket();
            };

            this.ws.onerror = (error) => {
                this.log(`WebSocket error: ${error.message}`, 'error');
            };

        } catch (error) {
            this.log(`WebSocket connection failed: ${error.message}`, 'error');
        }
    }

    // Authentification WebSocket
    authenticateWebSocket() {
        const timestamp = Date.now();
        const signature = CryptoJS.HmacSHA256(`GET/realtime${timestamp}`, this.apiSecret).toString();
        
        const authMessage = {
            op: 'auth',
            args: [this.apiKey, timestamp, signature]
        };
        
        this.ws.send(JSON.stringify(authMessage));
    }

    // Gestion des messages WebSocket
    handleWebSocketMessage(data) {
        if (data.topic) {
            const topic = data.topic;
            
            if (topic.includes('orderbook')) {
                this.updateOrderBook(data);
            } else if (topic.includes('kline')) {
                this.updateKlineData(data);
            } else if (topic.includes('position')) {
                this.updatePositions(data);
            } else if (topic.includes('order')) {
                this.updateOrders(data);
            }
            
            // Notifier les callbacks
            if (this.callbacks.has(topic)) {
                this.callbacks.get(topic)(data);
            }
        }
    }

    // Souscription √† un topic WebSocket
    subscribe(topic, callback = null) {
        if (!this.isConnected) {
            this.log('WebSocket not connected', 'error');
            return;
        }

        const subscribeMessage = {
            op: 'subscribe',
            args: [topic]
        };

        this.ws.send(JSON.stringify(subscribeMessage));
        this.subscriptions.add(topic);
        
        if (callback) {
            this.callbacks.set(topic, callback);
        }
        
        this.log(`Subscribed to ${topic}`, 'info');
    }

    // D√©sabonnement d'un topic
    unsubscribe(topic) {
        if (!this.isConnected) return;

        const unsubscribeMessage = {
            op: 'unsubscribe',
            args: [topic]
        };

        this.ws.send(JSON.stringify(unsubscribeMessage));
        this.subscriptions.delete(topic);
        this.callbacks.delete(topic);
        
        this.log(`Unsubscribed from ${topic}`, 'info');
    }

    // Reconnexion automatique WebSocket
    reconnectWebSocket() {
        setTimeout(() => {
            if (!this.isConnected) {
                this.log('Attempting to reconnect WebSocket...', 'info');
                this.connectWebSocket();
            }
        }, 5000);
    }

    // === FONCTIONS DE TRADING ===

    // R√©cup√©rer les informations du compte
    async getAccountBalance() {
        try {
            const result = await this.makeRequest('/v5/account/wallet-balance', 'GET', {
                accountType: 'UNIFIED'
            });
            this.log('Account balance retrieved', 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get account balance: ${error.message}`, 'error');
            throw error;
        }
    }

    // R√©cup√©rer les positions
    async getPositions(symbol = '') {
        try {
            const params = {
                category: 'linear',
                settleCoin: 'USDT'
            };
            
            if (symbol) {
                params.symbol = symbol;
            }

            const result = await this.makeRequest('/v5/position/list', 'GET', params);
            this.log(`Positions retrieved${symbol ? ' for ' + symbol : ''}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get positions: ${error.message}`, 'error');
            throw error;
        }
    }

    // Passer un ordre
    async placeOrder(symbol, side, orderType, qty, price = null, timeInForce = 'GTC', options = {}) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                side: side, // 'Buy' ou 'Sell'
                orderType: orderType, // 'Market' ou 'Limit'
                qty: qty.toString(),
                timeInForce: timeInForce,
                ...options
            };

            if (orderType === 'Limit' && price) {
                params.price = price.toString();
            }

            const result = await this.makeRequest('/v5/order/create', 'POST', params);
            this.log(`Order placed: ${side} ${qty} ${symbol} at ${price || 'market'}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to place order: ${error.message}`, 'error');
            throw error;
        }
    }

    // Annuler un ordre
    async cancelOrder(symbol, orderId) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                orderId: orderId
            };

            const result = await this.makeRequest('/v5/order/cancel', 'POST', params);
            this.log(`Order cancelled: ${orderId}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to cancel order: ${error.message}`, 'error');
            throw error;
        }
    }

    // Fermer une position
    async closePosition(symbol, side) {
        try {
            const positions = await this.getPositions(symbol);
            const position = positions.list.find(p => p.symbol === symbol && p.side === side);
            
            if (!position || parseFloat(position.size) === 0) {
                throw new Error('No position to close');
            }

            const closeSide = side === 'Buy' ? 'Sell' : 'Buy';
            const result = await this.placeOrder(symbol, closeSide, 'Market', Math.abs(parseFloat(position.size)));
            
            this.log(`Position closed: ${side} ${symbol}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to close position: ${error.message}`, 'error');
            throw error;
        }
    }

    // R√©cup√©rer l'historique des ordres
    async getOrderHistory(symbol = '', limit = 50) {
        try {
            const params = {
                category: 'linear',
                limit: limit
            };
            
            if (symbol) {
                params.symbol = symbol;
            }

            const result = await this.makeRequest('/v5/order/history', 'GET', params);
            this.log('Order history retrieved', 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get order history: ${error.message}`, 'error');
            throw error;
        }
    }

    // R√©cup√©rer les donn√©es de prix
    async getTicker(symbol) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol
            };

            const result = await this.makeRequest('/v5/market/tickers', 'GET', params);
            return result.list[0];
        } catch (error) {
            this.log(`Failed to get ticker for ${symbol}: ${error.message}`, 'error');
            throw error;
        }
    }

    // R√©cup√©rer les donn√©es kline/chandelier
    async getKlineData(symbol, interval = '1', limit = 200) {
        try {
            const params = {
                category: 'linear',
                symbol: symbol,
                interval: interval,
                limit: limit
            };

            const result = await this.makeRequest('/v5/market/kline', 'GET', params);
            this.log(`Kline data retrieved for ${symbol}`, 'success');
            return result;
        } catch (error) {
            this.log(`Failed to get kline data: ${error.message}`, 'error');
            throw error;
        }
    }

    // === FONCTIONS DE MISE √Ä JOUR DES DONN√âES ===

    updateOrderBook(data) {
        const symbol = data.data.s;
        this.orderBook.set(symbol, data.data);
        
        // Mettre √† jour l'interface si elle existe
        if (typeof updateOrderBookUI === 'function') {
            updateOrderBookUI(symbol, data.data);
        }
    }

    updateKlineData(data) {
        const symbol = data.data.symbol;
        if (!this.klineData.has(symbol)) {
            this.klineData.set(symbol, []);
        }
        
        const klines = this.klineData.get(symbol);
        klines.push(data.data);
        
        // Garder seulement les 1000 derni√®res bougies
        if (klines.length > 1000) {
            klines.shift();
        }
        
        // Mettre √† jour l'interface si elle existe
        if (typeof updateChartUI === 'function') {
            updateChartUI(symbol, data.data);
        }
    }

    updatePositions(data) {
        data.data.forEach(position => {
            this.positions.set(position.symbol, position);
        });
        
        // Mettre √† jour l'interface si elle existe
        if (typeof updatePositionsUI === 'function') {
            updatePositionsUI(data.data);
        }
    }

    updateOrders(data) {
        data.data.forEach(order => {
            this.orders.set(order.orderId, order);
        });
        
        // Mettre √† jour l'interface si elle existe
        if (typeof updateOrdersUI === 'function') {
            updateOrdersUI(data.data);
        }
    }

    // === FONCTIONS UTILITAIRES ===

    // Test de connexion API
    async testConnection() {
        try {
            await this.makeRequest('/v5/market/time', 'GET');
            this.log('API connection test successful', 'success');
            return true;
        } catch (error) {
            this.log(`API connection test failed: ${error.message}`, 'error');
            return false;
        }
    }

    // Mise √† jour du statut de connexion dans l'UI
    updateConnectionStatus(connected) {
        const statusElement = document.getElementById('api-status');
        if (statusElement) {
            statusElement.textContent = connected ? 'Connect√©' : 'D√©connect√©';
            statusElement.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }

        const wsStatusElement = document.getElementById('ws-status');
        if (wsStatusElement) {
            wsStatusElement.textContent = connected ? 'Connect√©' : 'D√©connect√©';
            wsStatusElement.className = `status ${connected ? 'connected' : 'disconnected'}`;
        }
    }

    // Logger avec gestion UI
    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logMessage = `[${timestamp}] ${message}`;
        
        console.log(logMessage);
        
        // Ajouter au log UI si disponible
        if (typeof addToActivityLog === 'function') {
            addToActivityLog(message, type);
        }
    }

    // D√©connexion propre
    disconnect() {
        if (this.ws) {
            this.ws.close();
        }
        this.isConnected = false;
        this.subscriptions.clear();
        this.callbacks.clear();
        this.log('API disconnected', 'info');
    }
}

// === GESTIONNAIRE PRINCIPAL DE L'API ===

class APIManager {
    constructor() {
        this.bybitAPI = new BybitAPI();
        this.isInitialized = false;
        this.activeSymbol = 'BTCUSDT';
        this.monitoringInterval = null;
    }

    // Initialisation de l'API
    async initialize(apiKey, apiSecret, isTestnet = true) {
        try {
            this.bybitAPI.setCredentials(apiKey, apiSecret, isTestnet);
            
            // Test de connexion
            const connected = await this.bybitAPI.testConnection();
            if (!connected) {
                throw new Error('Failed to connect to Bybit API');
            }

            // Connexion WebSocket
            await this.bybitAPI.connectWebSocket();
            
            // Souscriptions de base
            this.setupSubscriptions();
            
            // D√©marrage du monitoring
            this.startMonitoring();
            
            this.isInitialized = true;
            this.bybitAPI.log('API Manager initialized successfully', 'success');
            
            return true;
        } catch (error) {
            this.bybitAPI.log(`API initialization failed: ${error.message}`, 'error');
            return false;
        }
    }

    // Configuration des souscriptions WebSocket
    setupSubscriptions() {
        // Souscription aux donn√©es de prix
        this.bybitAPI.subscribe(`tickers.${this.activeSymbol}`, (data) => {
            this.handleTickerUpdate(data);
        });

        // Souscription aux positions (si authentifi√©)
        if (this.bybitAPI.apiKey) {
            this.bybitAPI.subscribe('position', (data) => {
                this.handlePositionUpdate(data);
            });
        }
    }

    // Gestion des mises √† jour de prix
    handleTickerUpdate(data) {
        const ticker = data.data;
        
        // Mettre √† jour l'interface de prix
        if (typeof updatePriceDisplay === 'function') {
            updatePriceDisplay(ticker);
        }
    }

    // Gestion des mises √† jour de positions
    handlePositionUpdate(data) {
        // Mettre √† jour l'interface des positions
        if (typeof updatePositionDisplay === 'function') {
            updatePositionDisplay(data.data);
        }
    }

    // D√©marrage du monitoring p√©riodique
    startMonitoring() {
        this.monitoringInterval = setInterval(async () => {
            try {
                // R√©cup√©ration p√©riodique des donn√©es de compte
                if (this.bybitAPI.apiKey) {
                    const balance = await this.bybitAPI.getAccountBalance();
                    if (typeof updateAccountBalance === 'function') {
                        updateAccountBalance(balance);
                    }
                }
            } catch (error) {
                this.bybitAPI.log(`Monitoring error: ${error.message}`, 'error');
            }
        }, 10000); // Toutes les 10 secondes
    }

    // Arr√™t du monitoring
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
    }

    // Changement de symbole de trading
    changeSymbol(symbol) {
        // D√©sabonnement de l'ancien symbole
        this.bybitAPI.unsubscribe(`tickers.${this.activeSymbol}`);
        
        // Changement de symbole actif
        this.activeSymbol = symbol;
        
        // Souscription au nouveau symbole
        this.bybitAPI.subscribe(`tickers.${symbol}`, (data) => {
            this.handleTickerUpdate(data);
        });
        
        this.bybitAPI.log(`Active symbol changed to ${symbol}`, 'info');
    }

    // Ex√©cution d'un trade
    async executeTrade(side, quantity, orderType = 'Market', price = null) {
        try {
            const result = await this.bybitAPI.placeOrder(
                this.activeSymbol,
                side,
                orderType,
                quantity,
                price
            );
            
            // Notification de succ√®s
            if (typeof showNotification === 'function') {
                showNotification(`Ordre ${side} ex√©cut√© avec succ√®s`, 'success');
            }
            
            return result;
        } catch (error) {
            // Notification d'erreur
            if (typeof showNotification === 'function') {
                showNotification(`Erreur lors de l'ex√©cution: ${error.message}`, 'error');
            }
            throw error;
        }
    }

    // Fermeture de toutes les positions
    async closeAllPositions() {
        try {
            const positions = await this.bybitAPI.getPositions();
            const openPositions = positions.list.filter(p => parseFloat(p.size) !== 0);
            
            for (const position of openPositions) {
                await this.bybitAPI.closePosition(position.symbol, position.side);
            }
            
            if (typeof showNotification === 'function') {
                showNotification('Toutes les positions ferm√©es', 'success');
            }
        } catch (error) {
            if (typeof showNotification === 'function') {
                showNotification(`Erreur fermeture positions: ${error.message}`, 'error');
            }
            throw error;
        }
    }

    // Arr√™t propre
    shutdown() {
        this.stopMonitoring();
        this.bybitAPI.disconnect();
        this.isInitialized = false;
        this.bybitAPI.log('API Manager shut down', 'info');
    }
}

// Instance globale de l'API Manager
const apiManager = new APIManager();

// === FONCTIONS D'INT√âGRATION AVEC L'INTERFACE ===

// Fonction d'initialisation √† appeler depuis l'interface
async function initializeAPI(apiKey, apiSecret, isTestnet = true) {
    return await apiManager.initialize(apiKey, apiSecret, isTestnet);
}

// Fonctions de trading √† appeler depuis l'interface
async function buyMarket(quantity) {
    return await apiManager.executeTrade('Buy', quantity, 'Market');
}

async function sellMarket(quantity) {
    return await apiManager.executeTrade('Sell', quantity, 'Market');
}

async function buyLimit(quantity, price) {
    return await apiManager.executeTrade('Buy', quantity, 'Limit', price);
}

async function sellLimit(quantity, price) {
    return await apiManager.executeTrade('Sell', quantity, 'Limit', price);
}

// Export des classes pour utilisation modulaire
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { BybitAPI, APIManager, apiManager };
}

# Module 3 

// SLM TRADE - Module 3: Int√©gration TradingView Compl√®te
// Graphiques professionnels avec indicateurs techniques avanc√©s

class TradingViewManager {
    constructor() {
        this.widget = null;
        this.activeSymbol = 'BYBIT:BTCUSDT';
        this.indicators = new Map();
        this.patterns = [];
        this.alerts = [];
        this.chartData = [];
        this.timeframe = '15';
        
        this.init();
    }

    async init() {
        await this.loadTradingViewLibrary();
        this.createChart();
        this.setupIndicators();
        this.initializePatternDetection();
        console.log('üìä TradingView Module initialis√©');
    }

    async loadTradingViewLibrary() {
        return new Promise((resolve) => {
            if (window.TradingView) {
                resolve();
                return;
            }

            const script = document.createElement('script');
            script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
            script.async = true;
            script.onload = resolve;
            document.head.appendChild(script);
        });
    }

    createChart() {
        const chartContainer = document.getElementById('tradingview-chart') || this.createChartContainer();
        
        // Configuration avanc√©e du widget TradingView
        this.widget = new TradingView.widget({
            "autosize": true,
            "symbol": this.activeSymbol,
            "interval": this.timeframe,
            "timezone": "Europe/Paris",
            "theme": "dark",
            "style": "1",
            "locale": "fr",
            "toolbar_bg": "#1a1a1a",
            "enable_publishing": false,
            "hide_top_toolbar": false,
            "hide_legend": false,
            "save_image": false,
            "container_id": "tradingview-chart",
            "studies": [
                "RSI@tv-basicstudies",
                "MACD@tv-basicstudies",
                "BB@tv-basicstudies",
                "Volume@tv-basicstudies"
            ],
            "overrides": {
                "paneProperties.background": "#0d1421",
                "paneProperties.vertGridProperties.color": "#1e293b",
                "paneProperties.horzGridProperties.color": "#1e293b",
                "symbolWatermarkProperties.transparency": 90,
                "scalesProperties.textColor": "#64748b",
                "mainSeriesProperties.candleStyle.upColor": "#22c55e",
                "mainSeriesProperties.candleStyle.downColor": "#ef4444",
                "mainSeriesProperties.candleStyle.borderUpColor": "#22c55e",
                "mainSeriesProperties.candleStyle.borderDownColor": "#ef4444",
            },
            "studies_overrides": {
                "volume.volume.color.0": "#ef444480",
                "volume.volume.color.1": "#22c55e80",
                "RSI.RSI.color": "#3b82f6",
                "MACD.MACD.color": "#8b5cf6",
                "MACD.signal.color": "#f59e0b",
                "Bollinger Bands.median.color": "#64748b",
                "Bollinger Bands.upper.color": "#f59e0b",
                "Bollinger Bands.lower.color": "#f59e0b"
            }
        });

        this.widget.onChartReady(() => {
            console.log('üìà Graphique TradingView charg√©');
            this.setupRealtimeData();
            this.addCustomIndicators();
        });
    }

    createChartContainer() {
        const container = document.createElement('div');
        container.id = 'tradingview-chart';
        container.style.cssText = `
            height: 600px;
            width: 100%;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            border-radius: 12px;
            border: 1px solid #334155;
            margin: 10px 0;
        `;
        
        // Ins√©rer dans l'interface principale
        const dashboardContent = document.querySelector('.dashboard-content') || document.body;
        dashboardContent.appendChild(container);
        return container;
    }

    setupRealtimeData() {
        // Connexion aux donn√©es temps r√©el via WebSocket Bybit
        if (window.bybitAPI) {
            // Abonnement aux donn√©es de prix
            window.bybitAPI.subscribeToTicker(this.activeSymbol.split(':')[1], (data) => {
                this.updateChartData(data);
            });

            // Abonnement aux donn√©es de profondeur
            window.bybitAPI.subscribeToOrderbook(this.activeSymbol.split(':')[1], (data) => {
                this.updateOrderbookAnalysis(data);
            });
        }
    }

    addCustomIndicators() {
        // Indicateur SLM personnalis√©
        this.addSLMIndicator();
        
        // Indicateur de Force du Trend
        this.addTrendStrengthIndicator();
        
        // Indicateur de Support/R√©sistance automatique
        this.addSupportResistanceIndicator();
        
        // Volume Profile
        this.addVolumeProfileIndicator();
    }

    addSLMIndicator() {
        const slmStudy = {
            name: "SLM Signal",
            metainfo: {
                _metainfoVersion: 51,
                id: "SLM_Signal@tv-basicstudies",
                description: "SLM Trading Signal",
                shortDescription: "SLM",
                format: {
                    type: "price",
                    precision: 4
                },
                plots: [{
                    id: "signal",
                    type: "line"
                }],
                defaults: {
                    styles: {
                        signal: {
                            linestyle: 0,
                            linewidth: 2,
                            plottype: 1,
                            trackPrice: false,
                            transparency: 0,
                            color: "#00d4ff"
                        }
                    }
                },
                styles: {
                    signal: {
                        title: "SLM Signal",
                        histogramBase: 0
                    }
                },
                inputs: []
            },
            constructor: function() {
                this.main = function(context, inputCallback) {
                    this._context = context;
                    this._input = inputCallback;
                    
                    const close = this._input(0);
                    const high = this._input(1);
                    const low = this._input(2);
                    const volume = this._input(3);
                    
                    // Calcul SLM personnalis√©
                    const slmValue = this.calculateSLM(close, high, low, volume);
                    return [slmValue];
                };
                
                this.calculateSLM = function(close, high, low, volume) {
                    // Algorithme SLM propri√©taire
                    const hl2 = (high + low) / 2;
                    const hlc3 = (high + low + close) / 3;
                    const volumeWeight = Math.log(volume) / 10;
                    
                    return hlc3 * (1 + volumeWeight * 0.1);
                };
            }
        };

        this.indicators.set('SLM', slmStudy);
    }

    addTrendStrengthIndicator() {
        // Force du trend bas√© sur ADX am√©lior√©
        const trendStrength = {
            calculate: (highs, lows, closes, period = 14) => {
                const tr = [];
                const plusDM = [];
                const minusDM = [];
                
                for (let i = 1; i < closes.length; i++) {
                    const high = highs[i];
                    const low = lows[i];
                    const close = closes[i];
                    const prevHigh = highs[i-1];
                    const prevLow = lows[i-1];
                    const prevClose = closes[i-1];
                    
                    // True Range
                    tr.push(Math.max(
                        high - low,
                        Math.abs(high - prevClose),
                        Math.abs(low - prevClose)
                    ));
                    
                    // Directional Movement
                    const highDiff = high - prevHigh;
                    const lowDiff = prevLow - low;
                    
                    plusDM.push(highDiff > lowDiff && highDiff > 0 ? highDiff : 0);
                    minusDM.push(lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0);
                }
                
                // Calcul ADX am√©lior√©
                return this.calculateEnhancedADX(tr, plusDM, minusDM, period);
            }
        };
        
        this.indicators.set('TrendStrength', trendStrength);
    }

    addSupportResistanceIndicator() {
        const srLevels = {
            calculate: (highs, lows, closes, lookback = 20, minTouches = 3) => {
                const levels = [];
                
                for (let i = lookback; i < closes.length - lookback; i++) {
                    // Recherche des pivots
                    const isHighPivot = this.isPivotHigh(highs, i, lookback);
                    const isLowPivot = this.isPivotLow(lows, i, lookback);
                    
                    if (isHighPivot) {
                        const level = {
                            price: highs[i],
                            type: 'resistance',
                            strength: this.calculateLevelStrength(highs, lows, closes, highs[i], minTouches),
                            index: i
                        };
                        if (level.strength >= minTouches) levels.push(level);
                    }
                    
                    if (isLowPivot) {
                        const level = {
                            price: lows[i],
                            type: 'support',
                            strength: this.calculateLevelStrength(highs, lows, closes, lows[i], minTouches),
                            index: i
                        };
                        if (level.strength >= minTouches) levels.push(level);
                    }
                }
                
                return levels.sort((a, b) => b.strength - a.strength);
            }
        };
        
        this.indicators.set('SupportResistance', srLevels);
    }

    addVolumeProfileIndicator() {
        const volumeProfile = {
            calculate: (highs, lows, volumes, bins = 50) => {
                const profile = [];
                const priceRange = Math.max(...highs) - Math.min(...lows);
                const binSize = priceRange / bins;
                const minPrice = Math.min(...lows);
                
                // Initialiser les bins
                for (let i = 0; i < bins; i++) {
                    profile.push({
                        price: minPrice + (i * binSize),
                        volume: 0,
                        buyVolume: 0,
                        sellVolume: 0
                    });
                }
                
                // Distribuer les volumes
                for (let i = 0; i < highs.length; i++) {
                    const high = highs[i];
                    const low = lows[i];
                    const volume = volumes[i];
                    const avgPrice = (high + low) / 2;
                    
                    const binIndex = Math.floor((avgPrice - minPrice) / binSize);
                    if (binIndex >= 0 && binIndex < bins) {
                        profile[binIndex].volume += volume;
                        // Estimation buy/sell bas√©e sur la position dans la bougie
                        const closePercent = (closes[i] - low) / (high - low);
                        profile[binIndex].buyVolume += volume * closePercent;
                        profile[binIndex].sellVolume += volume * (1 - closePercent);
                    }
                }
                
                return profile;
            }
        };
        
        this.indicators.set('VolumeProfile', volumeProfile);
    }

    detectPatterns(ohlcData) {
        const patterns = [];
        
        // D√©tection de patterns de chandeliers
        patterns.push(...this.detectCandlestickPatterns(ohlcData));
        
        // D√©tection de patterns techniques
        patterns.push(...this.detectTechnicalPatterns(ohlcData));
        
        // D√©tection de patterns harmoniques
        patterns.push(...this.detectHarmonicPatterns(ohlcData));
        
        return patterns;
    }

    detectCandlestickPatterns(data) {
        const patterns = [];
        
        for (let i = 2; i < data.length; i++) {
            const current = data[i];
            const prev = data[i-1];
            const prev2 = data[i-2];
            
            // Doji
            if (this.isDoji(current)) {
                patterns.push({
                    name: 'Doji',
                    type: 'reversal',
                    reliability: 0.6,
                    index: i,
                    signal: 'indecision'
                });
            }
            
            // Hammer / Hanging Man
            const hammerResult = this.isHammer(current, prev);
            if (hammerResult) {
                patterns.push({
                    name: hammerResult.name,
                    type: 'reversal',
                    reliability: 0.7,
                    index: i,
                    signal: hammerResult.signal
                });
            }
            
            // Engulfing Pattern
            const engulfing = this.isEngulfing(current, prev);
            if (engulfing) {
                patterns.push({
                    name: engulfing.name,
                    type: 'reversal',
                    reliability: 0.8,
                    index: i,
                    signal: engulfing.signal
                });
            }
            
            // Three White Soldiers / Three Black Crows
            const threePattern = this.isThreePattern(current, prev, prev2);
            if (threePattern) {
                patterns.push({
                    name: threePattern.name,
                    type: 'continuation',
                    reliability: 0.85,
                    index: i,
                    signal: threePattern.signal
                });
            }
        }
        
        return patterns;
    }

    detectTechnicalPatterns(data) {
        const patterns = [];
        
        // Head and Shoulders
        const headShoulders = this.detectHeadAndShoulders(data);
        patterns.push(...headShoulders);
        
        // Double Top/Bottom
        const doubles = this.detectDoubleTopBottom(data);
        patterns.push(...doubles);
        
        // Triangle Patterns
        const triangles = this.detectTriangles(data);
        patterns.push(...triangles);
        
        // Flag and Pennant
        const flags = this.detectFlagsAndPennants(data);
        patterns.push(...flags);
        
        return patterns;
    }

    detectHarmonicPatterns(data) {
        const patterns = [];
        
        // Gartley Pattern
        const gartley = this.detectGartley(data);
        patterns.push(...gartley);
        
        // Butterfly Pattern
        const butterfly = this.detectButterfly(data);
        patterns.push(...butterfly);
        
        // Bat Pattern
        const bat = this.detectBat(data);
        patterns.push(...bat);
        
        // Crab Pattern
        const crab = this.detectCrab(data);
        patterns.push(...crab);
        
        return patterns;
    }

    // M√©thodes utilitaires pour la d√©tection de patterns
    isDoji(candle) {
        const bodySize = Math.abs(candle.close - candle.open);
        const totalRange = candle.high - candle.low;
        return bodySize / totalRange < 0.1;
    }

    isHammer(candle, prevCandle) {
        const bodySize = Math.abs(candle.close - candle.open);
        const lowerShadow = Math.min(candle.open, candle.close) - candle.low;
        const upperShadow = candle.high - Math.max(candle.open, candle.close);
        const totalRange = candle.high - candle.low;
        
        if (lowerShadow > bodySize * 2 && upperShadow < bodySize * 0.5) {
            const trend = this.getTrend(prevCandle);
            if (trend === 'down') {
                return { name: 'Hammer', signal: 'bullish' };
            } else if (trend === 'up') {
                return { name: 'Hanging Man', signal: 'bearish' };
            }
        }
        return null;
    }

    isEngulfing(current, prev) {
        const currentBull = current.close > current.open;
        const prevBull = prev.close > prev.open;
        
        if (currentBull && !prevBull) {
            // Bullish Engulfing
            if (current.open < prev.close && current.close > prev.open) {
                return { name: 'Bullish Engulfing', signal: 'bullish' };
            }
        } else if (!currentBull && prevBull) {
            // Bearish Engulfing
            if (current.open > prev.close && current.close < prev.open) {
                return { name: 'Bearish Engulfing', signal: 'bearish' };
            }
        }
        return null;
    }

    createPatternAlert(pattern) {
        const alert = {
            id: Date.now(),
            timestamp: new Date(),
            pattern: pattern.name,
            signal: pattern.signal,
            reliability: pattern.reliability,
            price: this.getCurrentPrice(),
            message: `Pattern ${pattern.name} d√©tect√© - Signal ${pattern.signal}`,
            type: pattern.reliability > 0.7 ? 'high' : 'medium'
        };
        
        this.alerts.push(alert);
        this.showPatternNotification(alert);
        
        // Callback vers l'interface principale
        if (window.updatePatternDetection) {
            window.updatePatternDetection(pattern, alert);
        }
        
        return alert;
    }

    showPatternNotification(alert) {
        // Cr√©er une notification toast
        const notification = document.createElement('div');
        notification.className = `pattern-notification ${alert.type}`;
        notification.innerHTML = `
            <div class="notification-icon">üìä</div>
            <div class="notification-content">
                <div class="notification-title">Pattern D√©tect√©</div>
                <div class="notification-message">${alert.message}</div>
                <div class="notification-time">${alert.timestamp.toLocaleTimeString()}</div>
            </div>
        `;
        
        // Styles
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.3);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease-out;
            max-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        // Suppression automatique apr√®s 5 secondes
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    }

    // M√©thodes d'analyse technique avanc√©e
    calculateRSI(closes, period = 14) {
        const gains = [];
        const losses = [];
        
        for (let i = 1; i < closes.length; i++) {
            const change = closes[i] - closes[i-1];
            gains.push(change > 0 ? change : 0);
            losses.push(change < 0 ? Math.abs(change) : 0);
        }
        
        const avgGain = gains.slice(-period).reduce((a, b) => a + b) / period;
        const avgLoss = losses.slice(-period).reduce((a, b) => a + b) / period;
        
        if (avgLoss === 0) return 100;
        
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }

    calculateMACD(closes, fast = 12, slow = 26, signal = 9) {
        const emaFast = this.calculateEMA(closes, fast);
        const emaSlow = this.calculateEMA(closes, slow);
        
        const macdLine = emaFast.map((fast, i) => fast - emaSlow[i]);
        const signalLine = this.calculateEMA(macdLine, signal);
        const histogram = macdLine.map((macd, i) => macd - signalLine[i]);
        
        return {
            macd: macdLine,
            signal: signalLine,
            histogram: histogram
        };
    }

    calculateEMA(data, period) {
        const ema = [];
        const multiplier = 2 / (period + 1);
        
        ema[0] = data[0];
        
        for (let i = 1; i < data.length; i++) {
            ema[i] = (data[i] * multiplier) + (ema[i-1] * (1 - multiplier));
        }
        
        return ema;
    }

    calculateBollingerBands(closes, period = 20, stdDev = 2) {
        const sma = this.calculateSMA(closes, period);
        const bands = {
            upper: [],
            middle: sma,
            lower: []
        };
        
        for (let i = period - 1; i < closes.length; i++) {
            const slice = closes.slice(i - period + 1, i + 1);
            const mean = sma[i];
            const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
            const standardDeviation = Math.sqrt(variance);
            
            bands.upper[i] = mean + (standardDeviation * stdDev);
            bands.lower[i] = mean - (standardDeviation * stdDev);
        }
        
        return bands;
    }

    calculateSMA(data, period) {
        const sma = [];
        
        for (let i = period - 1; i < data.length; i++) {
            const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b);
            sma[i] = sum / period;
        }
        
        return sma;
    }

    // Interface de contr√¥le
    changeSymbol(symbol) {
        this.activeSymbol = symbol;
        if (this.widget) {
            this.widget.setSymbol(symbol, () => {
                console.log(`üìä Symbole chang√© vers: ${symbol}`);
                this.setupRealtimeData();
            });
        }
    }

    changeTimeframe(timeframe) {
        this.timeframe = timeframe;
        if (this.widget) {
            this.widget.chart().setResolution(timeframe, () => {
                console.log(`‚è±Ô∏è Timeframe chang√© vers: ${timeframe}`);
            });
        }
    }

    addIndicator(indicatorName, params = {}) {
        if (this.widget && this.widget.chart) {
            this.widget.chart().createStudy(indicatorName, false, false, params);
            console.log(`üìà Indicateur ajout√©: ${indicatorName}`);
        }
    }

    removeIndicator(indicatorId) {
        if (this.widget && this.widget.chart) {
            this.widget.chart().removeEntity(indicatorId);
            console.log(`‚ùå Indicateur supprim√©: ${indicatorId}`);
        }
    }

    takeScreenshot() {
        if (this.widget && this.widget.chart) {
            this.widget.chart().takeScreenshot();
            console.log('üì∏ Capture d\'√©cran du graphique prise');
        }
    }

    exportData() {
        const exportData = {
            symbol: this.activeSymbol,
            timeframe: this.timeframe,
            indicators: Array.from(this.indicators.keys()),
            patterns: this.patterns,
            alerts: this.alerts,
            timestamp: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `slm-trade-analysis-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        console.log('üíæ Donn√©es d\'analyse export√©es');
    }

    // M√©thodes utilitaires
    getCurrentPrice() {
        return this.chartData.length > 0 ? this.chartData[this.chartData.length - 1].close : 0;
    }

    getTrend(candle, period = 10) {
        // Logique simplifi√©e pour d√©tecter la tendance
        if (candle.close > candle.open) return 'up';
        if (candle.close < candle.open) return 'down';
        return 'neutral';
    }

    isPivotHigh(highs, index, lookback) {
        const currentHigh = highs[index];
        for (let i = index - lookback; i <= index + lookback; i++) {
            if (i !== index && i >= 0 && i < highs.length) {
                if (highs[i] >= currentHigh) return false;
            }
        }
        return true;
    }

    isPivotLow(lows, index, lookback) {
        const currentLow = lows[index];
        for (let i = index - lookback; i <= index + lookback; i++) {
            if (i !== index && i >= 0 && i < lows.length) {
                if (lows[i] <= currentLow) return false;
            }
        }
        return true;
    }

    calculateLevelStrength(highs, lows, closes, level, tolerance = 0.001) {
        let touches = 0;
        const toleranceAmount = level * tolerance;
        
        for (let i = 0; i < closes.length; i++) {
            if (Math.abs(highs[i] - level) <= toleranceAmount ||
                Math.abs(lows[i] - level) <= toleranceAmount ||
                Math.abs(closes[i] - level) <= toleranceAmount) {
                touches++;
            }
        }
        
        return touches;
    }

    // Interface de gestion des alertes
    createAlert(condition, message, type = 'info') {
        const alert = {
            id: Date.now(),
            condition: condition,
            message: message,
            type: type,
            active: true,
            triggered: false,
            createdAt: new Date()
        };
        
        this.alerts.push(alert);
        return alert;
    }

    checkAlerts() {
        const currentPrice = this.getCurrentPrice();
        
        this.alerts.filter(alert => alert.active && !alert.triggered).forEach(alert => {
            if (this.evaluateAlertCondition(alert.condition, currentPrice)) {
                alert.triggered = true;
                this.triggerAlert(alert);
            }
        });
    }

    evaluateAlertCondition(condition, currentPrice) {
        // √âvaluation simple des conditions d'alerte
        try {
            return eval(condition.replace('PRICE', currentPrice));
        } catch (error) {
            console.error('Erreur dans la condition d\'alerte:', error);
            return false;
        }
    }

    triggerAlert(alert) {
        console.log(`üö® Alerte d√©clench√©e: ${alert.message}`);
        this.showPatternNotification({
            type: alert.type,
            message: alert.message,
            timestamp: new Date()
        });
        
        // Callback vers l'interface principale
        if (window.onAlertTriggered) {
            window.onAlertTriggered(alert);
        }
    }
}

// Initialisation automatique
let tradingViewManager;

document.addEventListener('DOMContentLoaded', () => {
    tradingViewManager = new TradingViewManager();
});

// Fonctions d'interface globales
window.changeTradingSymbol = (symbol) => {
    if (tradingViewManager) {
        tradingViewManager.changeSymbol(symbol);
    }
};

window.changeTradingTimeframe = (timeframe) => {
    if (tradingViewManager) {
        tradingViewManager.changeTimeframe(timeframe);
    }
};

window.addTradingIndicator = (indicator, params) => {
    if (tradingViewManager) {
        tradingViewManager.addIndicator(indicator, params);
    }
};

window.exportTradingData = () => {
    if (tradingViewManager) {
        tradingViewManager.exportData();
    }
};

window.createTradingAlert = (condition, message, type) => {
    if (tradingViewManager) {
        return tradingViewManager.createAlert(condition, message, type);
    }
};

// Styles CSS pour les notifications
const notificationStyles = document.createElement('style');
notificationStyles.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
    
    .pattern-notification {
        font-family: 'Inter', sans-serif;
    }
    
    .pattern-notification.high {
        border-color: #22c55e;
        box-shadow: 0 10px 30px rgba(34, 197, 94, 0.3);
    }
    
    .pattern-notification.medium {
        border-color: #f59e0b;
        box-shadow: 0 10px 30px rgba(245, 158, 11, 0.3);
    }
    
    .notification-icon {
        font-size: 24px;
        flex-shrink: 0;
    }
    
    .notification-content {
        flex-grow: 1;
    }
    
    .notification-title {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 4px;
    }
    
    .notification-message {
        font-size: 12px;
        opacity: 0.8;
        margin-bottom: 2px;
    }
    
    .notification-time {
        font-size: 10px;
        opacity: 0.6;
    }
`;

document.head.appendChild(notificationStyles);

// Extension pour l'analyse de sentiment et flux d'ordres
class MarketSentimentAnalyzer {
    constructor() {
        this.orderFlow = [];
        this.sentimentScore = 0;
        this.volumeAnalysis = {
            buyPressure: 0,
            sellPressure: 0,
            netFlow: 0
        };
        this.init();
    }

    init() {
        this.startOrderFlowAnalysis();
        this.initializeSentimentTracking();
        console.log('üìä Analyseur de sentiment de march√© initialis√©');
    }

    startOrderFlowAnalysis() {
        // Analyse du flux d'ordres en temps r√©el
        if (window.bybitAPI) {
            window.bybitAPI.subscribeToTrades('BTCUSDT', (trade) => {
                this.analyzeOrderFlow(trade);
            });
        }
    }

    analyzeOrderFlow(trade) {
        const orderFlowData = {
            timestamp: trade.timestamp,
            price: parseFloat(trade.price),
            size: parseFloat(trade.size),
            side: trade.side, // 'Buy' or 'Sell'
            isBlockTrade: parseFloat(trade.size) > this.getAverageTradeSize() * 5
        };

        this.orderFlow.unshift(orderFlowData);
        
        // Garder seulement les 1000 derniers trades
        if (this.orderFlow.length > 1000) {
            this.orderFlow = this.orderFlow.slice(0, 1000);
        }

        this.updateVolumeAnalysis();
        this.calculateSentimentScore();
        this.detectLargeOrders(orderFlowData);
    }

    updateVolumeAnalysis() {
        const recentTrades = this.orderFlow.slice(0, 100); // 100 derniers trades
        
        let buyVolume = 0;
        let sellVolume = 0;
        
        recentTrades.forEach(trade => {
            if (trade.side === 'Buy') {
                buyVolume += trade.size;
            } else {
                sellVolume += trade.size;
            }
        });
        
        this.volumeAnalysis = {
            buyPressure: buyVolume,
            sellPressure: sellVolume,
            netFlow: buyVolume - sellVolume,
            dominance: buyVolume > sellVolume ? 'buyers' : 'sellers',
            ratio: sellVolume > 0 ? (buyVolume / sellVolume).toFixed(2) : 'N/A'
        };
    }

    calculateSentimentScore() {
        if (this.orderFlow.length < 50) return;
        
        const recentTrades = this.orderFlow.slice(0, 100);
        let score = 0;
        let weightedScore = 0;
        let totalWeight = 0;
        
        recentTrades.forEach((trade, index) => {
            const weight = Math.exp(-index * 0.05); // Poids d√©croissant
            const tradeScore = trade.side === 'Buy' ? 1 : -1;
            const sizeMultiplier = Math.log(trade.size + 1);
            
            weightedScore += tradeScore * weight * sizeMultiplier;
            totalWeight += weight * sizeMultiplier;
        });
        
        this.sentimentScore = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 0;
        
        // Callback vers l'interface
        if (window.updateSentimentDisplay) {
            window.updateSentimentDisplay(this.sentimentScore, this.volumeAnalysis);
        }
    }

    detectLargeOrders(trade) {
        if (trade.isBlockTrade) {
            const alert = {
                type: 'large_order',
                timestamp: new Date(),
                message: `Ordre important d√©tect√©: ${trade.side} ${trade.size} √† ${trade.price}`,
                trade: trade
            };
            
            this.showLargeOrderAlert(alert);
            
            // Log pour analyse
            console.log('üêã Ordre important d√©tect√©:', trade);
        }
    }

    showLargeOrderAlert(alert) {
        const notification = document.createElement('div');
        notification.className = 'large-order-notification';
        notification.innerHTML = `
            <div class="notification-icon">üêã</div>
            <div class="notification-content">
                <div class="notification-title">Ordre Important</div>
                <div class="notification-message">${alert.message}</div>
                <div class="notification-time">${alert.timestamp.toLocaleTimeString()}</div>
            </div>
        `;
        
        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            border: 1px solid #8b5cf6;
            border-radius: 8px;
            padding: 15px;
            color: #ffffff;
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideInRight 0.3s ease-out;
            max-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        }, 7000);
    }

    getAverageTradeSize() {
        if (this.orderFlow.length === 0) return 1;
        
        const total = this.orderFlow.reduce((sum, trade) => sum + trade.size, 0);
        return total / this.orderFlow.length;
    }

    getSentimentSummary() {
        return {
            score: this.sentimentScore,
            interpretation: this.interpretSentiment(this.sentimentScore),
            volumeAnalysis: this.volumeAnalysis,
            recentActivity: this.getRecentActivity(),
            marketPressure: this.getMarketPressure()
        };
    }

    interpretSentiment(score) {
        if (score > 50) return 'Tr√®s Haussier';
        if (score > 20) return 'Haussier';
        if (score > -20) return 'Neutre';
        if (score > -50) return 'Baissier';
        return 'Tr√®s Baissier';
    }

    getRecentActivity() {
        const recent = this.orderFlow.slice(0, 20);
        return {
            averageSize: recent.reduce((sum, t) => sum + t.size, 0) / recent.length,
            priceMovement: recent.length > 1 ? recent[0].price - recent[recent.length - 1].price : 0,
            frequency: recent.length
        };
    }

    getMarketPressure() {
        const ratio = this.volumeAnalysis.ratio;
        if (ratio === 'N/A') return 'Ind√©termin√©';
        
        const r = parseFloat(ratio);
        if (r > 2) return 'Forte pression acheteuse';
        if (r > 1.5) return 'Pression acheteuse mod√©r√©e';
        if (r > 0.67) return '√âquilibr√©';
        if (r > 0.5) return 'Pression vendeuse mod√©r√©e';
        return 'Forte pression vendeuse';
    }
}

// Gestionnaire d'alertes avanc√©es
class AdvancedAlertManager {
    constructor() {
        this.alerts = new Map();
        this.alertHistory = [];
        this.alertTypes = {
            PRICE: 'price',
            VOLUME: 'volume',
            PATTERN: 'pattern',
            INDICATOR: 'indicator',
            SENTIMENT: 'sentiment',
            ORDER_FLOW: 'order_flow'
        };
        this.init();
    }

    init() {
        this.setupDefaultAlerts();
        this.startAlertMonitoring();
        console.log('üö® Gestionnaire d\'alertes avanc√©es initialis√©');
    }

    setupDefaultAlerts() {
        // Alertes de prix par d√©faut
        this.createAlert({
            name: 'Support cass√©',
            type: this.alertTypes.PRICE,
            condition: 'PRICE < SUPPORT_LEVEL',
            message: 'Le prix a cass√© le niveau de support',
            priority: 'high',
            autoTrade: false
        });

        this.createAlert({
            name: 'R√©sistance franchie',
            type: this.alertTypes.PRICE,
            condition: 'PRICE > RESISTANCE_LEVEL',
            message: 'Le prix a franchi le niveau de r√©sistance',
            priority: 'high',
            autoTrade: false
        });

        // Alertes de volume
        this.createAlert({
            name: 'Volume anormal',
            type: this.alertTypes.VOLUME,
            condition: 'VOLUME > AVERAGE_VOLUME * 3',
            message: 'Volume anormalement √©lev√© d√©tect√©',
            priority: 'medium',
            autoTrade: false
        });
    }

    createAlert(alertConfig) {
        const alert = {
            id: Date.now() + Math.random(),
            ...alertConfig,
            created: new Date(),
            triggered: false,
            triggerCount: 0,
            lastTriggered: null,
            active: true
        };

        this.alerts.set(alert.id, alert);
        return alert;
    }

    startAlertMonitoring() {
        setInterval(() => {
            this.checkAllAlerts();
        }, 1000); // V√©rification chaque seconde
    }

    checkAllAlerts() {
        const currentData = this.getCurrentMarketData();
        
        this.alerts.forEach(alert => {
            if (alert.active && this.shouldCheckAlert(alert)) {
                if (this.evaluateAlertCondition(alert, currentData)) {
                    this.triggerAlert(alert, currentData);
                }
            }
        });
    }

    shouldCheckAlert(alert) {
        // √âviter les alertes trop fr√©quentes
        if (alert.lastTriggered) {
            const timeSinceLastTrigger = Date.now() - alert.lastTriggered.getTime();
            const cooldownPeriod = this.getCooldownPeriod(alert.priority);
            return timeSinceLastTrigger > cooldownPeriod;
        }
        return true;
    }

    getCooldownPeriod(priority) {
        switch (priority) {
            case 'high': return 30000; // 30 secondes
            case 'medium': return 60000; // 1 minute
            case 'low': return 300000; // 5 minutes
            default: return 60000;
        }
    }

    evaluateAlertCondition(alert, marketData) {
        try {
            let condition = alert.condition;
            
            // Remplacer les variables par les valeurs r√©elles
            condition = condition.replace(/PRICE/g, marketData.price);
            condition = condition.replace(/VOLUME/g, marketData.volume);
            condition = condition.replace(/RSI/g, marketData.rsi || 50);
            condition = condition.replace(/MACD/g, marketData.macd || 0);
            condition = condition.replace(/SUPPORT_LEVEL/g, marketData.supportLevel || 0);
            condition = condition.replace(/RESISTANCE_LEVEL/g, marketData.resistanceLevel || 999999);
            condition = condition.replace(/AVERAGE_VOLUME/g, marketData.averageVolume || 1000);
            
            return eval(condition);
        } catch (error) {
            console.error('Erreur √©valuation alerte:', error);
            return false;
        }
    }

    triggerAlert(alert, marketData) {
        alert.triggered = true;
        alert.triggerCount++;
        alert.lastTriggered = new Date();

        const alertEvent = {
            alert: alert,
            marketData: marketData,
            timestamp: new Date()
        };

        this.alertHistory.unshift(alertEvent);
        
        // Garder seulement les 100 derni√®res alertes
        if (this.alertHistory.length > 100) {
            this.alertHistory = this.alertHistory.slice(0, 100);
        }

        this.showAlert(alertEvent);
        this.logAlert(alertEvent);

        // Auto-trading si activ√©
        if (alert.autoTrade && window.executeAutoTrade) {
            window.executeAutoTrade(alert, marketData);
        }

        // Callback vers l'interface
        if (window.onAdvancedAlert) {
            window.onAdvancedAlert(alertEvent);
        }
    }

    showAlert(alertEvent) {
        const { alert, marketData } = alertEvent;
        
        const notification = document.createElement('div');
        notification.className = `advanced-alert ${alert.priority}`;
        notification.innerHTML = `
            <div class="alert-icon">${this.getAlertIcon(alert.type)}</div>
            <div class="alert-content">
                <div class="alert-title">${alert.name}</div>
                <div class="alert-message">${alert.message}</div>
                <div class="alert-details">Prix: ${marketData.price} | Vol: ${marketData.volume}</div>
                <div class="alert-time">${alertEvent.timestamp.toLocaleTimeString()}</div>
            </div>
            <div class="alert-actions">
                <button onclick="window.dismissAlert('${alert.id}')" class="dismiss-btn">√ó</button>
            </div>
        `;
        
        const colors = {
            high: '#ef4444',
            medium: '#f59e0b',
            low: '#10b981'
        };
        
        notification.style.cssText = `
            position: fixed;
            top: ${20 + (this.getActiveNotifications() * 90)}px;
            right: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid ${colors[alert.priority]};
            border-radius: 12px;
            padding: 16px;
            color: #ffffff;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: slideInRight 0.4s ease-out;
            max-width: 350px;
            min-width: 300px;
        `;
        
        document.body.appendChild(notification);
        
        // Auto-suppression bas√©e sur la priorit√©
        const autoRemoveTime = alert.priority === 'high' ? 10000 : 
                              alert.priority === 'medium' ? 7000 : 5000;
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutRight 0.4s ease-in';
                setTimeout(() => notification.remove(), 400);
            }
        }, autoRemoveTime);
    }

    getAlertIcon(type) {
        const icons = {
            [this.alertTypes.PRICE]: 'üí∞',
            [this.alertTypes.VOLUME]: 'üìä',
            [this.alertTypes.PATTERN]: 'üìà',
            [this.alertTypes.INDICATOR]: '‚ö°',
            [this.alertTypes.SENTIMENT]: 'üé≠',
            [this.alertTypes.ORDER_FLOW]: 'üåä'
        };
        return icons[type] || 'üö®';
    }

    getActiveNotifications() {
        return document.querySelectorAll('.advanced-alert').length;
    }

    getCurrentMarketData() {
        // R√©cup√©ration des donn√©es de march√© actuelles
        return {
            price: window.tradingViewManager ? window.tradingViewManager.getCurrentPrice() : 50000,
            volume: Math.random() * 1000 + 500, // Simul√© pour l'exemple
            rsi: Math.random() * 100,
            macd: (Math.random() - 0.5) * 2,
            supportLevel: 48000,
            resistanceLevel: 52000,
            averageVolume: 750,
            timestamp: new Date()
        };
    }

    logAlert(alertEvent) {
        console.log(`üö® ALERTE [${alertEvent.alert.priority.toUpperCase()}]: ${alertEvent.alert.name}`, {
            message: alertEvent.alert.message,
            price: alertEvent.marketData.price,
            time: alertEvent.timestamp.toLocaleString()
        });
    }

    // Interface de gestion des alertes
    getAlertById(id) {
        return this.alerts.get(id);
    }

    updateAlert(id, updates) {
        const alert = this.alerts.get(id);
        if (alert) {
            Object.assign(alert, updates);
            return alert;
        }
        return null;
    }

    deleteAlert(id) {
        return this.alerts.delete(id);
    }

    toggleAlert(id) {
        const alert = this.alerts.get(id);
        if (alert) {
            alert.active = !alert.active;
            return alert;
        }
        return null;
    }

    getAlertHistory(limit = 50) {
        return this.alertHistory.slice(0, limit);
    }

    getAlertStatistics() {
        const total = this.alerts.size;
        const active = Array.from(this.alerts.values()).filter(a => a.active).length;
        const triggered = Array.from(this.alerts.values()).filter(a => a.triggered).length;
        
        return {
            total,
            active,
            inactive: total - active,
            triggered,
            triggerRate: total > 0 ? (triggered / total * 100).toFixed(1) + '%' : '0%',
            recentTriggers: this.alertHistory.slice(0, 10)
        };
    }
}

// Initialisation des modules √©tendus
let marketSentimentAnalyzer;
let advancedAlertManager;

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        marketSentimentAnalyzer = new MarketSentimentAnalyzer();
        advancedAlertManager = new AdvancedAlertManager();
    }, 2000);
});

// Fonctions globales pour l'interface
window.dismissAlert = (alertId) => {
    const notifications = document.querySelectorAll('.advanced-alert');
    notifications.forEach(notification => {
        if (notification.innerHTML.includes(alertId)) {
            notification.remove();
        }
    });
};

window.getSentimentAnalysis = () => {
    return marketSentimentAnalyzer ? marketSentimentAnalyzer.getSentimentSummary() : null;
};

window.createCustomAlert = (config) => {
    return advancedAlertManager ? advancedAlertManager.createAlert(config) : null;
};

window.getAlertStatistics = () => {
    return advancedAlertManager ? advancedAlertManager.getAlertStatistics() : null;
};

# Module 4

"""
SLM TRADE - Module 4: Strat√©gies de Trading Algorithmiques & IA
================================================================

Ce module impl√©mente des strat√©gies de trading avanc√©es avec:
- Machine Learning pour la pr√©diction de prix
- Backtesting sophistiqu√© avec m√©triques d√©taill√©es
- Optimisation automatique des param√®tres
- Signaux multi-timeframes
- Ex√©cution automatique des trades
- Strat√©gies adaptatives bas√©es sur l'IA

Auteur: Assistant IA
Version: 4.0
"""

import pandas as pd
import numpy as np
import yfinance as yf
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import ta
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class SLMAlgorithmicTrader:
    """
    Syst√®me de trading algorithmique avanc√© avec IA
    """
    
    def __init__(self):
        self.strategies = {}
        self.models = {}
        self.scalers = {}
        self.backtest_results = {}
        self.active_positions = {}
        self.performance_metrics = {}
        
    def fetch_data(self, symbol, period="2y", interval="1d"):
        """R√©cup√®re les donn√©es de march√©"""
        try:
            ticker = yf.Ticker(symbol)
            data = ticker.history(period=period, interval=interval)
            
            if data.empty:
                print(f"‚ùå Aucune donn√©e trouv√©e pour {symbol}")
                return None
                
            # Calcul des indicateurs techniques
            data = self.calculate_technical_indicators(data)
            print(f"‚úÖ Donn√©es r√©cup√©r√©es pour {symbol}: {len(data)} barres")
            return data
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es: {e}")
            return None
    
    def calculate_technical_indicators(self, data):
        """Calcule tous les indicateurs techniques n√©cessaires"""
        # Moyennes mobiles
        data['SMA_20'] = ta.trend.sma_indicator(data['Close'], window=20)
        data['SMA_50'] = ta.trend.sma_indicator(data['Close'], window=50)
        data['EMA_12'] = ta.trend.ema_indicator(data['Close'], window=12)
        data['EMA_26'] = ta.trend.ema_indicator(data['Close'], window=26)
        
        # MACD
        data['MACD'] = ta.trend.macd_diff(data['Close'])
        data['MACD_signal'] = ta.trend.macd_signal(data['Close'])
        
        # RSI
        data['RSI'] = ta.momentum.rsi(data['Close'])
        
        # Bollinger Bands
        data['BB_upper'] = ta.volatility.bollinger_hband(data['Close'])
        data['BB_lower'] = ta.volatility.bollinger_lband(data['Close'])
        data['BB_middle'] = ta.volatility.bollinger_mavg(data['Close'])
        
        # Stochastic
        data['Stoch_K'] = ta.momentum.stoch(data['High'], data['Low'], data['Close'])
        data['Stoch_D'] = ta.momentum.stoch_signal(data['High'], data['Low'], data['Close'])
        
        # ATR
        data['ATR'] = ta.volatility.average_true_range(data['High'], data['Low'], data['Close'])
        
        # Volume indicators
        data['Volume_SMA'] = data['Volume'].rolling(window=20).mean()
        data['OBV'] = ta.volume.on_balance_volume(data['Close'], data['Volume'])
        
        # Momentum
        data['ROC'] = ta.momentum.roc(data['Close'], window=12)
        data['Williams_R'] = ta.momentum.williams_r(data['High'], data['Low'], data['Close'])
        
        # Volatilit√©
        data['Close_returns'] = data['Close'].pct_change()
        data['Volatility'] = data['Close_returns'].rolling(window=20).std()
        
        return data
    
    def prepare_ml_features(self, data):
        """Pr√©pare les features pour le machine learning"""
        features = []
        
        # Features techniques
        feature_columns = [
            'SMA_20', 'SMA_50', 'EMA_12', 'EMA_26', 'MACD', 'MACD_signal',
            'RSI', 'BB_upper', 'BB_lower', 'Stoch_K', 'Stoch_D', 'ATR',
            'Volume_SMA', 'OBV', 'ROC', 'Williams_R', 'Volatility'
        ]
        
        # Ratios et relations
        data['Price_to_SMA20'] = data['Close'] / data['SMA_20']
        data['Price_to_SMA50'] = data['Close'] / data['SMA_50']
        data['BB_position'] = (data['Close'] - data['BB_lower']) / (data['BB_upper'] - data['BB_lower'])
        data['Volume_ratio'] = data['Volume'] / data['Volume_SMA']
        
        feature_columns.extend(['Price_to_SMA20', 'Price_to_SMA50', 'BB_position', 'Volume_ratio'])
        
        # Features de lag
        for col in ['Close', 'Volume', 'RSI', 'MACD']:
            for lag in [1, 2, 3, 5]:
                data[f'{col}_lag_{lag}'] = data[col].shift(lag)
                feature_columns.append(f'{col}_lag_{lag}')
        
        # Target: rendement futur
        data['Future_return'] = data['Close'].shift(-1) / data['Close'] - 1
        
        # Nettoyage des NaN
        data_clean = data[feature_columns + ['Future_return']].dropna()
        
        return data_clean[feature_columns], data_clean['Future_return']
    
    def train_ml_models(self, symbol, data):
        """Entra√Æne les mod√®les de machine learning"""
        print(f"\nü§ñ Entra√Ænement des mod√®les ML pour {symbol}...")
        
        X, y = self.prepare_ml_features(data)
        
        if len(X) < 100:
            print("‚ùå Pas assez de donn√©es pour l'entra√Ænement ML")
            return False
        
        # Division train/test
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
        
        # Normalisation
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
        
        self.scalers[symbol] = scaler
        
        # Mod√®les
        models = {
            'RandomForest': RandomForestRegressor(n_estimators=100, random_state=42),
            'GradientBoosting': GradientBoostingRegressor(n_estimators=100, random_state=42),
            'LinearRegression': LinearRegression()
        }
        
        self.models[symbol] = {}
        model_scores = {}
        
        for name, model in models.items():
            if name == 'LinearRegression':
                model.fit(X_train_scaled, y_train)
                y_pred = model.predict(X_test_scaled)
            else:
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)
            
            score = r2_score(y_test, y_pred)
            mse = mean_squared_error(y_test, y_pred)
            
            self.models[symbol][name] = model
            model_scores[name] = {'R2': score, 'MSE': mse}
            
            print(f"  {name}: R¬≤ = {score:.4f}, MSE = {mse:.6f}")
        
        # S√©lection du meilleur mod√®le
        best_model = max(model_scores.keys(), key=lambda x: model_scores[x]['R2'])
        print(f"‚úÖ Meilleur mod√®le: {best_model}")
        
        return True
    
    def get_ml_signal(self, symbol, current_data):
        """Obtient un signal de trading bas√© sur ML"""
        if symbol not in self.models or not self.models[symbol]:
            return 0, 0.5  # Signal neutre si pas de mod√®le
        
        try:
            # Pr√©paration des features actuelles
            X_current, _ = self.prepare_ml_features(current_data.tail(100))
            
            if len(X_current) == 0:
                return 0, 0.5
            
            X_latest = X_current.iloc[-1:].values
            
            # Pr√©dictions de tous les mod√®les
            predictions = []
            for name, model in self.models[symbol].items():
                if name == 'LinearRegression':
                    X_scaled = self.scalers[symbol].transform(X_latest)
                    pred = model.predict(X_scaled)[0]
                else:
                    pred = model.predict(X_latest)[0]
                predictions.append(pred)
            
            # Pr√©diction moyenne
            avg_prediction = np.mean(predictions)
            confidence = 1 - np.std(predictions)  # Confiance bas√©e sur consensus
            
            # Signal bas√© sur la pr√©diction
            if avg_prediction > 0.005:  # +0.5%
                signal = 1  # Achat
            elif avg_prediction < -0.005:  # -0.5%
                signal = -1  # Vente
            else:
                signal = 0  # Neutre
            
            return signal, min(max(confidence, 0), 1)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur ML signal: {e}")
            return 0, 0.5
    
    def multi_timeframe_analysis(self, symbol):
        """Analyse multi-timeframes"""
        timeframes = {
            '1h': {'period': '30d', 'interval': '1h', 'weight': 0.2},
            '4h': {'period': '60d', 'interval': '4h', 'weight': 0.3},
            '1d': {'period': '1y', 'interval': '1d', 'weight': 0.5}
        }
        
        signals = {}
        
        for tf, params in timeframes.items():
            data = self.fetch_data(symbol, params['period'], params['interval'])
            if data is not None and len(data) > 50:
                signal = self.get_combined_signal(data)
                signals[tf] = {
                    'signal': signal['signal'],
                    'strength': signal['strength'],
                    'weight': params['weight']
                }
        
        if not signals:
            return {'signal': 0, 'strength': 0.5, 'timeframes': {}}
        
        # Signal pond√©r√©
        weighted_signal = sum(s['signal'] * s['weight'] for s in signals.values())
        weighted_strength = sum(s['strength'] * s['weight'] for s in signals.values())
        
        final_signal = 1 if weighted_signal > 0.3 else (-1 if weighted_signal < -0.3 else 0)
        
        return {
            'signal': final_signal,
            'strength': weighted_strength,
            'timeframes': signals,
            'weighted_signal': weighted_signal
        }
    
    def get_combined_signal(self, data):
        """Combine plusieurs signaux pour une d√©cision finale"""
        if len(data) < 50:
            return {'signal': 0, 'strength': 0.5}
        
        signals = []
        current = data.iloc[-1]
        prev = data.iloc[-2]
        
        # Signal 1: Croisement moyennes mobiles
        if current['SMA_20'] > current['SMA_50'] and prev['SMA_20'] <= prev['SMA_50']:
            signals.append(1)  # Golden cross
        elif current['SMA_20'] < current['SMA_50'] and prev['SMA_20'] >= prev['SMA_50']:
            signals.append(-1)  # Death cross
        
        # Signal 2: RSI
        if current['RSI'] < 30:
            signals.append(1)  # Survente
        elif current['RSI'] > 70:
            signals.append(-1)  # Surachat
        
        # Signal 3: MACD
        if current['MACD'] > current['MACD_signal'] and prev['MACD'] <= prev['MACD_signal']:
            signals.append(1)  # Croisement haussier
        elif current['MACD'] < current['MACD_signal'] and prev['MACD'] >= prev['MACD_signal']:
            signals.append(-1)  # Croisement baissier
        
        # Signal 4: Bollinger Bands
        if current['Close'] < current['BB_lower']:
            signals.append(1)  # Rebond potentiel
        elif current['Close'] > current['BB_upper']:
            signals.append(-1)  # Correction potentielle
        
        # Signal 5: Stochastic
        if current['Stoch_K'] < 20 and current['Stoch_K'] > current['Stoch_D']:
            signals.append(1)
        elif current['Stoch_K'] > 80 and current['Stoch_K'] < current['Stoch_D']:
            signals.append(-1)
        
        if not signals:
            return {'signal': 0, 'strength': 0.5}
        
        # Calcul du signal final
        avg_signal = np.mean(signals)
        strength = abs(avg_signal)
        
        final_signal = 1 if avg_signal > 0.2 else (-1 if avg_signal < -0.2 else 0)
        
        return {'signal': final_signal, 'strength': min(strength, 1.0)}
    
    def backtest_strategy(self, symbol, data, strategy_name="Combined", 
                         initial_capital=10000, commission=0.001):
        """Backtesting complet d'une strat√©gie"""
        print(f"\nüìä Backtesting de la strat√©gie {strategy_name} pour {symbol}")
        
        if len(data) < 100:
            print("‚ùå Pas assez de donn√©es pour le backtesting")
            return None
        
        # Initialisation
        capital = initial_capital
        position = 0  # 0: neutre, 1: long, -1: short
        entry_price = 0
        trades = []
        equity_curve = []
        
        for i in range(50, len(data)):
            current_data = data.iloc[:i+1]
            current_row = data.iloc[i]
            
            # Obtenir le signal
            signal_data = self.get_combined_signal(current_data)
            signal = signal_data['signal']
            strength = signal_data['strength']
            
            date = current_row.name
            price = current_row['Close']
            
            # Gestion des positions
            if position == 0 and signal != 0 and strength > 0.6:
                # Entr√©e en position
                position = signal
                entry_price = price
                trade_capital = capital * 0.95  # 95% du capital
                shares = trade_capital / price
                commission_cost = trade_capital * commission
                capital -= commission_cost
                
                trades.append({
                    'date': date,
                    'type': 'ENTRY',
                    'signal': signal,
                    'price': price,
                    'shares': shares,
                    'capital': capital,
                    'strength': strength
                })
                
            elif position != 0:
                # Gestion de la sortie
                exit_signal = False
                
                # Stop loss et take profit
                if position == 1:  # Position longue
                    pnl_pct = (price - entry_price) / entry_price
                    if pnl_pct <= -0.05 or pnl_pct >= 0.15:  # -5% stop loss, +15% take profit
                        exit_signal = True
                    elif signal == -1 and strength > 0.6:  # Signal contraire fort
                        exit_signal = True
                        
                elif position == -1:  # Position courte
                    pnl_pct = (entry_price - price) / entry_price
                    if pnl_pct <= -0.05 or pnl_pct >= 0.15:
                        exit_signal = True
                    elif signal == 1 and strength > 0.6:
                        exit_signal = True
                
                if exit_signal:
                    # Sortie de position
                    trade_value = shares * price
                    commission_cost = trade_value * commission
                    capital = trade_value - commission_cost
                    
                    pnl = capital - initial_capital if len(trades) == 1 else capital - trades[-1]['capital']
                    
                    trades.append({
                        'date': date,
                        'type': 'EXIT',
                        'signal': -position,
                        'price': price,
                        'shares': shares,
                        'capital': capital,
                        'pnl': pnl,
                        'pnl_pct': pnl / entry_price if entry_price > 0 else 0
                    })
                    
                    position = 0
                    entry_price = 0
            
            # Courbe de capital
            if position == 0:
                current_capital = capital
            else:
                current_value = shares * price
                current_capital = current_value - (shares * entry_price - capital)
            
            equity_curve.append({
                'date': date,
                'equity': current_capital,
                'price': price
            })
        
        # Calcul des m√©triques de performance
        if len(trades) < 2:
            print("‚ùå Pas assez de trades pour l'analyse")
            return None
        
        metrics = self.calculate_performance_metrics(trades, equity_curve, initial_capital)
        
        self.backtest_results[f"{symbol}_{strategy_name}"] = {
            'trades': trades,
            'equity_curve': equity_curve,
            'metrics': metrics
        }
        
        self.print_backtest_results(symbol, strategy_name, metrics)
        return metrics
    
    def calculate_performance_metrics(self, trades, equity_curve, initial_capital):
        """Calcule les m√©triques de performance d√©taill√©es"""
        # Extraction des PnL
        completed_trades = [t for t in trades if t['type'] == 'EXIT']
        
        if not completed_trades:
            return {}
        
        pnls = [trade['pnl'] for trade in completed_trades]
        
        # M√©triques de base
        total_trades = len(completed_trades)
        winning_trades = len([p for p in pnls if p > 0])
        losing_trades = len([p for p in pnls if p < 0])
        
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_return = (equity_curve[-1]['equity'] - initial_capital) / initial_capital
        avg_return_per_trade = np.mean(pnls) / initial_capital if pnls else 0
        
        # Drawdown
        peak = initial_capital
        max_drawdown = 0
        drawdowns = []
        
        for point in equity_curve:
            if point['equity'] > peak:
                peak = point['equity']
            drawdown = (peak - point['equity']) / peak
            drawdowns.append(drawdown)
            if drawdown > max_drawdown:
                max_drawdown = drawdown
        
        # Ratio de Sharpe (approximatif)
        if len(pnls) > 1:
            returns_std = np.std(pnls) / initial_capital
            sharpe_ratio = avg_return_per_trade / returns_std if returns_std > 0 else 0
        else:
            sharpe_ratio = 0
        
        # Profit factor
        gross_profit = sum([p for p in pnls if p > 0])
        gross_loss = abs(sum([p for p in pnls if p < 0]))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        return {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': losing_trades,
            'win_rate': win_rate,
            'total_return': total_return,
            'total_return_pct': total_return * 100,
            'avg_return_per_trade': avg_return_per_trade,
            'max_drawdown': max_drawdown,
            'max_drawdown_pct': max_drawdown * 100,
            'sharpe_ratio': sharpe_ratio,
            'profit_factor': profit_factor,
            'gross_profit': gross_profit,
            'gross_loss': gross_loss,
            'final_capital': equity_curve[-1]['equity']
        }
    
    def print_backtest_results(self, symbol, strategy, metrics):
        """Affiche les r√©sultats du backtesting"""
        print(f"\n{'='*60}")
        print(f"üìà R√âSULTATS BACKTESTING - {symbol} ({strategy})")
        print(f"{'='*60}")
        
        print(f"üí∞ Performance Globale:")
        print(f"   Rendement Total: {metrics['total_return_pct']:.2f}%")
        print(f"   Capital Final: ${metrics['final_capital']:,.2f}")
        print(f"   Drawdown Max: {metrics['max_drawdown_pct']:.2f}%")
        
        print(f"\nüìä Statistiques de Trading:")
        print(f"   Nombre de Trades: {metrics['total_trades']}")
        print(f"   Trades Gagnants: {metrics['winning_trades']}")
        print(f"   Trades Perdants: {metrics['losing_trades']}")
        print(f"   Taux de R√©ussite: {metrics['win_rate']*100:.1f}%")
        
        print(f"\nüìè M√©triques de Risque:")
        print(f"   Ratio de Sharpe: {metrics['sharpe_ratio']:.2f}")
        print(f"   Profit Factor: {metrics['profit_factor']:.2f}")
        print(f"   Profit Brut: ${metrics['gross_profit']:,.2f}")
        print(f"   Perte Brute: ${metrics['gross_loss']:,.2f}")
    
    def optimize_strategy_parameters(self, symbol, data):
        """Optimise automatiquement les param√®tres de strat√©gie"""
        print(f"\nüîß Optimisation des param√®tres pour {symbol}...")
        
        # Param√®tres √† optimiser
        rsi_thresholds = [(20, 80), (25, 75), (30, 70)]
        sma_periods = [(10, 30), (20, 50), (15, 45)]
        stop_loss_levels = [0.03, 0.05, 0.07]  # 3%, 5%, 7%
        take_profit_levels = [0.10, 0.15, 0.20]  # 10%, 15%, 20%
        
        best_params = None
        best_performance = -float('inf')
        
        optimization_results = []
        
        for rsi_low, rsi_high in rsi_thresholds:
            for sma_short, sma_long in sma_periods:
                for stop_loss in stop_loss_levels:
                    for take_profit in take_profit_levels:
                        
                        # Simulation avec ces param√®tres
                        performance = self.simulate_with_parameters(
                            data, rsi_low, rsi_high, sma_short, sma_long, 
                            stop_loss, take_profit
                        )
                        
                        optimization_results.append({
                            'params': {
                                'rsi_low': rsi_low,
                                'rsi_high': rsi_high,
                                'sma_short': sma_short,
                                'sma_long': sma_long,
                                'stop_loss': stop_loss,
                                'take_profit': take_profit
                            },
                            'performance': performance,
                            'score': performance.get('total_return', 0) - performance.get('max_drawdown', 1)
                        })
        
        # S√©lection des meilleurs param√®tres
        if optimization_results:
            best_result = max(optimization_results, key=lambda x: x['score'])
            best_params = best_result['params']
            best_performance = best_result['performance']
            
            print(f"‚úÖ Meilleurs param√®tres trouv√©s:")
            for param, value in best_params.items():
                print(f"   {param}: {value}")
            print(f"   Score: {best_result['score']:.4f}")
            print(f"   Rendement: {best_performance.get('total_return_pct', 0):.2f}%")
        
        return best_params, optimization_results
    
    def simulate_with_parameters(self, data, rsi_low, rsi_high, sma_short, sma_long, 
                                stop_loss, take_profit, initial_capital=10000):
        """Simule une strat√©gie avec des param√®tres sp√©cifiques"""
        if len(data) < max(sma_long, 50):
            return {'total_return': -1, 'max_drawdown': 1}
        
        # Recalcul des indicateurs avec nouveaux param√®tres
        data_copy = data.copy()
        data_copy[f'SMA_{sma_short}'] = ta.trend.sma_indicator(data_copy['Close'], window=sma_short)
        data_copy[f'SMA_{sma_long}'] = ta.trend.sma_indicator(data_copy['Close'], window=sma_long)
        
        capital = initial_capital
        position = 0
        entry_price = 0
        equity_curve = []
        
        for i in range(sma_long, len(data_copy)):
            current = data_copy.iloc[i]
            prev = data_copy.iloc[i-1]
            
            price = current['Close']
            
            # Signaux avec param√®tres optimis√©s
            signal = 0
            
            # Croisement moyennes mobiles
            if (current[f'SMA_{sma_short}'] > current[f'SMA_{sma_long}'] and 
                prev[f'SMA_{sma_short}'] <= prev[f'SMA_{sma_long}']):
                signal = 1
            elif (current[f'SMA_{sma_short}'] < current[f'SMA_{sma_long}'] and 
                  prev[f'SMA_{sma_short}'] >= prev[f'SMA_{sma_long}']):
                signal = -1
            
            # Confirmation RSI
            if signal == 1 and current['RSI'] > rsi_high:
                signal = 0  # Pas d'achat si surachat
            elif signal == -1 and current['RSI'] < rsi_low:
                signal = 0  # Pas de vente si survente
            
            # Gestion des positions
            if position == 0 and signal != 0:
                position = signal
                entry_price = price
                shares = capital * 0.95 / price
                
            elif position != 0:
                pnl_pct = (price - entry_price) / entry_price * position
                
                if pnl_pct <= -stop_loss or pnl_pct >= take_profit or signal == -position:
                    capital = shares * price * 0.999  # Commission
                    position = 0
                    entry_price = 0
            
            # √âquit√© courante
            if position == 0:
                current_equity = capital
            else:
                current_equity = shares * price * 0.999
            
            equity_curve.append(current_equity)
        
        if not equity_curve:
            return {'total_return': -1, 'max_drawdown': 1}
        
        # Calcul des m√©triques simplifi√©es
        final_equity = equity_curve[-1]
        total_return = (final_equity - initial_capital) / initial_capital
        
        # Drawdown
        peak = initial_capital
        max_drawdown = 0
        for equity in equity_curve:
            if equity > peak:
                peak = equity
            drawdown = (peak - equity) / peak
            if drawdown > max_drawdown:
                max_drawdown = drawdown
        
        return {
            'total_return': total_return,
            'total_return_pct': total_return * 100,
            'max_drawdown': max_drawdown,
            'final_equity': final_equity
        }
    
    def generate_trading_report(self, symbol):
        """G√©n√®re un rapport de trading complet"""
        print(f"\nüìã RAPPORT DE TRADING COMPLET - {symbol}")
        print("="*70)
        
        # Analyse multi-timeframes
        mtf_analysis = self.multi_timeframe_analysis(symbol)
        
        print(f"\nüîç ANALYSE MULTI-TIMEFRAMES:")
        print(f"Signal Global: {self.signal_to_text(mtf_analysis['signal'])}")
        print(f"Force du Signal: {mtf_analysis['strength']:.2f}")
        print(f"Score Pond√©r√©: {mtf_analysis.get('weighted_signal', 0):.2f}")
        
        for tf, data in mtf_analysis.get('timeframes', {}).items():
            print(f"  {tf}: {self.signal_to_text(data['signal'])} (Force: {data['strength']:.2f})")
        
        # Analyse ML si disponible
        if symbol in self.models and self.models[symbol]:
            daily_data = self.fetch_data(symbol, period="1y", interval="1d")
            if daily_data is not None:
                ml_signal, ml_confidence = self.get_ml_signal(symbol, daily_data)
                print(f"\nü§ñ ANALYSE MACHINE LEARNING:")
                print(f"Signal ML: {self.signal_to_text(ml_signal)}")
                print(f"Confiance: {ml_confidence:.2f}")
                
                # Pr√©dictions individuelles des mod√®les
                X, _ = self.prepare_ml_features(daily_data.tail(100))
                if len(X) > 0:
                    X_latest = X.iloc[-1:].values
                    print(f"Pr√©dictions des mod√®les:")
                    for name, model in self.models[symbol].items():
                        try:
                            if name == 'LinearRegression':
                                X_scaled = self.scalers[symbol].transform(X_latest)
                                pred = model.predict(X_scaled)[0]
                            else:
                                pred = model.predict(X_latest)[0]
                            print(f"  {name}: {pred*100:.2f}% de rendement pr√©dit")
                        except:
                            pass
        
        # Recommandations finales
        print(f"\nüí° RECOMMANDATIONS:")
        overall_signal = mtf_analysis['signal']
        overall_strength = mtf_analysis['strength']
        
        if overall_signal == 1 and overall_strength > 0.7:
            print("üü¢ FORTE RECOMMANDATION D'ACHAT")
            print("   - Signaux haussiers convergents sur plusieurs timeframes")
            print("   - Niveau de confiance √©lev√©")
        elif overall_signal == 1 and overall_strength > 0.5:
            print("üü° RECOMMANDATION D'ACHAT MOD√âR√âE")
            print("   - Signaux haussiers pr√©sents mais force mod√©r√©e")
            print("   - Surveiller les confirmations")
        elif overall_signal == -1 and overall_strength > 0.7:
            print("üî¥ FORTE RECOMMANDATION DE VENTE")
            print("   - Signaux baissiers convergents")
            print("   - Risque de correction important")
        elif overall_signal == -1 and overall_strength > 0.5:
            print("üü° RECOMMANDATION DE VENTE MOD√âR√âE")
            print("   - Signaux baissiers pr√©sents")
            print("   - Prudence recommand√©e")
        else:
            print("‚ö™ POSITION NEUTRE")
            print("   - Signaux mixtes ou faibles")
            print("   - Attendre des signaux plus clairs")
        
        return {
            'symbol': symbol,
            'multi_timeframe': mtf_analysis,
            'ml_analysis': {'signal': ml_signal, 'confidence': ml_confidence} if symbol in self.models else None,
            'recommendation': overall_signal,
            'strength': overall_strength
        }
    
    def signal_to_text(self, signal):
        """Convertit un signal num√©rique en texte"""
        if signal == 1:
            return "üü¢ ACHAT"
        elif signal == -1:
            return "üî¥ VENTE"
        else:
            return "‚ö™ NEUTRE"
    
    def auto_trade_execution(self, symbol, signal_data, position_size=0.1):
        """Ex√©cution automatique des trades (simulation)"""
        print(f"\nüöÄ EX√âCUTION AUTOMATIQUE - {symbol}")
        
        signal = signal_data['signal']
        strength = signal_data['strength']
        
        if signal == 0 or strength < 0.6:
            print("‚ùå Signal trop faible pour l'ex√©cution automatique")
            return False
        
        # R√©cup√©ration du prix actuel
        current_data = self.fetch_data(symbol, period="5d", interval="1h")
        if current_data is None or len(current_data) == 0:
            print("‚ùå Impossible de r√©cup√©rer le prix actuel")
            return False
        
        current_price = current_data['Close'].iloc[-1]
        
        # Calcul de la taille de position
        risk_per_trade = 0.02  # 2% du capital par trade
        stop_loss_pct = 0.05  # Stop loss √† 5%
        
        # Simulation d'ex√©cution
        if symbol not in self.active_positions:
            self.active_positions[symbol] = []
        
        trade = {
            'timestamp': datetime.now(),
            'signal': signal,
            'entry_price': current_price,
            'position_size': position_size,
            'stop_loss': current_price * (1 - stop_loss_pct) if signal == 1 else current_price * (1 + stop_loss_pct),
            'take_profit': current_price * (1 + 0.15) if signal == 1 else current_price * (1 - 0.15),
            'strength': strength,
            'status': 'ACTIVE'
        }
        
        self.active_positions[symbol].append(trade)
        
        print(f"‚úÖ Trade ex√©cut√©:")
        print(f"   Signal: {self.signal_to_text(signal)}")
        print(f"   Prix d'entr√©e: ${current_price:.2f}")
        print(f"   Stop Loss: ${trade['stop_loss']:.2f}")
        print(f"   Take Profit: ${trade['take_profit']:.2f}")
        print(f"   Force du signal: {strength:.2f}")
        
        return True
    
    def monitor_active_positions(self):
        """Surveillance des positions actives"""
        if not self.active_positions:
            print("üìä Aucune position active √† surveiller")
            return
        
        print(f"\nüëÅÔ∏è SURVEILLANCE DES POSITIONS ACTIVES")
        print("="*50)
        
        for symbol, positions in self.active_positions.items():
            active_positions = [p for p in positions if p['status'] == 'ACTIVE']
            
            if not active_positions:
                continue
                
            print(f"\nüìà {symbol}:")
            
            # Prix actuel
            current_data = self.fetch_data(symbol, period="2d", interval="1h")
            if current_data is None:
                continue
                
            current_price = current_data['Close'].iloc[-1]
            
            for i, position in enumerate(active_positions):
                entry_price = position['entry_price']
                signal = position['signal']
                
                # Calcul du PnL
                if signal == 1:  # Position longue
                    pnl_pct = (current_price - entry_price) / entry_price * 100
                else:  # Position courte
                    pnl_pct = (entry_price - current_price) / entry_price * 100
                
                pnl_color = "üü¢" if pnl_pct > 0 else "üî¥"
                
                print(f"  Position #{i+1}:")
                print(f"    Signal: {self.signal_to_text(signal)}")
                print(f"    Prix d'entr√©e: ${entry_price:.2f}")
                print(f"    Prix actuel: ${current_price:.2f}")
                print(f"    PnL: {pnl_color} {pnl_pct:+.2f}%")
                print(f"    Stop Loss: ${position['stop_loss']:.2f}")
                print(f"    Take Profit: ${position['take_profit']:.2f}")
                
                # V√©rification des conditions de sortie
                if signal == 1:  # Position longue
                    if current_price <= position['stop_loss']:
                        print(f"    ‚ö†Ô∏è STOP LOSS ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'STOP_LOSS'
                    elif current_price >= position['take_profit']:
                        print(f"    üéØ TAKE PROFIT ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'TAKE_PROFIT'
                else:  # Position courte
                    if current_price >= position['stop_loss']:
                        print(f"    ‚ö†Ô∏è STOP LOSS ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'STOP_LOSS'
                    elif current_price <= position['take_profit']:
                        print(f"    üéØ TAKE PROFIT ATTEINT!")
                        position['status'] = 'CLOSED'
                        position['exit_reason'] = 'TAKE_PROFIT'
                
                print()
    
    def run_complete_analysis(self, symbol):
        """Lance une analyse compl√®te avec toutes les fonctionnalit√©s"""
        print(f"\nüéØ ANALYSE COMPL√àTE - {symbol}")
        print("="*60)
        
        # 1. R√©cup√©ration des donn√©es
        data = self.fetch_data(symbol, period="2y", interval="1d")
        if data is None:
            return None
        
        # 2. Entra√Ænement des mod√®les ML
        ml_success = self.train_ml_models(symbol, data)
        
        # 3. Backtesting
        backtest_results = self.backtest_strategy(symbol, data)
        
        # 4. Optimisation des param√®tres
        if len(data) > 200:  # Seulement si assez de donn√©es
            best_params, optimization_results = self.optimize_strategy_parameters(symbol, data)
        
        # 5. Rapport de trading
        trading_report = self.generate_trading_report(symbol)
        
        # 6. Recommandation finale
        final_recommendation = self.get_final_recommendation(symbol, trading_report, backtest_results)
        
        return {
            'symbol': symbol,
            'ml_trained': ml_success,
            'backtest': backtest_results,
            'trading_report': trading_report,
            'recommendation': final_recommendation
        }
    
    def get_final_recommendation(self, symbol, trading_report, backtest_results):
        """Formule une recommandation finale bas√©e sur toutes les analyses"""
        print(f"\nüéØ RECOMMANDATION FINALE - {symbol}")
        print("="*50)
        
        score = 0
        factors = []
        
        # Facteur 1: Signal multi-timeframes
        mtf_signal = trading_report['multi_timeframe']['signal']
        mtf_strength = trading_report['multi_timeframe']['strength']
        
        if mtf_signal == 1 and mtf_strength > 0.7:
            score += 3
            factors.append("‚úÖ Signaux haussiers forts multi-timeframes")
        elif mtf_signal == 1 and mtf_strength > 0.5:
            score += 1
            factors.append("üü° Signaux haussiers mod√©r√©s")
        elif mtf_signal == -1 and mtf_strength > 0.7:
            score -= 3
            factors.append("‚ùå Signaux baissiers forts")
        elif mtf_signal == -1 and mtf_strength > 0.5:
            score -= 1
            factors.append("üü° Signaux baissiers mod√©r√©s")
        
        # Facteur 2: Performance du backtesting
        if backtest_results:
            win_rate = backtest_results.get('win_rate', 0)
            total_return = backtest_results.get('total_return', 0)
            max_drawdown = backtest_results.get('max_drawdown', 1)
            
            if win_rate > 0.6 and total_return > 0.15 and max_drawdown < 0.15:
                score += 2
                factors.append("‚úÖ Excellent historique de performance")
            elif win_rate > 0.5 and total_return > 0:
                score += 1
                factors.append("üü° Performance historique correcte")
            else:
                score -= 1
                factors.append("‚ùå Performance historique faible")
        
        # Facteur 3: ML si disponible
        if trading_report.get('ml_analysis'):
            ml_signal = trading_report['ml_analysis']['signal']
            ml_confidence = trading_report['ml_analysis']['confidence']
            
            if ml_signal == mtf_signal and ml_confidence > 0.7:
                score += 1
                factors.append("‚úÖ Confirmation par IA")
            elif ml_signal != mtf_signal:
                score -= 1
                factors.append("‚ö†Ô∏è Divergence avec l'IA")
        
        # Recommandation finale
        if score >= 4:
            recommendation = "FORTE RECOMMANDATION D'ACHAT"
            action = "üü¢ ACHETER"
            risk_level = "Faible √† Mod√©r√©"
        elif score >= 2:
            recommendation = "RECOMMANDATION D'ACHAT"
            action = "üü° ACHETER (avec prudence)"
            risk_level = "Mod√©r√©"
        elif score <= -4:
            recommendation = "FORTE RECOMMANDATION DE VENTE"
            action = "üî¥ VENDRE"
            risk_level = "√âlev√©"
        elif score <= -2:
            recommendation = "RECOMMANDATION DE VENTE"
            action = "üü° VENDRE (avec prudence)"
            risk_level = "Mod√©r√© √† √âlev√©"
        else:
            recommendation = "POSITION NEUTRE"
            action = "‚ö™ ATTENDRE"
            risk_level = "Variable"
        
        print(f"Action Recommand√©e: {action}")
        print(f"Niveau de Risque: {risk_level}")
        print(f"Score Global: {score}/10")
        print(f"\nFacteurs Analys√©s:")
        for factor in factors:
            print(f"  {factor}")
        
        print(f"\nüíº CONSEILS DE GESTION:")
        if score > 0:
            print("  ‚Ä¢ Taille de position recommand√©e: 2-5% du portefeuille")
            print("  ‚Ä¢ Stop loss sugg√©r√©: 5-7% sous le prix d'entr√©e")
            print("  ‚Ä¢ Take profit: 15-20% au-dessus du prix d'entr√©e")
        elif score < 0:
            print("  ‚Ä¢ √âviter les nouvelles positions longues")
            print("  ‚Ä¢ Consid√©rer une position courte si expertise suffisante")
            print("  ‚Ä¢ Surveiller les signaux de retournement")
        else:
            print("  ‚Ä¢ Attendre des signaux plus clairs")
            print("  ‚Ä¢ Surveiller l'√©volution des indicateurs")
            print("  ‚Ä¢ Maintenir la diversification")
        
        return {
            'action': action,
            'recommendation': recommendation,
            'score': score,
            'risk_level': risk_level,
            'factors': factors
        }


# Exemple d'utilisation du syst√®me complet
def demo_slm_algorithmic_trading():
    """D√©monstration du syst√®me de trading algorithmique SLM"""
    print("üöÄ D√âMONSTRATION SLM ALGORITHMIC TRADER")
    print("="*60)
    
    # Initialisation
    trader = SLMAlgorithmicTrader()
    
    # Symboles √† analyser
    symbols = ['AAPL', 'MSFT', 'GOOGL']
    
    print("üìä Analyse en cours des symboles:", symbols)
    print("‚è±Ô∏è Cela peut prendre quelques minutes...")
    
    results = {}
    
    for symbol in symbols:
        print(f"\n{'='*20} {symbol} {'='*20}")
        
        try:
            # Analyse compl√®te
            result = trader.run_complete_analysis(symbol)
            results[symbol] = result
            
            # Simulation d'ex√©cution automatique si signal fort
            if result and result['recommendation']['score'] >= 3:
                trader.auto_trade_execution(symbol, result['trading_report']['multi_timeframe'])
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'analyse de {symbol}: {e}")
            continue
    
    # Surveillance des positions
    trader.monitor_active_positions()
    
    # R√©sum√© final
    print(f"\nüìã R√âSUM√â FINAL")
    print("="*40)
    
    for symbol, result in results.items():
        if result:
            rec = result['recommendation']
            print(f"{symbol}: {rec['action']} (Score: {rec['score']})")
    
    return trader, results


if __name__ == "__main__":
    # D√©monstration
    trader, results = demo_slm_algorithmic_trading()
    
    print("\nüéâ D√©monstration termin√©e!")
    print("\nFonctionnalit√©s impl√©ment√©es:")
    print("‚úÖ Machine Learning multi-mod√®les")
    print("‚úÖ Backtesting complet avec m√©triques")
    print("‚úÖ Optimisation automatique des param√®tres")
    print("‚úÖ Analyse multi-timeframes")
    print("‚úÖ Ex√©cution automatique simul√©e")
    print("‚úÖ Surveillance des positions")
    print("‚úÖ Recommandations bas√©es sur l'IA")
    
    print(f"\nüí° Le Module 4 de SLM TRADE est maintenant op√©rationnel!")
    print("Pr√™t pour l'int√©gration avec les autres modules du syst√®me.")

# Module 5

"""
SLM TRADE - Module 5: Gestion Avanc√©e des Risques
==================================================

Ce module impl√©mente un syst√®me complet de gestion des risques avec:
- Value at Risk (VaR) et Expected Shortfall (ES)
- Position sizing dynamique avec Kelly Criterion
- Gestion de portefeuille multi-actifs
- Corr√©lations et diversification
- Stress testing et Monte Carlo
- Alertes de risque en temps r√©el
- Dashboard de visualisation des risques

Auteur: SLM TRADE System
Version: 5.0
"""

import numpy as np
import pandas as pd
import yfinance as yf
from scipy import stats
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class SLMRiskManager:
    """Gestionnaire de risques avanc√© pour SLM TRADE"""
    
    def __init__(self):
        """Initialisation du gestionnaire de risques"""
        
        # Param√®tres de risque
        self.max_portfolio_var = 0.02  # VaR max 2% du capital
        self.max_position_weight = 0.20  # 20% max par position
        self.confidence_levels = [0.90, 0.95, 0.99]
        self.lookback_days = 252  # 1 an pour calculs historiques
        
        # Capital et portfolio
        self.total_capital = 100000
        self.available_capital = 100000
        self.portfolio_positions = {}
        self.portfolio_weights = {}
        
        # Cache des donn√©es
        self.price_data = {}
        self.returns_data = {}
        self.correlation_matrix = None
        self.last_update = None
        
        print("üõ°Ô∏è SLM Risk Manager initialis√© avec succ√®s!")
    
    def set_capital(self, capital):
        """D√©finir le capital total"""
        self.total_capital = capital
        self.available_capital = capital
        print(f"üí∞ Capital d√©fini: ${capital:,.2f}")
    
    def fetch_risk_data(self, symbols, period="1y"):
        """R√©cup√©ration des donn√©es pour analyse de risque"""
        
        print(f"üìä R√©cup√©ration donn√©es risque pour {len(symbols)} actifs...")
        
        try:
            for symbol in symbols:
                # T√©l√©charger les donn√©es
                ticker = yf.Ticker(symbol)
                data = ticker.history(period=period)
                
                if len(data) > 20:
                    self.price_data[symbol] = data['Close']
                    # Calcul des rendements
                    returns = data['Close'].pct_change().dropna()
                    self.returns_data[symbol] = returns
            
            # Calculer matrice de corr√©lation
            if len(self.returns_data) > 1:
                returns_df = pd.DataFrame(self.returns_data)
                self.correlation_matrix = returns_df.corr()
            
            self.last_update = datetime.now()
            print(f"‚úÖ Donn√©es mises √† jour: {len(self.price_data)} actifs")
            
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration donn√©es: {e}")
    
    def calculate_var(self, returns, confidence_level=0.95, method='historical'):
        """Calcul du Value at Risk (VaR)"""
        
        if len(returns) < 30:
            return 0
        
        if method == 'historical':
            # VaR historique
            var = np.percentile(returns, (1 - confidence_level) * 100)
        
        elif method == 'parametric':
            # VaR param√©trique (distribution normale)
            mean_return = returns.mean()
            std_return = returns.std()
            z_score = stats.norm.ppf(1 - confidence_level)
            var = mean_return + z_score * std_return
        
        elif method == 'monte_carlo':
            # VaR Monte Carlo
            simulated_returns = np.random.normal(
                returns.mean(), returns.std(), 10000
            )
            var = np.percentile(simulated_returns, (1 - confidence_level) * 100)
        
        return abs(var)
    
    def calculate_expected_shortfall(self, returns, confidence_level=0.95):
        """Calcul de l'Expected Shortfall (ES)"""
        
        var = self.calculate_var(returns, confidence_level)
        # ES = moyenne des pertes au-del√† du VaR
        tail_losses = returns[returns <= -var]
        
        if len(tail_losses) > 0:
            es = abs(tail_losses.mean())
        else:
            es = var
        
        return es
    
    def calculate_position_size_kelly(self, symbol, win_prob, avg_win, avg_loss):
        """Position sizing avec Kelly Criterion"""
        
        if avg_loss == 0 or win_prob <= 0:
            return 0
        
        # Formule Kelly: f = (bp - q) / b
        # b = avg_win/avg_loss, p = win_prob, q = 1-win_prob
        b = avg_win / abs(avg_loss)
        p = win_prob
        q = 1 - win_prob
        
        kelly_fraction = (b * p - q) / b
        
        # Limitation √† 25% pour s√©curit√©
        kelly_fraction = max(0, min(kelly_fraction, 0.25))
        
        # Calcul taille position
        position_value = self.available_capital * kelly_fraction
        
        return {
            'kelly_fraction': kelly_fraction,
            'position_value': position_value,
            'recommended_allocation': kelly_fraction * 100
        }
    
    def calculate_optimal_position_size(self, symbol, target_volatility=0.15):
        """Calcul taille position optimale bas√©e sur volatilit√© cible"""
        
        if symbol not in self.returns_data:
            return {'position_value': 0, 'shares': 0, 'weight': 0}
        
        returns = self.returns_data[symbol]
        asset_volatility = returns.std() * np.sqrt(252)  # Volatilit√© annualis√©e
        
        if asset_volatility == 0:
            return {'position_value': 0, 'shares': 0, 'weight': 0}
        
        # Position sizing bas√© sur volatilit√©
        position_weight = target_volatility / asset_volatility
        position_weight = min(position_weight, self.max_position_weight)
        
        position_value = self.available_capital * position_weight
        
        # Calcul nombre d'actions
        if symbol in self.price_data:
            current_price = self.price_data[symbol].iloc[-1]
            shares = int(position_value / current_price)
        else:
            shares = 0
        
        return {
            'position_value': position_value,
            'shares': shares,
            'weight': position_weight,
            'asset_volatility': asset_volatility
        }
    
    def analyze_portfolio_risk(self):
        """Analyse compl√®te du risque portefeuille"""
        
        if not self.portfolio_positions:
            return {"error": "Aucune position dans le portefeuille"}
        
        # Calculs de base
        portfolio_value = sum(self.portfolio_positions.values())
        weights = np.array([pos/portfolio_value for pos in self.portfolio_positions.values()])
        symbols = list(self.portfolio_positions.keys())
        
        # VaR individuel de chaque position
        individual_vars = {}
        for symbol in symbols:
            if symbol in self.returns_data:
                returns = self.returns_data[symbol]
                var_95 = self.calculate_var(returns, 0.95)
                position_var = self.portfolio_positions[symbol] * var_95
                individual_vars[symbol] = position_var
        
        # VaR portefeuille (en tenant compte des corr√©lations)
        portfolio_var = self.calculate_portfolio_var(symbols, weights)
        
        # Expected Shortfall portefeuille
        portfolio_es = portfolio_var * 1.3  # Approximation ES ‚âà 1.3 * VaR
        
        # B√©n√©fice de diversification
        sum_individual_vars = sum(individual_vars.values())
        diversification_benefit = (sum_individual_vars - portfolio_var) / sum_individual_vars if sum_individual_vars > 0 else 0
        
        # Concentration du portefeuille (indice Herfindahl)
        herfindahl_index = sum(w**2 for w in weights)
        effective_positions = 1 / herfindahl_index if herfindahl_index > 0 else 0
        
        return {
            'portfolio_value': portfolio_value,
            'portfolio_var_95': portfolio_var,
            'portfolio_es_95': portfolio_es,
            'var_percentage': (portfolio_var / portfolio_value) * 100,
            'individual_vars': individual_vars,
            'diversification_benefit': diversification_benefit * 100,
            'concentration_index': herfindahl_index,
            'effective_positions': effective_positions,
            'largest_position_weight': max(weights) * 100
        }
    
    def calculate_portfolio_var(self, symbols, weights):
        """Calcul VaR portefeuille avec corr√©lations"""
        
        if len(symbols) < 2 or self.correlation_matrix is None:
            return 0
        
        # Matrice de covariance des rendements
        returns_matrix = pd.DataFrame({symbol: self.returns_data[symbol] 
                                     for symbol in symbols if symbol in self.returns_data})
        
        if returns_matrix.empty:
            return 0
        
        cov_matrix = returns_matrix.cov() * 252  # Annualis√©e
        
        # VaR portefeuille = sqrt(w' * Œ£ * w) * z_score
        portfolio_variance = np.dot(weights, np.dot(cov_matrix, weights))
        portfolio_volatility = np.sqrt(portfolio_variance)
        
        # Z-score pour 95% de confiance
        z_score = stats.norm.ppf(0.95)
        portfolio_var = portfolio_volatility * z_score
        
        return portfolio_var * sum(self.portfolio_positions.values())
    
    def stress_test_portfolio(self, scenarios=None):
        """Tests de stress sur le portefeuille"""
        
        if not scenarios:
            scenarios = {
                'Crash 2008': {'market_drop': -0.37, 'vol_increase': 2.5},
                'COVID Mars 2020': {'market_drop': -0.34, 'vol_increase': 3.0},
                'Dot-com 2000': {'market_drop': -0.49, 'vol_increase': 2.0},
                'Crise personnalis√©e': {'market_drop': -0.25, 'vol_increase': 2.0}
            }
        
        stress_results = {}
        current_portfolio_value = sum(self.portfolio_positions.values())
        
        for scenario_name, params in scenarios.items():
            scenario_loss = 0
            
            for symbol, position_value in self.portfolio_positions.items():
                if symbol in self.returns_data:
                    # Simuler l'impact du sc√©nario
                    base_loss = position_value * abs(params['market_drop'])
                    
                    # Ajuster selon la volatilit√© de l'actif
                    returns = self.returns_data[symbol]
                    asset_vol = returns.std() * np.sqrt(252)
                    vol_adjustment = asset_vol * params['vol_increase']
                    
                    total_loss = base_loss * (1 + vol_adjustment)
                    scenario_loss += total_loss
            
            loss_percentage = (scenario_loss / current_portfolio_value) * 100
            
            stress_results[scenario_name] = {
                'loss_amount': scenario_loss,
                'loss_percentage': loss_percentage,
                'remaining_capital': max(0, current_portfolio_value - scenario_loss)
            }
        
        return stress_results
    
    def generate_risk_alerts(self):
        """G√©n√©ration d'alertes de risque"""
        
        alerts = []
        
        if not self.portfolio_positions:
            return alerts
        
        # Analyse du portefeuille
        risk_analysis = self.analyze_portfolio_risk()
        
        # Alerte VaR d√©pass√©
        if risk_analysis['var_percentage'] > 2.0:
            alerts.append({
                'type': 'HIGH_VAR',
                'severity': 'HIGH',
                'message': f"VaR portefeuille √©lev√©: {risk_analysis['var_percentage']:.1f}% (>2%)",
                'action': 'R√©duire les positions √† risque'
            })
        
        # Alerte concentration
        if risk_analysis['largest_position_weight'] > 25:
            alerts.append({
                'type': 'CONCENTRATION',
                'severity': 'MEDIUM',
                'message': f"Position trop concentr√©e: {risk_analysis['largest_position_weight']:.1f}% (>25%)",
                'action': 'Diversifier le portefeuille'
            })
        
        # Alerte faible diversification
        if risk_analysis['effective_positions'] < 3:
            alerts.append({
                'type': 'LOW_DIVERSIFICATION',
                'severity': 'MEDIUM',
                'message': f"Faible diversification: {risk_analysis['effective_positions']:.1f} positions effectives",
                'action': 'Ajouter des actifs non corr√©l√©s'
            })
        
        # Tests de stress
        stress_results = self.stress_test_portfolio()
        for scenario, result in stress_results.items():
            if result['loss_percentage'] > 30:
                alerts.append({
                    'type': 'STRESS_TEST',
                    'severity': 'HIGH',
                    'message': f"Sc√©nario {scenario}: perte potentielle {result['loss_percentage']:.1f}%",
                    'action': 'Renforcer la couverture'
                })
        
        return alerts
    
    def update_portfolio(self, positions):
        """Mise √† jour du portefeuille"""
        
        self.portfolio_positions = positions.copy()
        total_value = sum(positions.values())
        self.portfolio_weights = {symbol: value/total_value 
                                for symbol, value in positions.items()}
        
        print(f"üìä Portefeuille mis √† jour: {len(positions)} positions, valeur ${total_value:,.2f}")
    
    def optimize_portfolio_allocation(self, expected_returns=None, max_risk=0.15):
        """Optimisation allocation portefeuille (Markowitz)"""
        
        if len(self.returns_data) < 2:
            return {"error": "Donn√©es insuffisantes pour optimisation"}
        
        symbols = list(self.returns_data.keys())
        returns_matrix = pd.DataFrame({symbol: self.returns_data[symbol] 
                                     for symbol in symbols})
        
        # Rendements moyens annualis√©s
        if expected_returns is None:
            expected_returns = returns_matrix.mean() * 252
        
        # Matrice de covariance annualis√©e
        cov_matrix = returns_matrix.cov() * 252
        
        n_assets = len(symbols)
        
        # Fonction objectif: minimiser la variance
        def objective(weights):
            return np.dot(weights, np.dot(cov_matrix, weights))
        
        # Contraintes
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # Somme = 1
        ]
        
        # Bornes (0% √† 30% par actif)
        bounds = [(0, 0.3) for _ in range(n_assets)]
        
        # Poids initiaux √©gaux
        initial_weights = np.array([1/n_assets] * n_assets)
        
        # Optimisation
        try:
            result = minimize(
                objective, 
                initial_weights,
                method='SLSQP',
                bounds=bounds,
                constraints=constraints
            )
            
            if result.success:
                optimal_weights = result.x
                optimal_risk = np.sqrt(objective(optimal_weights))
                optimal_return = np.dot(optimal_weights, expected_returns)
                
                # Allocation en dollars
                allocations = {}
                for i, symbol in enumerate(symbols):
                    allocation_value = self.available_capital * optimal_weights[i]
                    if allocation_value > 100:  # Minimum $100
                        allocations[symbol] = {
                            'weight': optimal_weights[i],
                            'value': allocation_value,
                            'percentage': optimal_weights[i] * 100
                        }
                
                return {
                    'optimal_weights': dict(zip(symbols, optimal_weights)),
                    'expected_return': optimal_return,
                    'expected_risk': optimal_risk,
                    'sharpe_ratio': optimal_return / optimal_risk if optimal_risk > 0 else 0,
                    'allocations': allocations
                }
            else:
                return {"error": "Optimisation √©chou√©e"}
                
        except Exception as e:
            return {"error": f"Erreur optimisation: {e}"}

    def create_risk_dashboard(self):
        """Cr√©ation dashboard de visualisation des risques"""
        
        if not self.portfolio_positions:
            print("‚ùå Aucune position pour cr√©er le dashboard")
            return
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        fig.suptitle('üõ°Ô∏è SLM TRADE - Dashboard de Gestion des Risques', fontsize=16, fontweight='bold')
        
        # 1. R√©partition du portefeuille
        ax1 = axes[0, 0]
        symbols = list(self.portfolio_positions.keys())
        values = list(self.portfolio_positions.values())
        colors = plt.cm.Set3(np.linspace(0, 1, len(symbols)))
        
        wedges, texts, autotexts = ax1.pie(values, labels=symbols, autopct='%1.1f%%', 
                                          colors=colors, startangle=90)
        ax1.set_title('R√©partition du Portefeuille')
        
        # 2. VaR par position
        ax2 = axes[0, 1]
        individual_vars = []
        for symbol in symbols:
            if symbol in self.returns_data:
                returns = self.returns_data[symbol]
                var = self.calculate_var(returns, 0.95)
                position_var = self.portfolio_positions[symbol] * var
                individual_vars.append(position_var)
            else:
                individual_vars.append(0)
        
        bars = ax2.bar(symbols, individual_vars, color=colors)
        ax2.set_title('VaR 95% par Position')
        ax2.set_ylabel('VaR ($)')
        ax2.tick_params(axis='x', rotation=45)
        
        # 3. Matrice de corr√©lation
        ax3 = axes[1, 0]
        if self.correlation_matrix is not None and len(self.correlation_matrix) > 1:
            sns.heatmap(self.correlation_matrix, annot=True, cmap='RdYlBu_r', 
                       center=0, ax=ax3, square=True)
            ax3.set_title('Matrice de Corr√©lation')
        else:
            ax3.text(0.5, 0.5, 'Donn√©es insuffisantes\npour corr√©lation', 
                    ha='center', va='center', transform=ax3.transAxes)
            ax3.set_title('Matrice de Corr√©lation')
        
        # 4. Analyse de risque
        ax4 = axes[1, 1]
        risk_analysis = self.analyze_portfolio_risk()
        
        risk_metrics = [
            f"VaR Portfolio: ${risk_analysis.get('portfolio_var_95', 0):,.0f}",
            f"VaR %: {risk_analysis.get('var_percentage', 0):.1f}%",
            f"Diversification: {risk_analysis.get('diversification_benefit', 0):.1f}%",
            f"Positions effectives: {risk_analysis.get('effective_positions', 0):.1f}",
            f"Plus grosse position: {risk_analysis.get('largest_position_weight', 0):.1f}%"
        ]
        
        ax4.text(0.1, 0.8, '\n'.join(risk_metrics), transform=ax4.transAxes, 
                fontsize=12, verticalalignment='top')
        ax4.set_title('M√©triques de Risque')
        ax4.axis('off')
        
        plt.tight_layout()
        plt.show()
    
    def generate_risk_report(self):
        """G√©n√©ration rapport complet de risque"""
        
        report = {
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'portfolio_summary': {
                'total_value': sum(self.portfolio_positions.values()),
                'number_of_positions': len(self.portfolio_positions),
                'available_capital': self.available_capital
            }
        }
        
        # Analyse de risque
        if self.portfolio_positions:
            risk_analysis = self.analyze_portfolio_risk()
            report['risk_analysis'] = risk_analysis
            
            # Tests de stress
            stress_results = self.stress_test_portfolio()
            report['stress_tests'] = stress_results
            
            # Alertes
            alerts = self.generate_risk_alerts()
            report['alerts'] = alerts
            
            # Optimisation recommand√©e
            optimization = self.optimize_portfolio_allocation()
            report['optimization_recommendation'] = optimization
        
        return report


def demo_risk_management():
    """D√©monstration du module de gestion des risques"""
    
    print("üöÄ D√âMONSTRATION SLM TRADE - MODULE 5: GESTION DES RISQUES")
    print("=" * 60)
    
    # Initialisation
    risk_manager = SLMRiskManager()
    risk_manager.set_capital(100000)
    
    # Portfolio d'exemple
    test_symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'NVDA']
    print(f"\nüìä Test avec portfolio: {test_symbols}")
    
    # R√©cup√©ration des donn√©es
    risk_manager.fetch_risk_data(test_symbols)
    
    # Portfolio positions d'exemple
    portfolio_positions = {
        'AAPL': 25000,
        'GOOGL': 20000,
        'MSFT': 18000,
        'TSLA': 15000,
        'NVDA': 12000
    }
    
    risk_manager.update_portfolio(portfolio_positions)
    
    # 1. Analyse de risque portefeuille
    print("\nüõ°Ô∏è ANALYSE DE RISQUE PORTEFEUILLE")
    print("-" * 40)
    risk_analysis = risk_manager.analyze_portfolio_risk()
    
    print(f"Valeur portefeuille: ${risk_analysis['portfolio_value']:,.2f}")
    print(f"VaR 95% (1 jour): ${risk_analysis['portfolio_var_95']:,.2f}")
    print(f"VaR en %: {risk_analysis['var_percentage']:.2f}%")
    print(f"B√©n√©fice diversification: {risk_analysis['diversification_benefit']:.1f}%")
    print(f"Positions effectives: {risk_analysis['effective_positions']:.1f}")
    
    # 2. Position sizing optimal
    print("\nüí∞ POSITION SIZING OPTIMAL")
    print("-" * 40)
    for symbol in ['AAPL', 'TSLA']:
        pos_size = risk_manager.calculate_optimal_position_size(symbol)
        print(f"{symbol}:")
        print(f"  Taille recommand√©e: ${pos_size['position_value']:,.0f}")
        print(f"  Nombre d'actions: {pos_size['shares']}")
        print(f"  Poids portfolio: {pos_size['weight']*100:.1f}%")
        print(f"  Volatilit√©: {pos_size.get('asset_volatility', 0)*100:.1f}%")
    
    # 3. Tests de stress
    print("\n‚ö†Ô∏è TESTS DE STRESS")
    print("-" * 40)
    stress_results = risk_manager.stress_test_portfolio()
    
    for scenario, result in stress_results.items():
        print(f"{scenario}:")
        print(f"  Perte: ${result['loss_amount']:,.0f} ({result['loss_percentage']:.1f}%)")
        print(f"  Capital restant: ${result['remaining_capital']:,.0f}")
    
    # 4. Alertes de risque
    print("\nüö® ALERTES DE RISQUE")
    print("-" * 40)
    alerts = risk_manager.generate_risk_alerts()
    
    if alerts:
        for alert in alerts:
            severity_icon = "üî¥" if alert['severity'] == 'HIGH' else "üü°"
            print(f"{severity_icon} {alert['message']}")
            print(f"   Action: {alert['action']}")
    else:
        print("‚úÖ Aucune alerte de risque d√©tect√©e")
    
    # 5. Optimisation portefeuille
    print("\nüéØ OPTIMISATION PORTEFEUILLE")
    print("-" * 40)
    optimization = risk_manager.optimize_portfolio_allocation()
    
    if 'error' not in optimization:
        print(f"Rendement attendu: {optimization['expected_return']*100:.2f}%")
        print(f"Risque attendu: {optimization['expected_risk']*100:.2f}%")
        print(f"Ratio de Sharpe: {optimization['sharpe_ratio']:.2f}")
        
        print("\nAllocation optimale recommand√©e:")
        for symbol, alloc in optimization['allocations'].items():
            print(f"  {symbol}: {alloc['percentage']:.1f}% (${alloc['value']:,.0f})")
    
    # 6. Dashboard visuel
    print("\nüìä G√©n√©ration du dashboard de risque...")
    try:
        risk_manager.create_risk_dashboard()
    except:
        print("Dashboard non disponible dans cet environnement")
    
    # 7. Rapport complet
    print("\nüìã G√âN√âRATION RAPPORT COMPLET")
    print("-" * 40)
    report = risk_manager.generate_risk_report()
    print(f"Rapport g√©n√©r√© le: {report['timestamp']}")
    print(f"Nombre d'alertes: {len(report.get('alerts', []))}")
    
    print("\nüéâ D√©monstration termin√©e!")
    return risk_manager

# Lancement de la d√©monstration
if __name__ == "__main__":
    demo_risk_manager = demo_risk_management()

# Module 6 

"""
SLM TRADE - Module 6: Base de Donn√©es & Syst√®me Complet Final
===========================================================

Ce module final int√®gre tous les modules pr√©c√©dents avec:
- Base de donn√©es SQLite optimis√©e pour trading
- Cache intelligent Redis-like en m√©moire
- Synchronisation multi-sources en temps r√©el
- API unifi√©e pour toutes les fonctionnalit√©s
- Interface web compl√®te
- Syst√®me de notifications avanc√©
"""

import sqlite3
import pandas as pd
import numpy as np
import json
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import yfinance as yf
from dataclasses import dataclass, asdict
import hashlib
import pickle
import logging
from concurrent.futures import ThreadPoolExecutor
import asyncio
from flask import Flask, jsonify, request, render_template_string
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import warnings
warnings.filterwarnings('ignore')

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class TradeSignal:
    """Structure pour les signaux de trading"""
    symbol: str
    timestamp: datetime
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    price: float
    confidence: float
    strategy: str
    timeframe: str
    indicators: Dict[str, float]
    risk_metrics: Dict[str, float]

@dataclass
class Portfolio:
    """Structure pour le portefeuille"""
    cash: float
    positions: Dict[str, Dict[str, float]]  # {symbol: {shares: x, avg_price: y}}
    total_value: float
    daily_pnl: float
    unrealized_pnl: float
    realized_pnl: float

class SLMCache:
    """Syst√®me de cache intelligent pour les donn√©es de trading"""
    
    def __init__(self, max_size: int = 10000, ttl: int = 300):
        self.cache = {}
        self.timestamps = {}
        self.max_size = max_size
        self.ttl = ttl  # Time to live en secondes
        self.access_count = {}
        self._lock = threading.RLock()
    
    def _generate_key(self, *args, **kwargs) -> str:
        """G√©n√®re une cl√© unique pour le cache"""
        key_data = str(args) + str(sorted(kwargs.items()))
        return hashlib.md5(key_data.encode()).hexdigest()
    
    def get(self, key: str) -> Optional[Any]:
        """R√©cup√®re une valeur du cache"""
        with self._lock:
            if key in self.cache:
                # V√©rifier l'expiration
                if time.time() - self.timestamps[key] > self.ttl:
                    self._remove(key)
                    return None
                
                self.access_count[key] = self.access_count.get(key, 0) + 1
                return self.cache[key]
            return None
    
    def set(self, key: str, value: Any) -> None:
        """Stocke une valeur dans le cache"""
        with self._lock:
            # Nettoyage si n√©cessaire
            if len(self.cache) >= self.max_size:
                self._cleanup()
            
            self.cache[key] = value
            self.timestamps[key] = time.time()
            self.access_count[key] = 1
    
    def _remove(self, key: str) -> None:
        """Supprime une entr√©e du cache"""
        self.cache.pop(key, None)
        self.timestamps.pop(key, None)
        self.access_count.pop(key, None)
    
    def _cleanup(self) -> None:
        """Nettoie le cache en supprimant les entr√©es les moins utilis√©es"""
        # Supprimer les entr√©es expir√©es
        current_time = time.time()
        expired_keys = [
            key for key, timestamp in self.timestamps.items()
            if current_time - timestamp > self.ttl
        ]
        for key in expired_keys:
            self._remove(key)
        
        # Si encore trop d'entr√©es, supprimer les moins utilis√©es
        if len(self.cache) >= self.max_size:
            sorted_keys = sorted(self.access_count.items(), key=lambda x: x[1])
            keys_to_remove = [key for key, _ in sorted_keys[:len(sorted_keys)//4]]
            for key in keys_to_remove:
                self._remove(key)
    
    def clear(self) -> None:
        """Vide compl√®tement le cache"""
        with self._lock:
            self.cache.clear()
            self.timestamps.clear()
            self.access_count.clear()
    
    def stats(self) -> Dict[str, Any]:
        """Retourne les statistiques du cache"""
        with self._lock:
            return {
                'size': len(self.cache),
                'max_size': self.max_size,
                'hit_rate': sum(self.access_count.values()) / max(len(self.cache), 1),
                'ttl': self.ttl
            }

class SLMDatabase:
    """Gestionnaire de base de donn√©es optimis√© pour le trading"""
    
    def __init__(self, db_path: str = "slm_trade.db"):
        self.db_path = db_path
        self.cache = SLMCache()
        self._init_database()
    
    def _init_database(self) -> None:
        """Initialise la structure de la base de donn√©es"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Table pour les donn√©es OHLCV
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS market_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    timeframe TEXT NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    volume INTEGER NOT NULL,
                    adj_close REAL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, timestamp, timeframe)
                )
            """)
            
            # Table pour les signaux de trading
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS trading_signals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    signal_type TEXT NOT NULL,
                    price REAL NOT NULL,
                    confidence REAL NOT NULL,
                    strategy TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    indicators TEXT,  -- JSON
                    risk_metrics TEXT,  -- JSON
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour les trades ex√©cut√©s
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS executed_trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    trade_type TEXT NOT NULL,  -- 'BUY' or 'SELL'
                    quantity REAL NOT NULL,
                    price REAL NOT NULL,
                    timestamp DATETIME NOT NULL,
                    commission REAL DEFAULT 0,
                    strategy TEXT,
                    pnl REAL DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour le portefeuille
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS portfolio_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp DATETIME NOT NULL,
                    cash REAL NOT NULL,
                    total_value REAL NOT NULL,
                    daily_pnl REAL NOT NULL,
                    unrealized_pnl REAL NOT NULL,
                    realized_pnl REAL NOT NULL,
                    positions TEXT,  -- JSON
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Table pour les m√©triques de performance
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE NOT NULL,
                    symbol TEXT,
                    strategy TEXT,
                    total_return REAL,
                    sharpe_ratio REAL,
                    max_drawdown REAL,
                    win_rate REAL,
                    profit_factor REAL,
                    var_95 REAL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(date, symbol, strategy)
                )
            """)
            
            # Index pour optimiser les requ√™tes
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_market_data_symbol_time ON market_data(symbol, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_signals_symbol_time ON trading_signals(symbol, timestamp)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol_time ON executed_trades(symbol, timestamp)")
            
            conn.commit()
            logger.info("Base de donn√©es initialis√©e avec succ√®s")
    
    def store_market_data(self, symbol: str, data: pd.DataFrame, timeframe: str) -> None:
        """Stocke les donn√©es de march√©"""
        with sqlite3.connect(self.db_path) as conn:
            try:
                records = []
                for timestamp, row in data.iterrows():
                    records.append((
                        symbol, timestamp, timeframe,
                        float(row['Open']), float(row['High']), 
                        float(row['Low']), float(row['Close']),
                        int(row['Volume']), 
                        float(row.get('Adj Close', row['Close']))
                    ))
                
                conn.executemany("""
                    INSERT OR REPLACE INTO market_data 
                    (symbol, timestamp, timeframe, open, high, low, close, volume, adj_close)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, records)
                
                conn.commit()
                logger.info(f"Stock√© {len(records)} enregistrements pour {symbol} ({timeframe})")
                
            except Exception as e:
                logger.error(f"Erreur lors du stockage des donn√©es de march√©: {e}")
    
    def get_market_data(self, symbol: str, timeframe: str, 
                       start_date: Optional[datetime] = None,
                       end_date: Optional[datetime] = None) -> pd.DataFrame:
        """R√©cup√®re les donn√©es de march√© avec cache"""
        cache_key = self.cache._generate_key(symbol, timeframe, start_date, end_date)
        cached_data = self.cache.get(cache_key)
        if cached_data is not None:
            return cached_data
        
        with sqlite3.connect(self.db_path) as conn:
            query = """
                SELECT timestamp, open, high, low, close, volume, adj_close
                FROM market_data
                WHERE symbol = ? AND timeframe = ?
            """
            params = [symbol, timeframe]
            
            if start_date:
                query += " AND timestamp >= ?"
                params.append(start_date)
            
            if end_date:
                query += " AND timestamp <= ?"
                params.append(end_date)
            
            query += " ORDER BY timestamp"
            
            df = pd.read_sql_query(query, conn, params=params, 
                                 parse_dates=['timestamp'], index_col='timestamp')
            
            if not df.empty:
                df.columns = ['Open', 'High', 'Low', 'Close', 'Volume', 'Adj Close']
                self.cache.set(cache_key, df)
            
            return df
    
    def store_signal(self, signal: TradeSignal) -> None:
        """Stocke un signal de trading"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO trading_signals 
                (symbol, timestamp, signal_type, price, confidence, strategy, timeframe, indicators, risk_metrics)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                signal.symbol, signal.timestamp, signal.signal_type,
                signal.price, signal.confidence, signal.strategy, signal.timeframe,
                json.dumps(signal.indicators), json.dumps(signal.risk_metrics)
            ))
            conn.commit()
    
    def store_trade(self, symbol: str, trade_type: str, quantity: float, 
                   price: float, timestamp: datetime, commission: float = 0,
                   strategy: str = None, pnl: float = 0) -> None:
        """Stocke un trade ex√©cut√©"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO executed_trades 
                (symbol, trade_type, quantity, price, timestamp, commission, strategy, pnl)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (symbol, trade_type, quantity, price, timestamp, commission, strategy, pnl))
            conn.commit()
    
    def store_portfolio_snapshot(self, portfolio: Portfolio, timestamp: datetime) -> None:
        """Stocke un snapshot du portefeuille"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO portfolio_history 
                (timestamp, cash, total_value, daily_pnl, unrealized_pnl, realized_pnl, positions)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                timestamp, portfolio.cash, portfolio.total_value,
                portfolio.daily_pnl, portfolio.unrealized_pnl, 
                portfolio.realized_pnl, json.dumps(portfolio.positions)
            ))
            conn.commit()
    
    def get_latest_signals(self, symbol: str = None, limit: int = 100) -> List[Dict]:
        """R√©cup√®re les derniers signaux"""
        with sqlite3.connect(self.db_path) as conn:
            query = """
                SELECT * FROM trading_signals
                WHERE 1=1
            """
            params = []
            
            if symbol:
                query += " AND symbol = ?"
                params.append(symbol)
            
            query += " ORDER BY timestamp DESC LIMIT ?"
            params.append(limit)
            
            cursor = conn.execute(query, params)
            columns = [description[0] for description in cursor.description]
            
            signals = []
            for row in cursor.fetchall():
                signal_dict = dict(zip(columns, row))
                # Parse JSON fields
                signal_dict['indicators'] = json.loads(signal_dict.get('indicators', '{}'))
                signal_dict['risk_metrics'] = json.loads(signal_dict.get('risk_metrics', '{}'))
                signals.append(signal_dict)
            
            return signals
    
    def get_performance_summary(self, days: int = 30) -> Dict[str, Any]:
        """G√©n√®re un r√©sum√© de performance"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        with sqlite3.connect(self.db_path) as conn:
            # Total des trades
            total_trades = conn.execute("""
                SELECT COUNT(*) FROM executed_trades 
                WHERE timestamp >= ?
            """, (start_date,)).fetchone()[0]
            
            # PnL total
            total_pnl = conn.execute("""
                SELECT COALESCE(SUM(pnl), 0) FROM executed_trades 
                WHERE timestamp >= ?
            """, (start_date,)).fetchone()[0]
            
            # Win rate
            winning_trades = conn.execute("""
                SELECT COUNT(*) FROM executed_trades 
                WHERE timestamp >= ? AND pnl > 0
            """, (start_date,)).fetchone()[0]
            
            win_rate = (winning_trades / max(total_trades, 1)) * 100
            
            # Portfolio evolution
            portfolio_data = pd.read_sql_query("""
                SELECT timestamp, total_value FROM portfolio_history 
                WHERE timestamp >= ? ORDER BY timestamp
            """, conn, params=(start_date,), parse_dates=['timestamp'])
            
            max_value = portfolio_data['total_value'].max() if not portfolio_data.empty else 0
            min_value = portfolio_data['total_value'].min() if not portfolio_data.empty else 0
            current_value = portfolio_data['total_value'].iloc[-1] if not portfolio_data.empty else 0
            
            return {
                'period_days': days,
                'total_trades': total_trades,
                'total_pnl': total_pnl,
                'win_rate': win_rate,
                'current_portfolio_value': current_value,
                'max_portfolio_value': max_value,
                'min_portfolio_value': min_value,
                'drawdown_pct': ((max_value - current_value) / max(max_value, 1)) * 100
            }

class SLMDataSyncManager:
    """Gestionnaire de synchronisation multi-sources"""
    
    def __init__(self, database: SLMDatabase):
        self.database = database
        self.active_symbols = set()
        self.sync_threads = {}
        self.running = False
        self.update_callbacks = []
    
    def add_symbol(self, symbol: str, timeframes: List[str] = ['1h', '1d']) -> None:
        """Ajoute un symbole √† la synchronisation"""
        self.active_symbols.add(symbol)
        
        if self.running:
            self._start_sync_thread(symbol, timeframes)
        
        logger.info(f"Symbole {symbol} ajout√© √† la synchronisation")
    
    def remove_symbol(self, symbol: str) -> None:
        """Retire un symbole de la synchronisation"""
        if symbol in self.active_symbols:
            self.active_symbols.remove(symbol)
            
            if symbol in self.sync_threads:
                # Arr√™ter le thread de synchronisation
                self.sync_threads[symbol]['stop_event'].set()
                del self.sync_threads[symbol]
        
        logger.info(f"Symbole {symbol} retir√© de la synchronisation")
    
    def start_sync(self) -> None:
        """D√©marre la synchronisation en temps r√©el"""
        self.running = True
        
        for symbol in self.active_symbols:
            self._start_sync_thread(symbol, ['1h', '1d'])
        
        logger.info("Synchronisation en temps r√©el d√©marr√©e")
    
    def stop_sync(self) -> None:
        """Arr√™te la synchronisation"""
        self.running = False
        
        for symbol, thread_info in self.sync_threads.items():
            thread_info['stop_event'].set()
        
        self.sync_threads.clear()
        logger.info("Synchronisation arr√™t√©e")
    
    def _start_sync_thread(self, symbol: str, timeframes: List[str]) -> None:
        """D√©marre un thread de synchronisation pour un symbole"""
        if symbol in self.sync_threads:
            return
        
        stop_event = threading.Event()
        thread = threading.Thread(
            target=self._sync_worker,
            args=(symbol, timeframes, stop_event),
            daemon=True
        )
        
        self.sync_threads[symbol] = {
            'thread': thread,
            'stop_event': stop_event
        }
        
        thread.start()
    
    def _sync_worker(self, symbol: str, timeframes: List[str], stop_event: threading.Event) -> None:
        """Worker de synchronisation pour un symbole"""
        while not stop_event.is_set():
            try:
                ticker = yf.Ticker(symbol)
                
                for timeframe in timeframes:
                    # R√©cup√©rer les donn√©es r√©centes
                    data = ticker.history(period="5d", interval=timeframe)
                    
                    if not data.empty:
                        # Stocker en base
                        self.database.store_market_data(symbol, data, timeframe)
                        
                        # Notifier les callbacks
                        for callback in self.update_callbacks:
                            try:
                                callback(symbol, timeframe, data)
                            except Exception as e:
                                logger.error(f"Erreur dans callback: {e}")
                
                # Attendre avant la prochaine mise √† jour
                stop_event.wait(60)  # 1 minute
                
            except Exception as e:
                logger.error(f"Erreur de synchronisation pour {symbol}: {e}")
                stop_event.wait(30)  # Attendre 30s avant de retry
    
    def add_update_callback(self, callback) -> None:
        """Ajoute un callback pour les mises √† jour de donn√©es"""
        self.update_callbacks.append(callback)

class SLMTradeSystemComplete:
    """Syst√®me de trading complet SLM TRADE - Tous modules int√©gr√©s"""
    
    def __init__(self, initial_capital: float = 100000):
        # Initialisation des composants
        self.database = SLMDatabase()
        self.sync_manager = SLMDataSyncManager(self.database)
        
        # Portfolio
        self.portfolio = Portfolio(
            cash=initial_capital,
            positions={},
            total_value=initial_capital,
            daily_pnl=0,
            unrealized_pnl=0,
            realized_pnl=0
        )
        
        # Composants des modules pr√©c√©dents
        from datetime import datetime
        import yfinance as yf
        
        # Configuration
        self.commission_rate = 0.001  # 0.1%
        self.max_risk_per_trade = 0.02  # 2%
        self.active_strategies = ['rsi_mean_reversion', 'ma_crossover', 'bollinger_bounce']
        
        # Threads et √©tat
        self.trading_active = False
        self.monitoring_thread = None
        
        logger.info("Syst√®me SLM TRADE initialis√© avec succ√®s")
    
    def add_symbol_to_watch(self, symbol: str) -> None:
        """Ajoute un symbole √† la surveillance"""
        self.sync_manager.add_symbol(symbol)
        logger.info(f"Symbole {symbol} ajout√© √† la surveillance")
    
    def start_live_trading(self) -> None:
        """D√©marre le trading en temps r√©el"""
        if self.trading_active:
            logger.warning("Le trading est d√©j√† actif")
            return
        
        self.trading_active = True
        
        # D√©marrer la synchronisation des donn√©es
        self.sync_manager.start_sync()
        
        # D√©marrer le monitoring
        self.monitoring_thread = threading.Thread(target=self._trading_loop, daemon=True)
        self.monitoring_thread.start()
        
        logger.info("Trading en temps r√©el d√©marr√©")
    
    def stop_live_trading(self) -> None:
        """Arr√™te le trading en temps r√©el"""
        self.trading_active = False
        self.sync_manager.stop_sync()
        
        if self.monitoring_thread:
            self.monitoring_thread.join(timeout=5)
        
        logger.info("Trading en temps r√©el arr√™t√©")
    
    def _trading_loop(self) -> None:
        """Boucle principale de trading"""
        while self.trading_active:
            try:
                # Analyser chaque symbole surveill√©
                for symbol in self.sync_manager.active_symbols:
                    signals = self._generate_signals(symbol)
                    
                    for signal in signals:
                        if signal.confidence > 0.7:  # Seuil de confiance
                            self._process_signal(signal)
                
                # Mise √† jour du portefeuille
                self._update_portfolio()
                
                # Sauvegarde p√©riodique
                self.database.store_portfolio_snapshot(self.portfolio, datetime.now())
                
                time.sleep(30)  # Attendre 30 secondes
                
            except Exception as e:
                logger.error(f"Erreur dans la boucle de trading: {e}")
                time.sleep(60)
    
    def _generate_signals(self, symbol: str) -> List[TradeSignal]:
        """G√©n√®re des signaux de trading pour un symbole"""
        signals = []
        
        try:
            # R√©cup√©rer les donn√©es
            data_1h = self.database.get_market_data(symbol, '1h')
            data_1d = self.database.get_market_data(symbol, '1d')
            
            if data_1h.empty or data_1d.empty:
                return signals
            
            current_price = data_1h['Close'].iloc[-1]
            
            # Calculer les indicateurs
            indicators = self._calculate_indicators(data_1h)
            risk_metrics = self._calculate_risk_metrics(symbol, data_1d)
            
            # Strat√©gies de trading
            for strategy in self.active_strategies:
                signal_type, confidence = self._evaluate_strategy(strategy, indicators, data_1h)
                
                if signal_type != 'HOLD':
                    signal = TradeSignal(
                        symbol=symbol,
                        timestamp=datetime.now(),
                        signal_type=signal_type,
                        price=current_price,
                        confidence=confidence,
                        strategy=strategy,
                        timeframe='1h',
                        indicators=indicators,
                        risk_metrics=risk_metrics
                    )
                    signals.append(signal)
                    
                    # Stocker le signal
                    self.database.store_signal(signal)
        
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration signaux pour {symbol}: {e}")
        
        return signals
    
    def _calculate_indicators(self, data: pd.DataFrame) -> Dict[str, float]:
        """Calcule les indicateurs techniques"""
        if len(data) < 50:
            return {}
        
        indicators = {}
        
        try:
            # RSI
            delta = data['Close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            indicators['rsi'] = (100 - (100 / (1 + rs))).iloc[-1]
            
            # Moyennes mobiles
            indicators['sma_20'] = data['Close'].rolling(20).mean().iloc[-1]
            indicators['sma_50'] = data['Close'].rolling(50).mean().iloc[-1]
            indicators['ema_12'] = data['Close'].ewm(span=12).mean().iloc[-1]
            indicators['ema_26'] = data['Close'].ewm(span=26).mean().iloc[-1]
            
            # MACD
            macd_line = indicators['ema_12'] - indicators['ema_26']
            signal_line = data['Close'].ewm(span=9).mean().iloc[-1]
            indicators['macd'] = macd_line
            indicators['macd_signal'] = signal_line
            
            # Bollinger Bands
            bb_period = 20
            bb_std = 2
            sma = data['Close'].rolling(bb_period).mean()
            std = data['Close'].rolling(bb_period).std()
            indicators['bb_upper'] = (sma + (std * bb_std)).iloc[-1]
            indicators['bb_lower'] = (sma - (std * bb_std)).iloc[-1]
            indicators['bb_middle'] = sma.iloc[-1]
            
            # Prix actuel
            indicators['current_price'] = data['Close'].iloc[-1]
            
        except Exception as e:
            logger.error(f"Erreur calcul indicateurs: {e}")
        
        return indicators
    
    def _calculate_risk_metrics(self, symbol: str, data: pd.DataFrame) -> Dict[str, float]:
        """Calcule les m√©triques de risque"""
        if len(data) < 30:
            return {}
        
        metrics = {}
        
        try:
            returns = data['Close'].pct_change().dropna()
            
            # Volatilit√©
            metrics['volatility'] = returns.std() * np.sqrt(252)
            
            # VaR 95%
            metrics['var_95'] = np.percentile(returns, 5)
            
            # Maximum Drawdown
            cumulative = (1 + returns).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            metrics['max_drawdown'] = drawdown.min()
            
            # Beta (vs SPY approximation)
            metrics['beta'] = 1.0  # Approximation
            
        except Exception as e:
            logger.error(f"Erreur calcul m√©triques risque: {e}")
        
        return metrics
    
    def _evaluate_strategy(self, strategy: str, indicators: Dict[str, float], data: pd.DataFrame) -> Tuple[str, float]:
        """√âvalue une strat√©gie de trading"""
        if not indicators:
            return 'HOLD', 0.0
        
        try:
            if strategy == 'rsi_mean_reversion':
                rsi = indicators.get('rsi', 50)
                if rsi < 30:
                    return 'BUY', min(0.8, (30 - rsi) / 20)
                elif rsi > 70:
                    return 'SELL', min(0.8, (rsi - 70) / 20)
            
            elif strategy == 'ma_crossover':
                sma_20 = indicators.get('sma_20', 0)
                sma_50 = indicators.get('sma_50', 0)
                current_price = indicators.get('current_price', 0)
                
                if sma_20 > sma_50 and current_price > sma_20:
                    return 'BUY', 0.6
                elif sma_20 < sma_50 and current_price < sma_20:
                    return 'SELL', 0.6
            
            elif strategy == 'bollinger_bounce':
                current_price = indicators.get('current_price', 0)
                bb_upper = indicators.get('bb_upper', 0)
                bb_lower = indicators.get('bb_lower', 0)
                bb_middle = indicators.get('bb_middle', 0)
                
                if current_price <= bb_lower:
                    return 'BUY', 0.7
                elif current_price >= bb_upper:
                    return 'SELL', 0.7
        
        except Exception as e:
            logger.error(f"Erreur √©valuation strat√©gie {strategy}: {e}")
        
        return 'HOLD', 0.0
    
    def _process_signal(self, signal: TradeSignal) -> None:
        """Traite un signal de trading et ex√©cute si n√©cessaire"""
        try:
            # V√©rifier si on a d√©j√† une position
            current_position = self.portfolio.positions.get(signal.symbol, {'shares': 0, 'avg_price': 0})
            
            # Calculer la taille de position
            risk_amount = self.portfolio.total_value * self.max_risk_per_trade
            volatility = signal.risk_metrics.get('volatility', 0.2)
            
            # Position sizing bas√© sur la volatilit√©
            position_size = min(
                int(risk_amount / (signal.price * volatility)),
                int(self.portfolio.cash / signal.price * 0.25)  # Max 25% du cash
            )
            
            if signal.signal_type == 'BUY' and current_position['shares'] <= 0 and position_size > 0:
                self._execute_buy(signal.symbol, position_size, signal.price, signal.strategy)
                
            elif signal.signal_type == 'SELL' and current_position['shares'] > 0:
                self._execute_sell(signal.symbol, current_position['shares'], signal.price, signal.strategy)
                
        except Exception as e:
            logger.error(f"Erreur traitement signal: {e}")
    
    def _execute_buy(self, symbol: str, quantity: int, price: float, strategy: str) -> None:
        """Ex√©cute un ordre d'achat"""
        try:
            total_cost = quantity * price
            commission = total_cost * self.commission_rate
            total_with_commission = total_cost + commission
            
            if self.portfolio.cash >= total_with_commission:
                # Mise √† jour du portefeuille
                self.portfolio.cash -= total_with_commission
                
                if symbol in self.portfolio.positions:
                    # Position existante - moyenne pond√©r√©e
                    old_shares = self.portfolio.positions[symbol]['shares']
                    old_price = self.portfolio.positions[symbol]['avg_price']
                    
                    new_shares = old_shares + quantity
                    new_avg_price = ((old_shares * old_price) + total_cost) / new_shares
                    
                    self.portfolio.positions[symbol] = {
                        'shares': new_shares,
                        'avg_price': new_avg_price
                    }
                else:
                    # Nouvelle position
                    self.portfolio.positions[symbol] = {
                        'shares': quantity,
                        'avg_price': price
                    }
                
                # Enregistrer le trade
                self.database.store_trade(
                    symbol=symbol,
                    trade_type='BUY',
                    quantity=quantity,
                    price=price,
                    timestamp=datetime.now(),
                    commission=commission,
                    strategy=strategy
                )
                
                logger.info(f"ACHAT ex√©cut√©: {quantity} {symbol} @ {price:.2f}")
            
        except Exception as e:
            logger.error(f"Erreur ex√©cution achat: {e}")
    
    def _execute_sell(self, symbol: str, quantity: int, price: float, strategy: str) -> None:
        """Ex√©cute un ordre de vente"""
        try:
            if symbol in self.portfolio.positions and self.portfolio.positions[symbol]['shares'] >= quantity:
                total_proceeds = quantity * price
                commission = total_proceeds * self.commission_rate
                net_proceeds = total_proceeds - commission
                
                # Calculer le PnL
                avg_price = self.portfolio.positions[symbol]['avg_price']
                pnl = (price - avg_price) * quantity - commission
                
                # Mise √† jour du portefeuille
                self.portfolio.cash += net_proceeds
                self.portfolio.realized_pnl += pnl
                
                # Mise √† jour de la position
                remaining_shares = self.portfolio.positions[symbol]['shares'] - quantity
                if remaining_shares > 0:
                    self.portfolio.positions[symbol]['shares'] = remaining_shares
                else:
                    del self.portfolio.positions[symbol]
                
                # Enregistrer le trade
                self.database.store_trade(
                    symbol=symbol,
                    trade_type='SELL',
                    quantity=quantity,
                    price=price,
                    timestamp=datetime.now(),
                    commission=commission,
                    strategy=strategy,
                    pnl=pnl
                )
                
                logger.info(f"VENTE ex√©cut√©e: {quantity} {symbol} @ {price:.2f} | PnL: {pnl:.2f}")
            
        except Exception as e:
            logger.error(f"Erreur ex√©cution vente: {e}")
    
    def _update_portfolio(self) -> None:
        """Met √† jour la valeur du portefeuille"""
        try:
            total_value = self.portfolio.cash
            unrealized_pnl = 0
            
            for symbol, position in self.portfolio.positions.items():
                try:
                    # R√©cup√©rer le prix actuel
                    recent_data = self.database.get_market_data(symbol, '1h')
                    if not recent_data.empty:
                        current_price = recent_data['Close'].iloc[-1]
                        position_value = position['shares'] * current_price
                        total_value += position_value
                        
                        # PnL non r√©alis√©
                        position_pnl = (current_price - position['avg_price']) * position['shares']
                        unrealized_pnl += position_pnl
                        
                except Exception as e:
                    logger.warning(f"Erreur mise √† jour prix {symbol}: {e}")
            
            # Calculer le PnL journalier
            previous_value = self.portfolio.total_value
            daily_pnl = total_value - previous_value
            
            # Mise √† jour
            self.portfolio.total_value = total_value
            self.portfolio.unrealized_pnl = unrealized_pnl
            self.portfolio.daily_pnl = daily_pnl
            
        except Exception as e:
            logger.error(f"Erreur mise √† jour portefeuille: {e}")
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """G√©n√®re les donn√©es pour le dashboard"""
        try:
            # Performance summary
            performance = self.database.get_performance_summary(30)
            
            # Signaux r√©cents
            recent_signals = self.database.get_latest_signals(limit=20)
            
            # Portfolio current state
            portfolio_data = {
                'cash': self.portfolio.cash,
                'total_value': self.portfolio.total_value,
                'daily_pnl': self.portfolio.daily_pnl,
                'unrealized_pnl': self.portfolio.unrealized_pnl,
                'realized_pnl': self.portfolio.realized_pnl,
                'positions': self.portfolio.positions,
                'position_count': len(self.portfolio.positions)
            }
            
            # Cache stats
            cache_stats = self.database.cache.stats()
            
            return {
                'timestamp': datetime.now().isoformat(),
                'performance': performance,
                'portfolio': portfolio_data,
                'recent_signals': recent_signals,
                'cache_stats': cache_stats,
                'active_symbols': list(self.sync_manager.active_symbols),
                'trading_active': self.trading_active
            }
            
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration dashboard: {e}")
            return {}
    
    def create_performance_chart(self, days: int = 30) -> str:
        """Cr√©e un graphique de performance"""
        try:
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)
            
            with sqlite3.connect(self.database.db_path) as conn:
                portfolio_data = pd.read_sql_query("""
                    SELECT timestamp, total_value, daily_pnl, unrealized_pnl
                    FROM portfolio_history 
                    WHERE timestamp >= ? 
                    ORDER BY timestamp
                """, conn, params=(start_date,), parse_dates=['timestamp'])
            
            if portfolio_data.empty:
                return "<div>Pas de donn√©es de performance disponibles</div>"
            
            # Cr√©er le graphique
            fig = make_subplots(
                rows=2, cols=1,
                subplot_titles=['Valeur du Portefeuille', 'PnL Journalier'],
                vertical_spacing=0.1
            )
            
            # Courbe de valeur du portefeuille
            fig.add_trace(
                go.Scatter(
                    x=portfolio_data['timestamp'],
                    y=portfolio_data['total_value'],
                    mode='lines',
                    name='Valeur Totale',
                    line=dict(color='blue', width=2)
                ),
                row=1, col=1
            )
            
            # PnL journalier
            colors = ['green' if x >= 0 else 'red' for x in portfolio_data['daily_pnl']]
            fig.add_trace(
                go.Bar(
                    x=portfolio_data['timestamp'],
                    y=portfolio_data['daily_pnl'],
                    name='PnL Journalier',
                    marker_color=colors
                ),
                row=2, col=1
            )
            
            fig.update_layout(
                title='Performance du Portefeuille SLM TRADE',
                height=600,
                showlegend=True
            )
            
            return fig.to_html(include_plotlyjs='cdn')
            
        except Exception as e:
            logger.error(f"Erreur cr√©ation graphique: {e}")
            return f"<div>Erreur g√©n√©ration graphique: {e}</div>"

# Interface Web Flask
class SLMWebInterface:
    """Interface web pour SLM TRADE"""
    
    def __init__(self, trading_system: SLMTradeSystemComplete):
        self.trading_system = trading_system
        self.app = Flask(__name__)
        self._setup_routes()
    
    def _setup_routes(self):
        """Configure les routes de l'interface web"""
        
        @self.app.route('/')
        def dashboard():
            """Page principale du dashboard"""
            dashboard_html = """
            <!DOCTYPE html>
            <html>
            <head>
                <title>SLM TRADE - Dashboard</title>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
                <style>
                    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
                    .container { max-width: 1200px; margin: 0 auto; }
                    .header { text-align: center; color: #2c3e50; margin-bottom: 30px; }
                    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
                    .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                    .card h3 { margin-top: 0; color: #34495e; }
                    .value { font-size: 24px; font-weight: bold; }
                    .positive { color: #27ae60; }
                    .negative { color: #e74c3c; }
                    .neutral { color: #95a5a6; }
                    .chart-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
                    .signals-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
                    .signals-table th, .signals-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                    .signals-table th { background-color: #f8f9fa; }
                    .signal-buy { color: #27ae60; font-weight: bold; }
                    .signal-sell { color: #e74c3c; font-weight: bold; }
                    .signal-hold { color: #95a5a6; }
                    .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
                    .btn { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; margin-right: 10px; }
                    .btn-primary { background: #3498db; color: white; }
                    .btn-success { background: #27ae60; color: white; }
                    .btn-danger { background: #e74c3c; color: white; }
                    .btn:hover { opacity: 0.8; }
                    input[type="text"] { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px; }
                </style>
            </head>
            <body>
                <div class="container">
                    <div class="header">
                        <h1>üöÄ SLM TRADE - Syst√®me de Trading Algorithmique</h1>
                        <p>Dashboard de Trading Professionnel avec IA</p>
                    </div>
                    
                    <div class="controls">
                        <h3>Contr√¥les du Syst√®me</h3>
                        <button class="btn btn-success" onclick="startTrading()">‚ñ∂Ô∏è D√©marrer Trading</button>
                        <button class="btn btn-danger" onclick="stopTrading()">‚èπÔ∏è Arr√™ter Trading</button>
                        <input type="text" id="symbolInput" placeholder="Symbole (ex: AAPL)">
                        <button class="btn btn-primary" onclick="addSymbol()">‚ûï Ajouter Symbole</button>
                        <button class="btn btn-primary" onclick="refreshData()">üîÑ Actualiser</button>
                    </div>
                    
                    <div class="stats-grid" id="statsGrid">
                        <!-- Stats will be loaded here -->
                    </div>
                    
                    <div class="chart-container">
                        <h3>üìà Performance du Portefeuille</h3>
                        <div id="performanceChart"></div>
                    </div>
                    
                    <div class="card">
                        <h3>üéØ Signaux de Trading R√©cents</h3>
                        <div id="signalsTable"></div>
                    </div>
                </div>
                
                <script>
                    function loadDashboard() {
                        fetch('/api/dashboard')
                            .then(response => response.json())
                            .then(data => updateDashboard(data))
                            .catch(error => console.error('Error:', error));
                    }
                    
                    function updateDashboard(data) {
                        // Update stats
                        const statsGrid = document.getElementById('statsGrid');
                        const portfolio = data.portfolio;
                        const performance = data.performance;
                        
                        statsGrid.innerHTML = `
                            <div class="card">
                                <h3>üí∞ Valeur Totale</h3>
                                <div class="value">${portfolio.total_value.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}</div>
                            </div>
                            <div class="card">
                                <h3>üìä PnL Journalier</h3>
                                <div class="value ${portfolio.daily_pnl >= 0 ? 'positive' : 'negative'}">
                                    ${portfolio.daily_pnl.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}
                                </div>
                            </div>
                            <div class="card">
                                <h3>üí∏ Liquidit√©s</h3>
                                <div class="value">${portfolio.cash.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}</div>
                            </div>
                            <div class="card">
                                <h3>üìà PnL Non R√©alis√©</h3>
                                <div class="value ${portfolio.unrealized_pnl >= 0 ? 'positive' : 'negative'}">
                                    ${portfolio.unrealized_pnl.toLocaleString('fr-FR', {style: 'currency', currency: 'USD'})}
                                </div>
                            </div>
                            <div class="card">
                                <h3>üéØ Win Rate</h3>
                                <div class="value">${performance.win_rate.toFixed(1)}%</div>
                            </div>
                            <div class="card">
                                <h3>üìä Positions Actives</h3>
                                <div class="value">${portfolio.position_count}</div>
                            </div>
                        `;
                        
                        // Update signals table
                        const signalsTable = document.getElementById('signalsTable');
                        let tableHTML = '<table class="signals-table"><tr><th>Symbole</th><th>Signal</th><th>Prix</th><th>Confiance</th><th>Strat√©gie</th><th>Timestamp</th></tr>';
                        
                        data.recent_signals.slice(0, 10).forEach(signal => {
                            const signalClass = signal.signal_type === 'BUY' ? 'signal-buy' : 
                                              signal.signal_type === 'SELL' ? 'signal-sell' : 'signal-hold';
                            tableHTML += `
                                <tr>
                                    <td>${signal.symbol}</td>
                                    <td class="${signalClass}">${signal.signal_type}</td>
                                    <td>${signal.price.toFixed(2)}</td>
                                    <td>${(signal.confidence * 100).toFixed(1)}%</td>
                                    <td>${signal.strategy}</td>
                                    <td>${new Date(signal.timestamp).toLocaleString()}</td>
                                </tr>
                            `;
                        });
                        tableHTML += '</table>';
                        signalsTable.innerHTML = tableHTML;
                    }
                    
                    function startTrading() {
                        fetch('/api/start-trading', {method: 'POST'})
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                loadDashboard();
                            });
                    }
                    
                    function stopTrading() {
                        fetch('/api/stop-trading', {method: 'POST'})
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                loadDashboard();
                            });
                    }
                    
                    function addSymbol() {
                        const symbol = document.getElementById('symbolInput').value.toUpperCase();
                        if (symbol) {
                            fetch('/api/add-symbol', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({symbol: symbol})
                            })
                            .then(response => response.json())
                            .then(data => {
                                alert(data.message);
                                document.getElementById('symbolInput').value = '';
                                loadDashboard();
                            });
                        }
                    }
                    
                    function refreshData() {
                        loadDashboard();
                    }
                    
                    function loadPerformanceChart() {
                        fetch('/api/performance-chart')
                            .then(response => response.text())
                            .then(html => {
                                document.getElementById('performanceChart').innerHTML = html;
                            });
                    }
                    
                    // Auto-refresh every 30 seconds
                    setInterval(loadDashboard, 30000);
                    
                    // Initial load
                    loadDashboard();
                    loadPerformanceChart();
                </script>
            </body>
            </html>
            """
            return dashboard_html
        
        @self.app.route('/api/dashboard')
        def api_dashboard():
            """API endpoint pour les donn√©es du dashboard"""
            return jsonify(self.trading_system.get_dashboard_data())
        
        @self.app.route('/api/start-trading', methods=['POST'])
        def api_start_trading():
            """API endpoint pour d√©marrer le trading"""
            try:
                self.trading_system.start_live_trading()
                return jsonify({'status': 'success', 'message': 'Trading d√©marr√© avec succ√®s'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/stop-trading', methods=['POST'])
        def api_stop_trading():
            """API endpoint pour arr√™ter le trading"""
            try:
                self.trading_system.stop_live_trading()
                return jsonify({'status': 'success', 'message': 'Trading arr√™t√© avec succ√®s'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/add-symbol', methods=['POST'])
        def api_add_symbol():
            """API endpoint pour ajouter un symbole"""
            try:
                data = request.get_json()
                symbol = data.get('symbol', '').upper()
                if symbol:
                    self.trading_system.add_symbol_to_watch(symbol)
                    return jsonify({'status': 'success', 'message': f'Symbole {symbol} ajout√©'})
                else:
                    return jsonify({'status': 'error', 'message': 'Symbole invalide'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})
        
        @self.app.route('/api/performance-chart')
        def api_performance_chart():
            """API endpoint pour le graphique de performance"""
            return self.trading_system.create_performance_chart()
    
    def run(self, host='localhost', port=5000, debug=False):
        """Lance l'interface web"""
        logger.info(f"Interface web d√©marr√©e sur http://{host}:{port}")
        self.app.run(host=host, port=port, debug=debug)

# Fonction principale d'initialisation
def initialize_slm_trade_complete(initial_capital: float = 100000, 
                                web_interface: bool = True) -> SLMTradeSystemComplete:
    """
    Initialise le syst√®me complet SLM TRADE
    
    Args:
        initial_capital: Capital initial pour le trading
        web_interface: Si True, lance l'interface web
    
    Returns:
        Instance du syst√®me de trading complet
    """
    print("üöÄ Initialisation du Syst√®me SLM TRADE Complet...")
    print("=" * 60)
    
    # Cr√©er le syst√®me de trading
    trading_system = SLMTradeSystemComplete(initial_capital)
    
    # Ajouter quelques symboles populaires par d√©faut
    default_symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN']
    for symbol in default_symbols:
        trading_system.add_symbol_to_watch(symbol)
    
    print(f"‚úÖ Syst√®me initialis√© avec {len(default_symbols)} symboles")
    print(f"üí∞ Capital initial: ${initial_capital:,.2f}")
    print(f"üéØ Strat√©gies actives: {len(trading_system.active_strategies)}")
    
    # Lancer l'interface web si demand√©e
    if web_interface:
        web_app = SLMWebInterface(trading_system)
        print("\nüåê Interface Web disponible sur: http://localhost:5000")
        print("üìä Dashboard en temps r√©el avec toutes les m√©triques")
        
        # Lancer dans un thread s√©par√© pour ne pas bloquer
        web_thread = threading.Thread(
            target=lambda: web_app.run(host='0.0.0.0', port=5000, debug=False),
            daemon=True
        )
        web_thread.start()
        
        print("\n‚ö° Pour d√©marrer le trading automatique, utilisez l'interface web ou:")
        print("   trading_system.start_live_trading()")
    
    print("\nüéâ Syst√®me SLM TRADE pr√™t √† l'utilisation!")
    print("=" * 60)
    
    return trading_system

# Exemple d'utilisation compl√®te
if __name__ == "__main__":
    # Initialiser le syst√®me complet
    slm_system = initialize_slm_trade_complete(
        initial_capital=100000,
        web_interface=True
    )
    
    # Garder le programme en vie
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nüõë Arr√™t du syst√®me...")
        slm_system.stop_live_trading()
        print("‚úÖ Syst√®me arr√™t√© proprement")    